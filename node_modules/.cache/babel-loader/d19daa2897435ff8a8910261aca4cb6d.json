{"ast":null,"code":"const assert = require('assert');\n\nconst convertSourceMap = require('convert-source-map');\n\nconst util = require('util');\n\nconst debuglog = util.debuglog('c8');\n\nconst {\n  dirname,\n  isAbsolute,\n  join,\n  resolve\n} = require('path');\n\nconst {\n  fileURLToPath\n} = require('url');\n\nconst CovBranch = require('./branch');\n\nconst CovFunction = require('./function');\n\nconst CovSource = require('./source');\n\nconst {\n  sliceRange\n} = require('./range');\n\nconst compatError = Error(`requires Node.js ${require('../package.json').engines.node}`);\n\nlet readFile = () => {\n  throw compatError;\n};\n\ntry {\n  readFile = require('fs').promises.readFile;\n} catch (_err) {// most likely we're on an older version of Node.js.\n}\n\nconst {\n  SourceMapConsumer\n} = require('source-map');\n\nconst isOlderNode10 = /^v10\\.(([0-9]\\.)|(1[0-5]\\.))/u.test(process.version);\nconst isNode8 = /^v8\\./.test(process.version); // Injected when Node.js is loading script into isolate pre Node 10.16.x.\n// see: https://github.com/nodejs/node/pull/21573.\n\nconst cjsWrapperLength = isOlderNode10 ? require('module').wrapper[0].length : 0;\nmodule.exports = class V8ToIstanbul {\n  constructor(scriptPath, wrapperLength, sources, excludePath) {\n    assert(typeof scriptPath === 'string', 'scriptPath must be a string');\n    assert(!isNode8, 'This module does not support node 8 or lower, please upgrade to node 10');\n    this.path = parsePath(scriptPath);\n    this.wrapperLength = wrapperLength === undefined ? cjsWrapperLength : wrapperLength;\n\n    this.excludePath = excludePath || (() => false);\n\n    this.sources = sources || {};\n    this.generatedLines = [];\n    this.branches = {};\n    this.functions = {};\n    this.covSources = [];\n    this.rawSourceMap = undefined;\n    this.sourceMap = undefined;\n    this.sourceTranspiled = undefined; // Indicate that this report was generated with placeholder data from\n    // running --all:\n\n    this.all = false;\n  }\n\n  async load() {\n    const rawSource = this.sources.source || (await readFile(this.path, 'utf8'));\n    this.rawSourceMap = this.sources.sourceMap || // if we find a source-map (either inline, or a .map file) we load\n    // both the transpiled and original source, both of which are used during\n    // the backflips we perform to remap absolute to relative positions.\n    convertSourceMap.fromSource(rawSource) || convertSourceMap.fromMapFileSource(rawSource, dirname(this.path));\n\n    if (this.rawSourceMap) {\n      if (this.rawSourceMap.sourcemap.sources.length > 1) {\n        this.sourceMap = await new SourceMapConsumer(this.rawSourceMap.sourcemap);\n\n        if (!this.sourceMap.sourcesContent) {\n          this.sourceMap.sourcesContent = await this.sourcesContentFromSources();\n        }\n\n        this.covSources = this.sourceMap.sourcesContent.map((rawSource, i) => ({\n          source: new CovSource(rawSource, this.wrapperLength),\n          path: this.sourceMap.sources[i]\n        }));\n        this.sourceTranspiled = new CovSource(rawSource, this.wrapperLength);\n      } else {\n        const candidatePath = this.rawSourceMap.sourcemap.sources.length >= 1 ? this.rawSourceMap.sourcemap.sources[0] : this.rawSourceMap.sourcemap.file;\n        this.path = this._resolveSource(this.rawSourceMap, candidatePath || this.path);\n        this.sourceMap = await new SourceMapConsumer(this.rawSourceMap.sourcemap);\n        let originalRawSource;\n\n        if (this.sources.sourceMap && this.sources.sourceMap.sourcemap && this.sources.sourceMap.sourcemap.sourcesContent && this.sources.sourceMap.sourcemap.sourcesContent.length === 1) {\n          // If the sourcesContent field has been provided, return it rather than attempting\n          // to load the original source from disk.\n          // TODO: investigate whether there's ever a case where we hit this logic with 1:many sources.\n          originalRawSource = this.sources.sourceMap.sourcemap.sourcesContent[0];\n        } else if (this.sources.originalSource) {\n          // Original source may be populated on the sources object.\n          originalRawSource = this.sources.originalSource;\n        } else if (this.sourceMap.sourcesContent && this.sourceMap.sourcesContent[0]) {\n          // perhaps we loaded sourcesContent was populated by an inline source map, or .map file?\n          // TODO: investigate whether there's ever a case where we hit this logic with 1:many sources.\n          originalRawSource = this.sourceMap.sourcesContent[0];\n        } else {\n          // We fallback to reading the original source from disk.\n          originalRawSource = await readFile(this.path, 'utf8');\n        }\n\n        this.covSources = [{\n          source: new CovSource(originalRawSource, this.wrapperLength),\n          path: this.path\n        }];\n        this.sourceTranspiled = new CovSource(rawSource, this.wrapperLength);\n      }\n    } else {\n      this.covSources = [{\n        source: new CovSource(rawSource, this.wrapperLength),\n        path: this.path\n      }];\n    }\n  }\n\n  async sourcesContentFromSources() {\n    const fileList = this.sourceMap.sources.map(relativePath => {\n      const realPath = this._resolveSource(this.rawSourceMap, relativePath);\n\n      return readFile(realPath, 'utf-8').then(result => result).catch(err => {\n        debuglog(`failed to load ${realPath}: ${err.message}`);\n      });\n    });\n    return await Promise.all(fileList);\n  }\n\n  destroy() {\n    if (this.sourceMap) {\n      this.sourceMap.destroy();\n      this.sourceMap = undefined;\n    }\n  }\n\n  _resolveSource(rawSourceMap, sourcePath) {\n    if (sourcePath.startsWith('file://')) {\n      return fileURLToPath(sourcePath);\n    }\n\n    sourcePath = sourcePath.replace(/^webpack:\\/\\//, '');\n    const sourceRoot = rawSourceMap.sourcemap.sourceRoot ? rawSourceMap.sourcemap.sourceRoot.replace('file://', '') : '';\n    const candidatePath = join(sourceRoot, sourcePath);\n\n    if (isAbsolute(candidatePath)) {\n      return candidatePath;\n    } else {\n      return resolve(dirname(this.path), candidatePath);\n    }\n  }\n\n  applyCoverage(blocks) {\n    blocks.forEach(block => {\n      block.ranges.forEach((range, i) => {\n        const {\n          startCol,\n          endCol,\n          path,\n          covSource\n        } = this._maybeRemapStartColEndCol(range);\n\n        if (this.excludePath(path)) {\n          return;\n        }\n\n        let lines;\n\n        if (block.functionName === '(empty-report)') {\n          // (empty-report), this will result in a report that has all lines zeroed out.\n          lines = covSource.lines.filter(line => {\n            line.count = 0;\n            return true;\n          });\n          this.all = lines.length > 0;\n        } else {\n          lines = sliceRange(covSource.lines, startCol, endCol);\n        }\n\n        if (!lines.length) {\n          return;\n        }\n\n        const startLineInstance = lines[0];\n        const endLineInstance = lines[lines.length - 1];\n\n        if (block.isBlockCoverage) {\n          this.branches[path] = this.branches[path] || []; // record branches.\n\n          this.branches[path].push(new CovBranch(startLineInstance.line, startCol - startLineInstance.startCol, endLineInstance.line, endCol - endLineInstance.startCol, range.count)); // if block-level granularity is enabled, we still create a single\n          // CovFunction tracking object for each set of ranges.\n\n          if (block.functionName && i === 0) {\n            this.functions[path] = this.functions[path] || [];\n            this.functions[path].push(new CovFunction(block.functionName, startLineInstance.line, startCol - startLineInstance.startCol, endLineInstance.line, endCol - endLineInstance.startCol, range.count));\n          }\n        } else if (block.functionName) {\n          this.functions[path] = this.functions[path] || []; // record functions.\n\n          this.functions[path].push(new CovFunction(block.functionName, startLineInstance.line, startCol - startLineInstance.startCol, endLineInstance.line, endCol - endLineInstance.startCol, range.count));\n        } // record the lines (we record these as statements, such that we're\n        // compatible with Istanbul 2.0).\n\n\n        lines.forEach(line => {\n          // make sure branch spans entire line; don't record 'goodbye'\n          // branch in `const foo = true ? 'hello' : 'goodbye'` as a\n          // 0 for line coverage.\n          //\n          // All lines start out with coverage of 1, and are later set to 0\n          // if they are not invoked; line.ignore prevents a line from being\n          // set to 0, and is set if the special comment /* c8 ignore next */\n          // is used.\n          if (startCol <= line.startCol && endCol >= line.endCol && !line.ignore) {\n            line.count = range.count;\n          }\n        });\n      });\n    });\n  }\n\n  _maybeRemapStartColEndCol(range) {\n    let covSource = this.covSources[0].source;\n    let startCol = Math.max(0, range.startOffset - covSource.wrapperLength);\n    let endCol = Math.min(covSource.eof, range.endOffset - covSource.wrapperLength);\n    let path = this.path;\n\n    if (this.sourceMap) {\n      startCol = Math.max(0, range.startOffset - this.sourceTranspiled.wrapperLength);\n      endCol = Math.min(this.sourceTranspiled.eof, range.endOffset - this.sourceTranspiled.wrapperLength);\n      const {\n        startLine,\n        relStartCol,\n        endLine,\n        relEndCol,\n        source\n      } = this.sourceTranspiled.offsetToOriginalRelative(this.sourceMap, startCol, endCol);\n      const matchingSource = this.covSources.find(covSource => covSource.path === source);\n      covSource = matchingSource ? matchingSource.source : this.covSources[0].source;\n      path = matchingSource ? matchingSource.path : this.covSources[0].path; // next we convert these relative positions back to absolute positions\n      // in the original source (which is the format expected in the next step).\n\n      startCol = covSource.relativeToOffset(startLine, relStartCol);\n      endCol = covSource.relativeToOffset(endLine, relEndCol);\n    }\n\n    return {\n      path,\n      covSource,\n      startCol,\n      endCol\n    };\n  }\n\n  getInnerIstanbul(source, path) {\n    // We apply the \"Resolving Sources\" logic (as defined in\n    // sourcemaps.info/spec.html) as a final step for 1:many source maps.\n    // for 1:1 source maps, the resolve logic is applied while loading.\n    //\n    // TODO: could we move the resolving logic for 1:1 source maps to the final\n    // step as well? currently this breaks some tests in c8.\n    let resolvedPath = path;\n\n    if (this.rawSourceMap && this.rawSourceMap.sourcemap.sources.length > 1) {\n      resolvedPath = this._resolveSource(this.rawSourceMap, path);\n    }\n\n    if (this.excludePath(resolvedPath)) {\n      return;\n    }\n\n    return {\n      [resolvedPath]: {\n        path: resolvedPath,\n        all: this.all,\n        ...this._statementsToIstanbul(source, path),\n        ...this._branchesToIstanbul(source, path),\n        ...this._functionsToIstanbul(source, path)\n      }\n    };\n  }\n\n  toIstanbul() {\n    return this.covSources.reduce((istanbulOuter, _ref) => {\n      let {\n        source,\n        path\n      } = _ref;\n      return Object.assign(istanbulOuter, this.getInnerIstanbul(source, path));\n    }, {});\n  }\n\n  _statementsToIstanbul(source, path) {\n    const statements = {\n      statementMap: {},\n      s: {}\n    };\n    source.lines.forEach((line, index) => {\n      statements.statementMap[`${index}`] = line.toIstanbul();\n      statements.s[`${index}`] = line.count;\n    });\n    return statements;\n  }\n\n  _branchesToIstanbul(source, path) {\n    const branches = {\n      branchMap: {},\n      b: {}\n    };\n    this.branches[path] = this.branches[path] || [];\n    this.branches[path].forEach((branch, index) => {\n      const srcLine = source.lines[branch.startLine - 1];\n      const ignore = srcLine === undefined ? true : srcLine.ignore;\n      branches.branchMap[`${index}`] = branch.toIstanbul();\n      branches.b[`${index}`] = [ignore ? 1 : branch.count];\n    });\n    return branches;\n  }\n\n  _functionsToIstanbul(source, path) {\n    const functions = {\n      fnMap: {},\n      f: {}\n    };\n    this.functions[path] = this.functions[path] || [];\n    this.functions[path].forEach((fn, index) => {\n      const srcLine = source.lines[fn.startLine - 1];\n      const ignore = srcLine === undefined ? true : srcLine.ignore;\n      functions.fnMap[`${index}`] = fn.toIstanbul();\n      functions.f[`${index}`] = ignore ? 1 : fn.count;\n    });\n    return functions;\n  }\n\n};\n\nfunction parsePath(scriptPath) {\n  return scriptPath.startsWith('file://') ? fileURLToPath(scriptPath) : scriptPath;\n}","map":{"version":3,"names":["assert","require","convertSourceMap","util","debuglog","dirname","isAbsolute","join","resolve","fileURLToPath","CovBranch","CovFunction","CovSource","sliceRange","compatError","Error","engines","node","readFile","promises","_err","SourceMapConsumer","isOlderNode10","test","process","version","isNode8","cjsWrapperLength","wrapper","length","module","exports","V8ToIstanbul","constructor","scriptPath","wrapperLength","sources","excludePath","path","parsePath","undefined","generatedLines","branches","functions","covSources","rawSourceMap","sourceMap","sourceTranspiled","all","load","rawSource","source","fromSource","fromMapFileSource","sourcemap","sourcesContent","sourcesContentFromSources","map","i","candidatePath","file","_resolveSource","originalRawSource","originalSource","fileList","relativePath","realPath","then","result","catch","err","message","Promise","destroy","sourcePath","startsWith","replace","sourceRoot","applyCoverage","blocks","forEach","block","ranges","range","startCol","endCol","covSource","_maybeRemapStartColEndCol","lines","functionName","filter","line","count","startLineInstance","endLineInstance","isBlockCoverage","push","ignore","Math","max","startOffset","min","eof","endOffset","startLine","relStartCol","endLine","relEndCol","offsetToOriginalRelative","matchingSource","find","relativeToOffset","getInnerIstanbul","resolvedPath","_statementsToIstanbul","_branchesToIstanbul","_functionsToIstanbul","toIstanbul","reduce","istanbulOuter","Object","assign","statements","statementMap","s","index","branchMap","b","branch","srcLine","fnMap","f","fn"],"sources":["/Users/lincolnkushwah/Desktop/All/React Projects/house_joy_new/node_modules/v8-to-istanbul/lib/v8-to-istanbul.js"],"sourcesContent":["const assert = require('assert')\nconst convertSourceMap = require('convert-source-map')\nconst util = require('util')\nconst debuglog = util.debuglog('c8')\nconst { dirname, isAbsolute, join, resolve } = require('path')\nconst { fileURLToPath } = require('url')\nconst CovBranch = require('./branch')\nconst CovFunction = require('./function')\nconst CovSource = require('./source')\nconst { sliceRange } = require('./range')\nconst compatError = Error(`requires Node.js ${require('../package.json').engines.node}`)\nlet readFile = () => { throw compatError }\ntry {\n  readFile = require('fs').promises.readFile\n} catch (_err) {\n  // most likely we're on an older version of Node.js.\n}\nconst { SourceMapConsumer } = require('source-map')\nconst isOlderNode10 = /^v10\\.(([0-9]\\.)|(1[0-5]\\.))/u.test(process.version)\nconst isNode8 = /^v8\\./.test(process.version)\n\n// Injected when Node.js is loading script into isolate pre Node 10.16.x.\n// see: https://github.com/nodejs/node/pull/21573.\nconst cjsWrapperLength = isOlderNode10 ? require('module').wrapper[0].length : 0\n\nmodule.exports = class V8ToIstanbul {\n  constructor (scriptPath, wrapperLength, sources, excludePath) {\n    assert(typeof scriptPath === 'string', 'scriptPath must be a string')\n    assert(!isNode8, 'This module does not support node 8 or lower, please upgrade to node 10')\n    this.path = parsePath(scriptPath)\n    this.wrapperLength = wrapperLength === undefined ? cjsWrapperLength : wrapperLength\n    this.excludePath = excludePath || (() => false)\n    this.sources = sources || {}\n    this.generatedLines = []\n    this.branches = {}\n    this.functions = {}\n    this.covSources = []\n    this.rawSourceMap = undefined\n    this.sourceMap = undefined\n    this.sourceTranspiled = undefined\n    // Indicate that this report was generated with placeholder data from\n    // running --all:\n    this.all = false\n  }\n\n  async load () {\n    const rawSource = this.sources.source || await readFile(this.path, 'utf8')\n    this.rawSourceMap = this.sources.sourceMap ||\n      // if we find a source-map (either inline, or a .map file) we load\n      // both the transpiled and original source, both of which are used during\n      // the backflips we perform to remap absolute to relative positions.\n      convertSourceMap.fromSource(rawSource) || convertSourceMap.fromMapFileSource(rawSource, dirname(this.path))\n\n    if (this.rawSourceMap) {\n      if (this.rawSourceMap.sourcemap.sources.length > 1) {\n        this.sourceMap = await new SourceMapConsumer(this.rawSourceMap.sourcemap)\n        if (!this.sourceMap.sourcesContent) {\n          this.sourceMap.sourcesContent = await this.sourcesContentFromSources()\n        }\n        this.covSources = this.sourceMap.sourcesContent.map((rawSource, i) => ({ source: new CovSource(rawSource, this.wrapperLength), path: this.sourceMap.sources[i] }))\n        this.sourceTranspiled = new CovSource(rawSource, this.wrapperLength)\n      } else {\n        const candidatePath = this.rawSourceMap.sourcemap.sources.length >= 1 ? this.rawSourceMap.sourcemap.sources[0] : this.rawSourceMap.sourcemap.file\n        this.path = this._resolveSource(this.rawSourceMap, candidatePath || this.path)\n        this.sourceMap = await new SourceMapConsumer(this.rawSourceMap.sourcemap)\n\n        let originalRawSource\n        if (this.sources.sourceMap && this.sources.sourceMap.sourcemap && this.sources.sourceMap.sourcemap.sourcesContent && this.sources.sourceMap.sourcemap.sourcesContent.length === 1) {\n          // If the sourcesContent field has been provided, return it rather than attempting\n          // to load the original source from disk.\n          // TODO: investigate whether there's ever a case where we hit this logic with 1:many sources.\n          originalRawSource = this.sources.sourceMap.sourcemap.sourcesContent[0]\n        } else if (this.sources.originalSource) {\n          // Original source may be populated on the sources object.\n          originalRawSource = this.sources.originalSource\n        } else if (this.sourceMap.sourcesContent && this.sourceMap.sourcesContent[0]) {\n          // perhaps we loaded sourcesContent was populated by an inline source map, or .map file?\n          // TODO: investigate whether there's ever a case where we hit this logic with 1:many sources.\n          originalRawSource = this.sourceMap.sourcesContent[0]\n        } else {\n          // We fallback to reading the original source from disk.\n          originalRawSource = await readFile(this.path, 'utf8')\n        }\n        this.covSources = [{ source: new CovSource(originalRawSource, this.wrapperLength), path: this.path }]\n        this.sourceTranspiled = new CovSource(rawSource, this.wrapperLength)\n      }\n    } else {\n      this.covSources = [{ source: new CovSource(rawSource, this.wrapperLength), path: this.path }]\n    }\n  }\n\n  async sourcesContentFromSources () {\n    const fileList = this.sourceMap.sources.map(relativePath => {\n      const realPath = this._resolveSource(this.rawSourceMap, relativePath)\n      return readFile(realPath, 'utf-8')\n        .then(result => result)\n        .catch(err => {\n          debuglog(`failed to load ${realPath}: ${err.message}`)\n        })\n    })\n    return await Promise.all(fileList)\n  }\n\n  destroy () {\n    if (this.sourceMap) {\n      this.sourceMap.destroy()\n      this.sourceMap = undefined\n    }\n  }\n\n  _resolveSource (rawSourceMap, sourcePath) {\n    if (sourcePath.startsWith('file://')) {\n      return fileURLToPath(sourcePath)\n    }\n    sourcePath = sourcePath.replace(/^webpack:\\/\\//, '')\n    const sourceRoot = rawSourceMap.sourcemap.sourceRoot ? rawSourceMap.sourcemap.sourceRoot.replace('file://', '') : ''\n    const candidatePath = join(sourceRoot, sourcePath)\n\n    if (isAbsolute(candidatePath)) {\n      return candidatePath\n    } else {\n      return resolve(dirname(this.path), candidatePath)\n    }\n  }\n\n  applyCoverage (blocks) {\n    blocks.forEach(block => {\n      block.ranges.forEach((range, i) => {\n        const { startCol, endCol, path, covSource } = this._maybeRemapStartColEndCol(range)\n        if (this.excludePath(path)) {\n          return\n        }\n        let lines\n        if (block.functionName === '(empty-report)') {\n          // (empty-report), this will result in a report that has all lines zeroed out.\n          lines = covSource.lines.filter((line) => {\n            line.count = 0\n            return true\n          })\n          this.all = lines.length > 0\n        } else {\n          lines = sliceRange(covSource.lines, startCol, endCol)\n        }\n        if (!lines.length) {\n          return\n        }\n\n        const startLineInstance = lines[0]\n        const endLineInstance = lines[lines.length - 1]\n\n        if (block.isBlockCoverage) {\n          this.branches[path] = this.branches[path] || []\n          // record branches.\n          this.branches[path].push(new CovBranch(\n            startLineInstance.line,\n            startCol - startLineInstance.startCol,\n            endLineInstance.line,\n            endCol - endLineInstance.startCol,\n            range.count\n          ))\n\n          // if block-level granularity is enabled, we still create a single\n          // CovFunction tracking object for each set of ranges.\n          if (block.functionName && i === 0) {\n            this.functions[path] = this.functions[path] || []\n            this.functions[path].push(new CovFunction(\n              block.functionName,\n              startLineInstance.line,\n              startCol - startLineInstance.startCol,\n              endLineInstance.line,\n              endCol - endLineInstance.startCol,\n              range.count\n            ))\n          }\n        } else if (block.functionName) {\n          this.functions[path] = this.functions[path] || []\n          // record functions.\n          this.functions[path].push(new CovFunction(\n            block.functionName,\n            startLineInstance.line,\n            startCol - startLineInstance.startCol,\n            endLineInstance.line,\n            endCol - endLineInstance.startCol,\n            range.count\n          ))\n        }\n\n        // record the lines (we record these as statements, such that we're\n        // compatible with Istanbul 2.0).\n        lines.forEach(line => {\n          // make sure branch spans entire line; don't record 'goodbye'\n          // branch in `const foo = true ? 'hello' : 'goodbye'` as a\n          // 0 for line coverage.\n          //\n          // All lines start out with coverage of 1, and are later set to 0\n          // if they are not invoked; line.ignore prevents a line from being\n          // set to 0, and is set if the special comment /* c8 ignore next */\n          // is used.\n\n          if (startCol <= line.startCol && endCol >= line.endCol && !line.ignore) {\n            line.count = range.count\n          }\n        })\n      })\n    })\n  }\n\n  _maybeRemapStartColEndCol (range) {\n    let covSource = this.covSources[0].source\n    let startCol = Math.max(0, range.startOffset - covSource.wrapperLength)\n    let endCol = Math.min(covSource.eof, range.endOffset - covSource.wrapperLength)\n    let path = this.path\n\n    if (this.sourceMap) {\n      startCol = Math.max(0, range.startOffset - this.sourceTranspiled.wrapperLength)\n      endCol = Math.min(this.sourceTranspiled.eof, range.endOffset - this.sourceTranspiled.wrapperLength)\n\n      const { startLine, relStartCol, endLine, relEndCol, source } = this.sourceTranspiled.offsetToOriginalRelative(\n        this.sourceMap,\n        startCol,\n        endCol\n      )\n\n      const matchingSource = this.covSources.find(covSource => covSource.path === source)\n      covSource = matchingSource ? matchingSource.source : this.covSources[0].source\n      path = matchingSource ? matchingSource.path : this.covSources[0].path\n\n      // next we convert these relative positions back to absolute positions\n      // in the original source (which is the format expected in the next step).\n      startCol = covSource.relativeToOffset(startLine, relStartCol)\n      endCol = covSource.relativeToOffset(endLine, relEndCol)\n    }\n\n    return {\n      path,\n      covSource,\n      startCol,\n      endCol\n    }\n  }\n\n  getInnerIstanbul (source, path) {\n    // We apply the \"Resolving Sources\" logic (as defined in\n    // sourcemaps.info/spec.html) as a final step for 1:many source maps.\n    // for 1:1 source maps, the resolve logic is applied while loading.\n    //\n    // TODO: could we move the resolving logic for 1:1 source maps to the final\n    // step as well? currently this breaks some tests in c8.\n    let resolvedPath = path\n    if (this.rawSourceMap && this.rawSourceMap.sourcemap.sources.length > 1) {\n      resolvedPath = this._resolveSource(this.rawSourceMap, path)\n    }\n\n    if (this.excludePath(resolvedPath)) {\n      return\n    }\n\n    return {\n      [resolvedPath]: {\n        path: resolvedPath,\n        all: this.all,\n        ...this._statementsToIstanbul(source, path),\n        ...this._branchesToIstanbul(source, path),\n        ...this._functionsToIstanbul(source, path)\n      }\n    }\n  }\n\n  toIstanbul () {\n    return this.covSources.reduce((istanbulOuter, { source, path }) => Object.assign(istanbulOuter, this.getInnerIstanbul(source, path)), {})\n  }\n\n  _statementsToIstanbul (source, path) {\n    const statements = {\n      statementMap: {},\n      s: {}\n    }\n    source.lines.forEach((line, index) => {\n      statements.statementMap[`${index}`] = line.toIstanbul()\n      statements.s[`${index}`] = line.count\n    })\n    return statements\n  }\n\n  _branchesToIstanbul (source, path) {\n    const branches = {\n      branchMap: {},\n      b: {}\n    }\n    this.branches[path] = this.branches[path] || []\n    this.branches[path].forEach((branch, index) => {\n      const srcLine = source.lines[branch.startLine - 1]\n      const ignore = srcLine === undefined ? true : srcLine.ignore\n      branches.branchMap[`${index}`] = branch.toIstanbul()\n      branches.b[`${index}`] = [ignore ? 1 : branch.count]\n    })\n    return branches\n  }\n\n  _functionsToIstanbul (source, path) {\n    const functions = {\n      fnMap: {},\n      f: {}\n    }\n    this.functions[path] = this.functions[path] || []\n    this.functions[path].forEach((fn, index) => {\n      const srcLine = source.lines[fn.startLine - 1]\n      const ignore = srcLine === undefined ? true : srcLine.ignore\n      functions.fnMap[`${index}`] = fn.toIstanbul()\n      functions.f[`${index}`] = ignore ? 1 : fn.count\n    })\n    return functions\n  }\n}\n\nfunction parsePath (scriptPath) {\n  return scriptPath.startsWith('file://') ? fileURLToPath(scriptPath) : scriptPath\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}