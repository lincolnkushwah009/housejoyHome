{"ast":null,"code":"/*\n Copyright 2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n'use strict';\n\nconst debug = require('debug')('istanbuljs');\n\nconst libCoverage = require('istanbul-lib-coverage');\n\nconst {\n  MappedCoverage\n} = require('./mapped');\n\nconst getMapping = require('./get-mapping');\n\nconst {\n  getUniqueKey,\n  getOutput\n} = require('./transform-utils');\n\nclass SourceMapTransformer {\n  constructor(finder) {\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.finder = finder;\n    this.baseDir = opts.baseDir || process.cwd();\n    this.resolveMapping = opts.getMapping || getMapping;\n  }\n\n  processFile(fc, sourceMap, coverageMapper) {\n    let changes = 0;\n    Object.entries(fc.statementMap).forEach(_ref => {\n      let [s, loc] = _ref;\n      const hits = fc.s[s];\n      const mapping = this.resolveMapping(sourceMap, loc, fc.path);\n\n      if (mapping) {\n        changes += 1;\n        const mappedCoverage = coverageMapper(mapping.source);\n        mappedCoverage.addStatement(mapping.loc, hits);\n      }\n    });\n    Object.entries(fc.fnMap).forEach(_ref2 => {\n      let [f, fnMeta] = _ref2;\n      const hits = fc.f[f];\n      const mapping = this.resolveMapping(sourceMap, fnMeta.decl, fc.path);\n      const spanMapping = this.resolveMapping(sourceMap, fnMeta.loc, fc.path);\n\n      if (mapping && spanMapping && mapping.source === spanMapping.source) {\n        changes += 1;\n        const mappedCoverage = coverageMapper(mapping.source);\n        mappedCoverage.addFunction(fnMeta.name, mapping.loc, spanMapping.loc, hits);\n      }\n    });\n    Object.entries(fc.branchMap).forEach(_ref3 => {\n      let [b, branchMeta] = _ref3;\n      const hits = fc.b[b];\n      const locs = [];\n      const mappedHits = [];\n      let source;\n      let skip;\n      branchMeta.locations.forEach((loc, i) => {\n        const mapping = this.resolveMapping(sourceMap, loc, fc.path);\n\n        if (mapping) {\n          if (!source) {\n            source = mapping.source;\n          }\n\n          if (mapping.source !== source) {\n            skip = true;\n          }\n\n          locs.push(mapping.loc);\n          mappedHits.push(hits[i]);\n        }\n      });\n      const locMapping = branchMeta.loc ? this.resolveMapping(sourceMap, branchMeta.loc, fc.path) : null;\n\n      if (!skip && locs.length > 0) {\n        changes += 1;\n        const mappedCoverage = coverageMapper(source);\n        mappedCoverage.addBranch(branchMeta.type, locMapping ? locMapping.loc : locs[0], locs, mappedHits);\n      }\n    });\n    return changes > 0;\n  }\n\n  async transform(coverageMap) {\n    const uniqueFiles = {};\n\n    const getMappedCoverage = file => {\n      const key = getUniqueKey(file);\n\n      if (!uniqueFiles[key]) {\n        uniqueFiles[key] = {\n          file,\n          mappedCoverage: new MappedCoverage(file)\n        };\n      }\n\n      return uniqueFiles[key].mappedCoverage;\n    };\n\n    for (const file of coverageMap.files()) {\n      const fc = coverageMap.fileCoverageFor(file);\n      const sourceMap = await this.finder(file, fc);\n\n      if (sourceMap) {\n        const changed = this.processFile(fc, sourceMap, getMappedCoverage);\n\n        if (!changed) {\n          debug(`File [${file}] ignored, nothing could be mapped`);\n        }\n      } else {\n        uniqueFiles[getUniqueKey(file)] = {\n          file,\n          mappedCoverage: new MappedCoverage(fc)\n        };\n      }\n    }\n\n    return libCoverage.createCoverageMap(getOutput(uniqueFiles));\n  }\n\n}\n\nmodule.exports = {\n  SourceMapTransformer\n};","map":{"version":3,"names":["debug","require","libCoverage","MappedCoverage","getMapping","getUniqueKey","getOutput","SourceMapTransformer","constructor","finder","opts","baseDir","process","cwd","resolveMapping","processFile","fc","sourceMap","coverageMapper","changes","Object","entries","statementMap","forEach","s","loc","hits","mapping","path","mappedCoverage","source","addStatement","fnMap","f","fnMeta","decl","spanMapping","addFunction","name","branchMap","b","branchMeta","locs","mappedHits","skip","locations","i","push","locMapping","length","addBranch","type","transform","coverageMap","uniqueFiles","getMappedCoverage","file","key","files","fileCoverageFor","changed","createCoverageMap","module","exports"],"sources":["/Users/lincolnkushwah/Desktop/All/React Projects/house_joy_new/node_modules/istanbul-lib-source-maps/lib/transformer.js"],"sourcesContent":["/*\n Copyright 2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n'use strict';\n\nconst debug = require('debug')('istanbuljs');\nconst libCoverage = require('istanbul-lib-coverage');\nconst { MappedCoverage } = require('./mapped');\nconst getMapping = require('./get-mapping');\nconst { getUniqueKey, getOutput } = require('./transform-utils');\n\nclass SourceMapTransformer {\n    constructor(finder, opts = {}) {\n        this.finder = finder;\n        this.baseDir = opts.baseDir || process.cwd();\n        this.resolveMapping = opts.getMapping || getMapping;\n    }\n\n    processFile(fc, sourceMap, coverageMapper) {\n        let changes = 0;\n\n        Object.entries(fc.statementMap).forEach(([s, loc]) => {\n            const hits = fc.s[s];\n            const mapping = this.resolveMapping(sourceMap, loc, fc.path);\n\n            if (mapping) {\n                changes += 1;\n                const mappedCoverage = coverageMapper(mapping.source);\n                mappedCoverage.addStatement(mapping.loc, hits);\n            }\n        });\n\n        Object.entries(fc.fnMap).forEach(([f, fnMeta]) => {\n            const hits = fc.f[f];\n            const mapping = this.resolveMapping(\n                sourceMap,\n                fnMeta.decl,\n                fc.path\n            );\n\n            const spanMapping = this.resolveMapping(\n                sourceMap,\n                fnMeta.loc,\n                fc.path\n            );\n\n            if (\n                mapping &&\n                spanMapping &&\n                mapping.source === spanMapping.source\n            ) {\n                changes += 1;\n                const mappedCoverage = coverageMapper(mapping.source);\n                mappedCoverage.addFunction(\n                    fnMeta.name,\n                    mapping.loc,\n                    spanMapping.loc,\n                    hits\n                );\n            }\n        });\n\n        Object.entries(fc.branchMap).forEach(([b, branchMeta]) => {\n            const hits = fc.b[b];\n            const locs = [];\n            const mappedHits = [];\n            let source;\n            let skip;\n\n            branchMeta.locations.forEach((loc, i) => {\n                const mapping = this.resolveMapping(sourceMap, loc, fc.path);\n                if (mapping) {\n                    if (!source) {\n                        source = mapping.source;\n                    }\n\n                    if (mapping.source !== source) {\n                        skip = true;\n                    }\n\n                    locs.push(mapping.loc);\n                    mappedHits.push(hits[i]);\n                }\n            });\n\n            const locMapping = branchMeta.loc\n                ? this.resolveMapping(sourceMap, branchMeta.loc, fc.path)\n                : null;\n\n            if (!skip && locs.length > 0) {\n                changes += 1;\n                const mappedCoverage = coverageMapper(source);\n                mappedCoverage.addBranch(\n                    branchMeta.type,\n                    locMapping ? locMapping.loc : locs[0],\n                    locs,\n                    mappedHits\n                );\n            }\n        });\n\n        return changes > 0;\n    }\n\n    async transform(coverageMap) {\n        const uniqueFiles = {};\n        const getMappedCoverage = file => {\n            const key = getUniqueKey(file);\n            if (!uniqueFiles[key]) {\n                uniqueFiles[key] = {\n                    file,\n                    mappedCoverage: new MappedCoverage(file)\n                };\n            }\n\n            return uniqueFiles[key].mappedCoverage;\n        };\n\n        for (const file of coverageMap.files()) {\n            const fc = coverageMap.fileCoverageFor(file);\n            const sourceMap = await this.finder(file, fc);\n\n            if (sourceMap) {\n                const changed = this.processFile(\n                    fc,\n                    sourceMap,\n                    getMappedCoverage\n                );\n                if (!changed) {\n                    debug(`File [${file}] ignored, nothing could be mapped`);\n                }\n            } else {\n                uniqueFiles[getUniqueKey(file)] = {\n                    file,\n                    mappedCoverage: new MappedCoverage(fc)\n                };\n            }\n        }\n\n        return libCoverage.createCoverageMap(getOutput(uniqueFiles));\n    }\n}\n\nmodule.exports = {\n    SourceMapTransformer\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}