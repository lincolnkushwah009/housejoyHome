{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = WatchmanWatcher;\n\nfunction _assert() {\n  const data = _interopRequireDefault(require('assert'));\n\n  _assert = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _events() {\n  const data = require('events');\n\n  _events = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _path() {\n  const data = _interopRequireDefault(require('path'));\n\n  _path = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _fbWatchman() {\n  const data = _interopRequireDefault(require('fb-watchman'));\n\n  _fbWatchman = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction fs() {\n  const data = _interopRequireWildcard(require('graceful-fs'));\n\n  fs = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _RecrawlWarning = _interopRequireDefault(require('./RecrawlWarning'));\n\nvar _common = _interopRequireDefault(require('./common'));\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== 'function') return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== 'object' && typeof obj !== 'function') {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache(nodeInterop);\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (key !== 'default' && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nconst CHANGE_EVENT = _common.default.CHANGE_EVENT;\nconst DELETE_EVENT = _common.default.DELETE_EVENT;\nconst ADD_EVENT = _common.default.ADD_EVENT;\nconst ALL_EVENT = _common.default.ALL_EVENT;\nconst SUB_NAME = 'sane-sub';\n/**\n * Watches `dir`.\n *\n * @class PollWatcher\n * @param String dir\n * @param {Object} opts\n * @public\n */\n\nfunction WatchmanWatcher(dir, opts) {\n  _common.default.assignOptions(this, opts);\n\n  this.root = _path().default.resolve(dir);\n  this.init();\n} // eslint-disable-next-line no-proto\n\n\nWatchmanWatcher.prototype.__proto__ = _events().EventEmitter.prototype;\n/**\n * Run the watchman `watch` command on the root and subscribe to changes.\n *\n * @private\n */\n\nWatchmanWatcher.prototype.init = function () {\n  if (this.client) {\n    this.client.removeAllListeners();\n  }\n\n  const self = this;\n  this.client = new (_fbWatchman().default.Client)();\n  this.client.on('error', error => {\n    self.emit('error', error);\n  });\n  this.client.on('subscription', this.handleChangeEvent.bind(this));\n  this.client.on('end', () => {\n    console.warn('[sane] Warning: Lost connection to watchman, reconnecting..');\n    self.init();\n  });\n  this.watchProjectInfo = null;\n\n  function getWatchRoot() {\n    return self.watchProjectInfo ? self.watchProjectInfo.root : self.root;\n  }\n\n  function onCapability(error, resp) {\n    if (handleError(self, error)) {\n      // The Watchman watcher is unusable on this system, we cannot continue\n      return;\n    }\n\n    handleWarning(resp);\n    self.capabilities = resp.capabilities;\n\n    if (self.capabilities.relative_root) {\n      self.client.command(['watch-project', getWatchRoot()], onWatchProject);\n    } else {\n      self.client.command(['watch', getWatchRoot()], onWatch);\n    }\n  }\n\n  function onWatchProject(error, resp) {\n    if (handleError(self, error)) {\n      return;\n    }\n\n    handleWarning(resp);\n    self.watchProjectInfo = {\n      relativePath: resp.relative_path ? resp.relative_path : '',\n      root: resp.watch\n    };\n    self.client.command(['clock', getWatchRoot()], onClock);\n  }\n\n  function onWatch(error, resp) {\n    if (handleError(self, error)) {\n      return;\n    }\n\n    handleWarning(resp);\n    self.client.command(['clock', getWatchRoot()], onClock);\n  }\n\n  function onClock(error, resp) {\n    if (handleError(self, error)) {\n      return;\n    }\n\n    handleWarning(resp);\n    const options = {\n      fields: ['name', 'exists', 'new'],\n      since: resp.clock\n    }; // If the server has the wildmatch capability available it supports\n    // the recursive **/*.foo style match and we can offload our globs\n    // to the watchman server.  This saves both on data size to be\n    // communicated back to us and compute for evaluating the globs\n    // in our node process.\n\n    if (self.capabilities.wildmatch) {\n      if (self.globs.length === 0) {\n        if (!self.dot) {\n          // Make sure we honor the dot option if even we're not using globs.\n          options.expression = ['match', '**', 'wholename', {\n            includedotfiles: false\n          }];\n        }\n      } else {\n        options.expression = ['anyof'];\n\n        for (const i in self.globs) {\n          options.expression.push(['match', self.globs[i], 'wholename', {\n            includedotfiles: self.dot\n          }]);\n        }\n      }\n    }\n\n    if (self.capabilities.relative_root) {\n      options.relative_root = self.watchProjectInfo.relativePath;\n    }\n\n    self.client.command(['subscribe', getWatchRoot(), SUB_NAME, options], onSubscribe);\n  }\n\n  function onSubscribe(error, resp) {\n    if (handleError(self, error)) {\n      return;\n    }\n\n    handleWarning(resp);\n    self.emit('ready');\n  }\n\n  self.client.capabilityCheck({\n    optional: ['wildmatch', 'relative_root']\n  }, onCapability);\n};\n/**\n * Handles a change event coming from the subscription.\n *\n * @param {Object} resp\n * @private\n */\n\n\nWatchmanWatcher.prototype.handleChangeEvent = function (resp) {\n  _assert().default.equal(resp.subscription, SUB_NAME, 'Invalid subscription event.');\n\n  if (resp.is_fresh_instance) {\n    this.emit('fresh_instance');\n  }\n\n  if (resp.is_fresh_instance) {\n    this.emit('fresh_instance');\n  }\n\n  if (Array.isArray(resp.files)) {\n    resp.files.forEach(this.handleFileChange, this);\n  }\n};\n/**\n * Handles a single change event record.\n *\n * @param {Object} changeDescriptor\n * @private\n */\n\n\nWatchmanWatcher.prototype.handleFileChange = function (changeDescriptor) {\n  const self = this;\n  let absPath;\n  let relativePath;\n\n  if (this.capabilities.relative_root) {\n    relativePath = changeDescriptor.name;\n    absPath = _path().default.join(this.watchProjectInfo.root, this.watchProjectInfo.relativePath, relativePath);\n  } else {\n    absPath = _path().default.join(this.root, changeDescriptor.name);\n    relativePath = changeDescriptor.name;\n  }\n\n  if (!(self.capabilities.wildmatch && !this.hasIgnore) && !_common.default.isFileIncluded(this.globs, this.dot, this.doIgnore, relativePath)) {\n    return;\n  }\n\n  if (!changeDescriptor.exists) {\n    self.emitEvent(DELETE_EVENT, relativePath, self.root);\n  } else {\n    fs().lstat(absPath, (error, stat) => {\n      // Files can be deleted between the event and the lstat call\n      // the most reliable thing to do here is to ignore the event.\n      if (error && error.code === 'ENOENT') {\n        return;\n      }\n\n      if (handleError(self, error)) {\n        return;\n      }\n\n      const eventType = changeDescriptor.new ? ADD_EVENT : CHANGE_EVENT; // Change event on dirs are mostly useless.\n\n      if (!(eventType === CHANGE_EVENT && stat.isDirectory())) {\n        self.emitEvent(eventType, relativePath, self.root, stat);\n      }\n    });\n  }\n};\n/**\n * Dispatches the event.\n *\n * @param {string} eventType\n * @param {string} filepath\n * @param {string} root\n * @param {fs.Stat} stat\n * @private\n */\n\n\nWatchmanWatcher.prototype.emitEvent = function (eventType, filepath, root, stat) {\n  this.emit(eventType, filepath, root, stat);\n  this.emit(ALL_EVENT, eventType, filepath, root, stat);\n};\n/**\n * Closes the watcher.\n *\n */\n\n\nWatchmanWatcher.prototype.close = function () {\n  this.client.removeAllListeners();\n  this.client.end();\n  return Promise.resolve();\n};\n/**\n * Handles an error and returns true if exists.\n *\n * @param {WatchmanWatcher} self\n * @param {Error} error\n * @private\n */\n\n\nfunction handleError(self, error) {\n  if (error != null) {\n    self.emit('error', error);\n    return true;\n  } else {\n    return false;\n  }\n}\n/**\n * Handles a warning in the watchman resp object.\n *\n * @param {object} resp\n * @private\n */\n\n\nfunction handleWarning(resp) {\n  if ('warning' in resp) {\n    if (_RecrawlWarning.default.isRecrawlWarningDupe(resp.warning)) {\n      return true;\n    }\n\n    console.warn(resp.warning);\n    return true;\n  } else {\n    return false;\n  }\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","default","WatchmanWatcher","_assert","data","_interopRequireDefault","require","_events","_path","_fbWatchman","fs","_interopRequireWildcard","_RecrawlWarning","_common","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","obj","__esModule","cache","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","CHANGE_EVENT","DELETE_EVENT","ADD_EVENT","ALL_EVENT","SUB_NAME","dir","opts","assignOptions","root","resolve","init","__proto__","EventEmitter","client","removeAllListeners","self","Client","on","error","emit","handleChangeEvent","bind","console","warn","watchProjectInfo","getWatchRoot","onCapability","resp","handleError","handleWarning","capabilities","relative_root","command","onWatchProject","onWatch","relativePath","relative_path","watch","onClock","options","fields","since","clock","wildmatch","globs","length","dot","expression","includedotfiles","i","push","onSubscribe","capabilityCheck","optional","equal","subscription","is_fresh_instance","Array","isArray","files","forEach","handleFileChange","changeDescriptor","absPath","name","join","hasIgnore","isFileIncluded","doIgnore","exists","emitEvent","lstat","stat","code","eventType","new","isDirectory","filepath","close","end","Promise","isRecrawlWarningDupe","warning"],"sources":["/Users/lincolnkushwah/Desktop/All/React Projects/house_joy_new/node_modules/jest-haste-map/build/watchers/WatchmanWatcher.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = WatchmanWatcher;\n\nfunction _assert() {\n  const data = _interopRequireDefault(require('assert'));\n\n  _assert = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _events() {\n  const data = require('events');\n\n  _events = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _path() {\n  const data = _interopRequireDefault(require('path'));\n\n  _path = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _fbWatchman() {\n  const data = _interopRequireDefault(require('fb-watchman'));\n\n  _fbWatchman = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction fs() {\n  const data = _interopRequireWildcard(require('graceful-fs'));\n\n  fs = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _RecrawlWarning = _interopRequireDefault(require('./RecrawlWarning'));\n\nvar _common = _interopRequireDefault(require('./common'));\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== 'function') return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {\n    return {default: obj};\n  }\n  var cache = _getRequireWildcardCache(nodeInterop);\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor =\n    Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (key !== 'default' && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor\n        ? Object.getOwnPropertyDescriptor(obj, key)\n        : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nconst CHANGE_EVENT = _common.default.CHANGE_EVENT;\nconst DELETE_EVENT = _common.default.DELETE_EVENT;\nconst ADD_EVENT = _common.default.ADD_EVENT;\nconst ALL_EVENT = _common.default.ALL_EVENT;\nconst SUB_NAME = 'sane-sub';\n/**\n * Watches `dir`.\n *\n * @class PollWatcher\n * @param String dir\n * @param {Object} opts\n * @public\n */\n\nfunction WatchmanWatcher(dir, opts) {\n  _common.default.assignOptions(this, opts);\n\n  this.root = _path().default.resolve(dir);\n  this.init();\n} // eslint-disable-next-line no-proto\n\nWatchmanWatcher.prototype.__proto__ = _events().EventEmitter.prototype;\n/**\n * Run the watchman `watch` command on the root and subscribe to changes.\n *\n * @private\n */\n\nWatchmanWatcher.prototype.init = function () {\n  if (this.client) {\n    this.client.removeAllListeners();\n  }\n\n  const self = this;\n  this.client = new (_fbWatchman().default.Client)();\n  this.client.on('error', error => {\n    self.emit('error', error);\n  });\n  this.client.on('subscription', this.handleChangeEvent.bind(this));\n  this.client.on('end', () => {\n    console.warn('[sane] Warning: Lost connection to watchman, reconnecting..');\n    self.init();\n  });\n  this.watchProjectInfo = null;\n\n  function getWatchRoot() {\n    return self.watchProjectInfo ? self.watchProjectInfo.root : self.root;\n  }\n\n  function onCapability(error, resp) {\n    if (handleError(self, error)) {\n      // The Watchman watcher is unusable on this system, we cannot continue\n      return;\n    }\n\n    handleWarning(resp);\n    self.capabilities = resp.capabilities;\n\n    if (self.capabilities.relative_root) {\n      self.client.command(['watch-project', getWatchRoot()], onWatchProject);\n    } else {\n      self.client.command(['watch', getWatchRoot()], onWatch);\n    }\n  }\n\n  function onWatchProject(error, resp) {\n    if (handleError(self, error)) {\n      return;\n    }\n\n    handleWarning(resp);\n    self.watchProjectInfo = {\n      relativePath: resp.relative_path ? resp.relative_path : '',\n      root: resp.watch\n    };\n    self.client.command(['clock', getWatchRoot()], onClock);\n  }\n\n  function onWatch(error, resp) {\n    if (handleError(self, error)) {\n      return;\n    }\n\n    handleWarning(resp);\n    self.client.command(['clock', getWatchRoot()], onClock);\n  }\n\n  function onClock(error, resp) {\n    if (handleError(self, error)) {\n      return;\n    }\n\n    handleWarning(resp);\n    const options = {\n      fields: ['name', 'exists', 'new'],\n      since: resp.clock\n    }; // If the server has the wildmatch capability available it supports\n    // the recursive **/*.foo style match and we can offload our globs\n    // to the watchman server.  This saves both on data size to be\n    // communicated back to us and compute for evaluating the globs\n    // in our node process.\n\n    if (self.capabilities.wildmatch) {\n      if (self.globs.length === 0) {\n        if (!self.dot) {\n          // Make sure we honor the dot option if even we're not using globs.\n          options.expression = [\n            'match',\n            '**',\n            'wholename',\n            {\n              includedotfiles: false\n            }\n          ];\n        }\n      } else {\n        options.expression = ['anyof'];\n\n        for (const i in self.globs) {\n          options.expression.push([\n            'match',\n            self.globs[i],\n            'wholename',\n            {\n              includedotfiles: self.dot\n            }\n          ]);\n        }\n      }\n    }\n\n    if (self.capabilities.relative_root) {\n      options.relative_root = self.watchProjectInfo.relativePath;\n    }\n\n    self.client.command(\n      ['subscribe', getWatchRoot(), SUB_NAME, options],\n      onSubscribe\n    );\n  }\n\n  function onSubscribe(error, resp) {\n    if (handleError(self, error)) {\n      return;\n    }\n\n    handleWarning(resp);\n    self.emit('ready');\n  }\n\n  self.client.capabilityCheck(\n    {\n      optional: ['wildmatch', 'relative_root']\n    },\n    onCapability\n  );\n};\n/**\n * Handles a change event coming from the subscription.\n *\n * @param {Object} resp\n * @private\n */\n\nWatchmanWatcher.prototype.handleChangeEvent = function (resp) {\n  _assert().default.equal(\n    resp.subscription,\n    SUB_NAME,\n    'Invalid subscription event.'\n  );\n\n  if (resp.is_fresh_instance) {\n    this.emit('fresh_instance');\n  }\n\n  if (resp.is_fresh_instance) {\n    this.emit('fresh_instance');\n  }\n\n  if (Array.isArray(resp.files)) {\n    resp.files.forEach(this.handleFileChange, this);\n  }\n};\n/**\n * Handles a single change event record.\n *\n * @param {Object} changeDescriptor\n * @private\n */\n\nWatchmanWatcher.prototype.handleFileChange = function (changeDescriptor) {\n  const self = this;\n  let absPath;\n  let relativePath;\n\n  if (this.capabilities.relative_root) {\n    relativePath = changeDescriptor.name;\n    absPath = _path().default.join(\n      this.watchProjectInfo.root,\n      this.watchProjectInfo.relativePath,\n      relativePath\n    );\n  } else {\n    absPath = _path().default.join(this.root, changeDescriptor.name);\n    relativePath = changeDescriptor.name;\n  }\n\n  if (\n    !(self.capabilities.wildmatch && !this.hasIgnore) &&\n    !_common.default.isFileIncluded(\n      this.globs,\n      this.dot,\n      this.doIgnore,\n      relativePath\n    )\n  ) {\n    return;\n  }\n\n  if (!changeDescriptor.exists) {\n    self.emitEvent(DELETE_EVENT, relativePath, self.root);\n  } else {\n    fs().lstat(absPath, (error, stat) => {\n      // Files can be deleted between the event and the lstat call\n      // the most reliable thing to do here is to ignore the event.\n      if (error && error.code === 'ENOENT') {\n        return;\n      }\n\n      if (handleError(self, error)) {\n        return;\n      }\n\n      const eventType = changeDescriptor.new ? ADD_EVENT : CHANGE_EVENT; // Change event on dirs are mostly useless.\n\n      if (!(eventType === CHANGE_EVENT && stat.isDirectory())) {\n        self.emitEvent(eventType, relativePath, self.root, stat);\n      }\n    });\n  }\n};\n/**\n * Dispatches the event.\n *\n * @param {string} eventType\n * @param {string} filepath\n * @param {string} root\n * @param {fs.Stat} stat\n * @private\n */\n\nWatchmanWatcher.prototype.emitEvent = function (\n  eventType,\n  filepath,\n  root,\n  stat\n) {\n  this.emit(eventType, filepath, root, stat);\n  this.emit(ALL_EVENT, eventType, filepath, root, stat);\n};\n/**\n * Closes the watcher.\n *\n */\n\nWatchmanWatcher.prototype.close = function () {\n  this.client.removeAllListeners();\n  this.client.end();\n  return Promise.resolve();\n};\n/**\n * Handles an error and returns true if exists.\n *\n * @param {WatchmanWatcher} self\n * @param {Error} error\n * @private\n */\n\nfunction handleError(self, error) {\n  if (error != null) {\n    self.emit('error', error);\n    return true;\n  } else {\n    return false;\n  }\n}\n/**\n * Handles a warning in the watchman resp object.\n *\n * @param {object} resp\n * @private\n */\n\nfunction handleWarning(resp) {\n  if ('warning' in resp) {\n    if (_RecrawlWarning.default.isRecrawlWarningDupe(resp.warning)) {\n      return true;\n    }\n\n    console.warn(resp.warning);\n    return true;\n  } else {\n    return false;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}