{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.dedentLines = void 0;\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst getIndentationLength = line => {\n  const result = /^( {2})+/.exec(line);\n  return result === null ? 0 : result[0].length;\n};\n\nconst dedentLine = line => line.slice(getIndentationLength(line)); // Return true if:\n// \"key\": \"value has multiple lines\\n…\n// \"key has multiple lines\\n…\n\n\nconst hasUnmatchedDoubleQuoteMarks = string => {\n  let n = 0;\n  let i = string.indexOf('\"', 0);\n\n  while (i !== -1) {\n    if (i === 0 || string[i - 1] !== '\\\\') {\n      n += 1;\n    }\n\n    i = string.indexOf('\"', i + 1);\n  }\n\n  return n % 2 !== 0;\n};\n\nconst isFirstLineOfTag = line => /^( {2})*\\</.test(line); // The length of the output array is the index of the next input line.\n// Push dedented lines of start tag onto output and return true;\n// otherwise return false because:\n// * props include a multiline string (or text node, if props have markup)\n// * start tag does not close\n\n\nconst dedentStartTag = (input, output) => {\n  let line = input[output.length];\n  output.push(dedentLine(line));\n\n  if (line.includes('>')) {\n    return true;\n  }\n\n  while (output.length < input.length) {\n    line = input[output.length];\n\n    if (hasUnmatchedDoubleQuoteMarks(line)) {\n      return false; // because props include a multiline string\n    } else if (isFirstLineOfTag(line)) {\n      // Recursion only if props have markup.\n      if (!dedentMarkup(input, output)) {\n        return false;\n      }\n    } else {\n      output.push(dedentLine(line));\n\n      if (line.includes('>')) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}; // Push dedented lines of markup onto output and return true;\n// otherwise return false because:\n// * props include a multiline string\n// * text has more than one adjacent line\n// * markup does not close\n\n\nconst dedentMarkup = (input, output) => {\n  let line = input[output.length];\n\n  if (!dedentStartTag(input, output)) {\n    return false;\n  }\n\n  if (input[output.length - 1].includes('/>')) {\n    return true;\n  }\n\n  let isText = false;\n  const stack = [];\n  stack.push(getIndentationLength(line));\n\n  while (stack.length > 0 && output.length < input.length) {\n    line = input[output.length];\n\n    if (isFirstLineOfTag(line)) {\n      if (line.includes('</')) {\n        output.push(dedentLine(line));\n        stack.pop();\n      } else {\n        if (!dedentStartTag(input, output)) {\n          return false;\n        }\n\n        if (!input[output.length - 1].includes('/>')) {\n          stack.push(getIndentationLength(line));\n        }\n      }\n\n      isText = false;\n    } else {\n      if (isText) {\n        return false; // because text has more than one adjacent line\n      }\n\n      const indentationLengthOfTag = stack[stack.length - 1];\n      output.push(line.slice(indentationLengthOfTag + 2));\n      isText = true;\n    }\n  }\n\n  return stack.length === 0;\n}; // Return lines unindented by heuristic;\n// otherwise return null because:\n// * props include a multiline string\n// * text has more than one adjacent line\n// * markup does not close\n\n\nconst dedentLines = input => {\n  const output = [];\n\n  while (output.length < input.length) {\n    const line = input[output.length];\n\n    if (hasUnmatchedDoubleQuoteMarks(line)) {\n      return null;\n    } else if (isFirstLineOfTag(line)) {\n      if (!dedentMarkup(input, output)) {\n        return null;\n      }\n    } else {\n      output.push(dedentLine(line));\n    }\n  }\n\n  return output;\n};\n\nexports.dedentLines = dedentLines;","map":{"version":3,"names":["Object","defineProperty","exports","value","dedentLines","getIndentationLength","line","result","exec","length","dedentLine","slice","hasUnmatchedDoubleQuoteMarks","string","n","i","indexOf","isFirstLineOfTag","test","dedentStartTag","input","output","push","includes","dedentMarkup","isText","stack","pop","indentationLengthOfTag"],"sources":["/Users/lincolnkushwah/Desktop/All/React Projects/house_joy_new/node_modules/jest-snapshot/build/dedentLines.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.dedentLines = void 0;\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nconst getIndentationLength = line => {\n  const result = /^( {2})+/.exec(line);\n  return result === null ? 0 : result[0].length;\n};\n\nconst dedentLine = line => line.slice(getIndentationLength(line)); // Return true if:\n// \"key\": \"value has multiple lines\\n…\n// \"key has multiple lines\\n…\n\nconst hasUnmatchedDoubleQuoteMarks = string => {\n  let n = 0;\n  let i = string.indexOf('\"', 0);\n\n  while (i !== -1) {\n    if (i === 0 || string[i - 1] !== '\\\\') {\n      n += 1;\n    }\n\n    i = string.indexOf('\"', i + 1);\n  }\n\n  return n % 2 !== 0;\n};\n\nconst isFirstLineOfTag = line => /^( {2})*\\</.test(line); // The length of the output array is the index of the next input line.\n// Push dedented lines of start tag onto output and return true;\n// otherwise return false because:\n// * props include a multiline string (or text node, if props have markup)\n// * start tag does not close\n\nconst dedentStartTag = (input, output) => {\n  let line = input[output.length];\n  output.push(dedentLine(line));\n\n  if (line.includes('>')) {\n    return true;\n  }\n\n  while (output.length < input.length) {\n    line = input[output.length];\n\n    if (hasUnmatchedDoubleQuoteMarks(line)) {\n      return false; // because props include a multiline string\n    } else if (isFirstLineOfTag(line)) {\n      // Recursion only if props have markup.\n      if (!dedentMarkup(input, output)) {\n        return false;\n      }\n    } else {\n      output.push(dedentLine(line));\n\n      if (line.includes('>')) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}; // Push dedented lines of markup onto output and return true;\n// otherwise return false because:\n// * props include a multiline string\n// * text has more than one adjacent line\n// * markup does not close\n\nconst dedentMarkup = (input, output) => {\n  let line = input[output.length];\n\n  if (!dedentStartTag(input, output)) {\n    return false;\n  }\n\n  if (input[output.length - 1].includes('/>')) {\n    return true;\n  }\n\n  let isText = false;\n  const stack = [];\n  stack.push(getIndentationLength(line));\n\n  while (stack.length > 0 && output.length < input.length) {\n    line = input[output.length];\n\n    if (isFirstLineOfTag(line)) {\n      if (line.includes('</')) {\n        output.push(dedentLine(line));\n        stack.pop();\n      } else {\n        if (!dedentStartTag(input, output)) {\n          return false;\n        }\n\n        if (!input[output.length - 1].includes('/>')) {\n          stack.push(getIndentationLength(line));\n        }\n      }\n\n      isText = false;\n    } else {\n      if (isText) {\n        return false; // because text has more than one adjacent line\n      }\n\n      const indentationLengthOfTag = stack[stack.length - 1];\n      output.push(line.slice(indentationLengthOfTag + 2));\n      isText = true;\n    }\n  }\n\n  return stack.length === 0;\n}; // Return lines unindented by heuristic;\n// otherwise return null because:\n// * props include a multiline string\n// * text has more than one adjacent line\n// * markup does not close\n\nconst dedentLines = input => {\n  const output = [];\n\n  while (output.length < input.length) {\n    const line = input[output.length];\n\n    if (hasUnmatchedDoubleQuoteMarks(line)) {\n      return null;\n    } else if (isFirstLineOfTag(line)) {\n      if (!dedentMarkup(input, output)) {\n        return null;\n      }\n    } else {\n      output.push(dedentLine(line));\n    }\n  }\n\n  return output;\n};\n\nexports.dedentLines = dedentLines;\n"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;EAC3CC,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,WAAR,GAAsB,KAAK,CAA3B;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMC,oBAAoB,GAAGC,IAAI,IAAI;EACnC,MAAMC,MAAM,GAAG,WAAWC,IAAX,CAAgBF,IAAhB,CAAf;EACA,OAAOC,MAAM,KAAK,IAAX,GAAkB,CAAlB,GAAsBA,MAAM,CAAC,CAAD,CAAN,CAAUE,MAAvC;AACD,CAHD;;AAKA,MAAMC,UAAU,GAAGJ,IAAI,IAAIA,IAAI,CAACK,KAAL,CAAWN,oBAAoB,CAACC,IAAD,CAA/B,CAA3B,C,CAAmE;AACnE;AACA;;;AAEA,MAAMM,4BAA4B,GAAGC,MAAM,IAAI;EAC7C,IAAIC,CAAC,GAAG,CAAR;EACA,IAAIC,CAAC,GAAGF,MAAM,CAACG,OAAP,CAAe,GAAf,EAAoB,CAApB,CAAR;;EAEA,OAAOD,CAAC,KAAK,CAAC,CAAd,EAAiB;IACf,IAAIA,CAAC,KAAK,CAAN,IAAWF,MAAM,CAACE,CAAC,GAAG,CAAL,CAAN,KAAkB,IAAjC,EAAuC;MACrCD,CAAC,IAAI,CAAL;IACD;;IAEDC,CAAC,GAAGF,MAAM,CAACG,OAAP,CAAe,GAAf,EAAoBD,CAAC,GAAG,CAAxB,CAAJ;EACD;;EAED,OAAOD,CAAC,GAAG,CAAJ,KAAU,CAAjB;AACD,CAbD;;AAeA,MAAMG,gBAAgB,GAAGX,IAAI,IAAI,aAAaY,IAAb,CAAkBZ,IAAlB,CAAjC,C,CAA0D;AAC1D;AACA;AACA;AACA;;;AAEA,MAAMa,cAAc,GAAG,CAACC,KAAD,EAAQC,MAAR,KAAmB;EACxC,IAAIf,IAAI,GAAGc,KAAK,CAACC,MAAM,CAACZ,MAAR,CAAhB;EACAY,MAAM,CAACC,IAAP,CAAYZ,UAAU,CAACJ,IAAD,CAAtB;;EAEA,IAAIA,IAAI,CAACiB,QAAL,CAAc,GAAd,CAAJ,EAAwB;IACtB,OAAO,IAAP;EACD;;EAED,OAAOF,MAAM,CAACZ,MAAP,GAAgBW,KAAK,CAACX,MAA7B,EAAqC;IACnCH,IAAI,GAAGc,KAAK,CAACC,MAAM,CAACZ,MAAR,CAAZ;;IAEA,IAAIG,4BAA4B,CAACN,IAAD,CAAhC,EAAwC;MACtC,OAAO,KAAP,CADsC,CACxB;IACf,CAFD,MAEO,IAAIW,gBAAgB,CAACX,IAAD,CAApB,EAA4B;MACjC;MACA,IAAI,CAACkB,YAAY,CAACJ,KAAD,EAAQC,MAAR,CAAjB,EAAkC;QAChC,OAAO,KAAP;MACD;IACF,CALM,MAKA;MACLA,MAAM,CAACC,IAAP,CAAYZ,UAAU,CAACJ,IAAD,CAAtB;;MAEA,IAAIA,IAAI,CAACiB,QAAL,CAAc,GAAd,CAAJ,EAAwB;QACtB,OAAO,IAAP;MACD;IACF;EACF;;EAED,OAAO,KAAP;AACD,CA5BD,C,CA4BG;AACH;AACA;AACA;AACA;;;AAEA,MAAMC,YAAY,GAAG,CAACJ,KAAD,EAAQC,MAAR,KAAmB;EACtC,IAAIf,IAAI,GAAGc,KAAK,CAACC,MAAM,CAACZ,MAAR,CAAhB;;EAEA,IAAI,CAACU,cAAc,CAACC,KAAD,EAAQC,MAAR,CAAnB,EAAoC;IAClC,OAAO,KAAP;EACD;;EAED,IAAID,KAAK,CAACC,MAAM,CAACZ,MAAP,GAAgB,CAAjB,CAAL,CAAyBc,QAAzB,CAAkC,IAAlC,CAAJ,EAA6C;IAC3C,OAAO,IAAP;EACD;;EAED,IAAIE,MAAM,GAAG,KAAb;EACA,MAAMC,KAAK,GAAG,EAAd;EACAA,KAAK,CAACJ,IAAN,CAAWjB,oBAAoB,CAACC,IAAD,CAA/B;;EAEA,OAAOoB,KAAK,CAACjB,MAAN,GAAe,CAAf,IAAoBY,MAAM,CAACZ,MAAP,GAAgBW,KAAK,CAACX,MAAjD,EAAyD;IACvDH,IAAI,GAAGc,KAAK,CAACC,MAAM,CAACZ,MAAR,CAAZ;;IAEA,IAAIQ,gBAAgB,CAACX,IAAD,CAApB,EAA4B;MAC1B,IAAIA,IAAI,CAACiB,QAAL,CAAc,IAAd,CAAJ,EAAyB;QACvBF,MAAM,CAACC,IAAP,CAAYZ,UAAU,CAACJ,IAAD,CAAtB;QACAoB,KAAK,CAACC,GAAN;MACD,CAHD,MAGO;QACL,IAAI,CAACR,cAAc,CAACC,KAAD,EAAQC,MAAR,CAAnB,EAAoC;UAClC,OAAO,KAAP;QACD;;QAED,IAAI,CAACD,KAAK,CAACC,MAAM,CAACZ,MAAP,GAAgB,CAAjB,CAAL,CAAyBc,QAAzB,CAAkC,IAAlC,CAAL,EAA8C;UAC5CG,KAAK,CAACJ,IAAN,CAAWjB,oBAAoB,CAACC,IAAD,CAA/B;QACD;MACF;;MAEDmB,MAAM,GAAG,KAAT;IACD,CAfD,MAeO;MACL,IAAIA,MAAJ,EAAY;QACV,OAAO,KAAP,CADU,CACI;MACf;;MAED,MAAMG,sBAAsB,GAAGF,KAAK,CAACA,KAAK,CAACjB,MAAN,GAAe,CAAhB,CAApC;MACAY,MAAM,CAACC,IAAP,CAAYhB,IAAI,CAACK,KAAL,CAAWiB,sBAAsB,GAAG,CAApC,CAAZ;MACAH,MAAM,GAAG,IAAT;IACD;EACF;;EAED,OAAOC,KAAK,CAACjB,MAAN,KAAiB,CAAxB;AACD,CA7CD,C,CA6CG;AACH;AACA;AACA;AACA;;;AAEA,MAAML,WAAW,GAAGgB,KAAK,IAAI;EAC3B,MAAMC,MAAM,GAAG,EAAf;;EAEA,OAAOA,MAAM,CAACZ,MAAP,GAAgBW,KAAK,CAACX,MAA7B,EAAqC;IACnC,MAAMH,IAAI,GAAGc,KAAK,CAACC,MAAM,CAACZ,MAAR,CAAlB;;IAEA,IAAIG,4BAA4B,CAACN,IAAD,CAAhC,EAAwC;MACtC,OAAO,IAAP;IACD,CAFD,MAEO,IAAIW,gBAAgB,CAACX,IAAD,CAApB,EAA4B;MACjC,IAAI,CAACkB,YAAY,CAACJ,KAAD,EAAQC,MAAR,CAAjB,EAAkC;QAChC,OAAO,IAAP;MACD;IACF,CAJM,MAIA;MACLA,MAAM,CAACC,IAAP,CAAYZ,UAAU,CAACJ,IAAD,CAAtB;IACD;EACF;;EAED,OAAOe,MAAP;AACD,CAlBD;;AAoBAnB,OAAO,CAACE,WAAR,GAAsBA,WAAtB"},"metadata":{},"sourceType":"script"}