{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.DuplicateError = void 0;\nObject.defineProperty(exports, 'ModuleMap', {\n  enumerable: true,\n  get: function () {\n    return _ModuleMap.default;\n  }\n});\nexports.default = void 0;\n\nfunction _child_process() {\n  const data = require('child_process');\n\n  _child_process = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _crypto() {\n  const data = require('crypto');\n\n  _crypto = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _events() {\n  const data = require('events');\n\n  _events = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _os() {\n  const data = require('os');\n\n  _os = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction path() {\n  const data = _interopRequireWildcard(require('path'));\n\n  path = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestRegexUtil() {\n  const data = require('jest-regex-util');\n\n  _jestRegexUtil = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestSerializer() {\n  const data = _interopRequireDefault(require('jest-serializer'));\n\n  _jestSerializer = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestWorker() {\n  const data = require('jest-worker');\n\n  _jestWorker = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _HasteFS = _interopRequireDefault(require('./HasteFS'));\n\nvar _ModuleMap = _interopRequireDefault(require('./ModuleMap'));\n\nvar _constants = _interopRequireDefault(require('./constants'));\n\nvar _node = _interopRequireDefault(require('./crawlers/node'));\n\nvar _watchman = _interopRequireDefault(require('./crawlers/watchman'));\n\nvar _getMockName = _interopRequireDefault(require('./getMockName'));\n\nvar fastPath = _interopRequireWildcard(require('./lib/fast_path'));\n\nvar _getPlatformExtension = _interopRequireDefault(require('./lib/getPlatformExtension'));\n\nvar _normalizePathSep = _interopRequireDefault(require('./lib/normalizePathSep'));\n\nvar _FSEventsWatcher = _interopRequireDefault(require('./watchers/FSEventsWatcher'));\n\nvar _NodeWatcher = _interopRequireDefault(require('./watchers/NodeWatcher'));\n\nvar _WatchmanWatcher = _interopRequireDefault(require('./watchers/WatchmanWatcher'));\n\nvar _worker = require('./worker');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== 'function') return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== 'object' && typeof obj !== 'function') {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache(nodeInterop);\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (key !== 'default' && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n} // TypeScript doesn't like us importing from outside `rootDir`, but it doesn't\n// understand `require`.\n\n\nconst {\n  version: VERSION\n} = require('../package.json');\n\nconst CHANGE_INTERVAL = 30;\nconst MAX_WAIT_TIME = 240000;\nconst NODE_MODULES = path().sep + 'node_modules' + path().sep;\nconst PACKAGE_JSON = path().sep + 'package.json';\nconst VCS_DIRECTORIES = ['.git', '.hg'].map(vcs => (0, _jestRegexUtil().escapePathForRegex)(path().sep + vcs + path().sep)).join('|');\n\nconst canUseWatchman = (() => {\n  try {\n    (0, _child_process().execSync)('watchman --version', {\n      stdio: ['ignore']\n    });\n    return true;\n  } catch {}\n\n  return false;\n})();\n\nfunction invariant(condition, message) {\n  if (!condition) {\n    throw new Error(message);\n  }\n}\n/**\n * HasteMap is a JavaScript implementation of Facebook's haste module system.\n *\n * This implementation is inspired by https://github.com/facebook/node-haste\n * and was built with for high-performance in large code repositories with\n * hundreds of thousands of files. This implementation is scalable and provides\n * predictable performance.\n *\n * Because the haste map creation and synchronization is critical to startup\n * performance and most tasks are blocked by I/O this class makes heavy use of\n * synchronous operations. It uses worker processes for parallelizing file\n * access and metadata extraction.\n *\n * The data structures created by `jest-haste-map` can be used directly from the\n * cache without further processing. The metadata objects in the `files` and\n * `map` objects contain cross-references: a metadata object from one can look\n * up the corresponding metadata object in the other map. Note that in most\n * projects, the number of files will be greater than the number of haste\n * modules one module can refer to many files based on platform extensions.\n *\n * type HasteMap = {\n *   clocks: WatchmanClocks,\n *   files: {[filepath: string]: FileMetaData},\n *   map: {[id: string]: ModuleMapItem},\n *   mocks: {[id: string]: string},\n * }\n *\n * // Watchman clocks are used for query synchronization and file system deltas.\n * type WatchmanClocks = {[filepath: string]: string};\n *\n * type FileMetaData = {\n *   id: ?string, // used to look up module metadata objects in `map`.\n *   mtime: number, // check for outdated files.\n *   size: number, // size of the file in bytes.\n *   visited: boolean, // whether the file has been parsed or not.\n *   dependencies: Array<string>, // all relative dependencies of this file.\n *   sha1: ?string, // SHA-1 of the file, if requested via options.\n * };\n *\n * // Modules can be targeted to a specific platform based on the file name.\n * // Example: platform.ios.js and Platform.android.js will both map to the same\n * // `Platform` module. The platform should be specified during resolution.\n * type ModuleMapItem = {[platform: string]: ModuleMetaData};\n *\n * //\n * type ModuleMetaData = {\n *   path: string, // the path to look up the file object in `files`.\n *   type: string, // the module type (either `package` or `module`).\n * };\n *\n * Note that the data structures described above are conceptual only. The actual\n * implementation uses arrays and constant keys for metadata storage. Instead of\n * `{id: 'flatMap', mtime: 3421, size: 42, visited: true, dependencies: []}` the real\n * representation is similar to `['flatMap', 3421, 42, 1, []]` to save storage space\n * and reduce parse and write time of a big JSON blob.\n *\n * The HasteMap is created as follows:\n *  1. read data from the cache or create an empty structure.\n *\n *  2. crawl the file system.\n *     * empty cache: crawl the entire file system.\n *     * cache available:\n *       * if watchman is available: get file system delta changes.\n *       * if watchman is unavailable: crawl the entire file system.\n *     * build metadata objects for every file. This builds the `files` part of\n *       the `HasteMap`.\n *\n *  3. parse and extract metadata from changed files.\n *     * this is done in parallel over worker processes to improve performance.\n *     * the worst case is to parse all files.\n *     * the best case is no file system access and retrieving all data from\n *       the cache.\n *     * the average case is a small number of changed files.\n *\n *  4. serialize the new `HasteMap` in a cache file.\n *     Worker processes can directly access the cache through `HasteMap.read()`.\n *\n */\n\n\nclass HasteMap extends _events().EventEmitter {\n  static getStatic(config) {\n    if (config.haste.hasteMapModulePath) {\n      return require(config.haste.hasteMapModulePath);\n    }\n\n    return HasteMap;\n  }\n\n  static create(options) {\n    if (options.hasteMapModulePath) {\n      const CustomHasteMap = require(options.hasteMapModulePath);\n\n      return new CustomHasteMap(options);\n    }\n\n    return new HasteMap(options);\n  }\n\n  constructor(options) {\n    super();\n\n    _defineProperty(this, '_buildPromise', void 0);\n\n    _defineProperty(this, '_cachePath', void 0);\n\n    _defineProperty(this, '_changeInterval', void 0);\n\n    _defineProperty(this, '_console', void 0);\n\n    _defineProperty(this, '_options', void 0);\n\n    _defineProperty(this, '_watchers', void 0);\n\n    _defineProperty(this, '_worker', void 0);\n\n    this._options = {\n      cacheDirectory: options.cacheDirectory || (0, _os().tmpdir)(),\n      computeDependencies: options.computeDependencies === undefined ? true : options.computeDependencies,\n      computeSha1: options.computeSha1 || false,\n      dependencyExtractor: options.dependencyExtractor || null,\n      enableSymlinks: options.enableSymlinks || false,\n      extensions: options.extensions,\n      forceNodeFilesystemAPI: !!options.forceNodeFilesystemAPI,\n      hasteImplModulePath: options.hasteImplModulePath,\n      maxWorkers: options.maxWorkers,\n      mocksPattern: options.mocksPattern ? new RegExp(options.mocksPattern) : null,\n      name: options.name,\n      platforms: options.platforms,\n      resetCache: options.resetCache,\n      retainAllFiles: options.retainAllFiles,\n      rootDir: options.rootDir,\n      roots: Array.from(new Set(options.roots)),\n      skipPackageJson: !!options.skipPackageJson,\n      throwOnModuleCollision: !!options.throwOnModuleCollision,\n      useWatchman: options.useWatchman == null ? true : options.useWatchman,\n      watch: !!options.watch\n    };\n    this._console = options.console || global.console;\n\n    if (options.ignorePattern) {\n      if (options.ignorePattern instanceof RegExp) {\n        this._options.ignorePattern = new RegExp(options.ignorePattern.source.concat('|' + VCS_DIRECTORIES), options.ignorePattern.flags);\n      } else {\n        throw new Error('jest-haste-map: the `ignorePattern` option must be a RegExp');\n      }\n    } else {\n      this._options.ignorePattern = new RegExp(VCS_DIRECTORIES);\n    }\n\n    if (this._options.enableSymlinks && this._options.useWatchman) {\n      throw new Error('jest-haste-map: enableSymlinks config option was set, but ' + 'is incompatible with watchman.\\n' + 'Set either `enableSymlinks` to false or `useWatchman` to false.');\n    }\n\n    const rootDirHash = (0, _crypto().createHash)('md5').update(options.rootDir).digest('hex');\n    let hasteImplHash = '';\n    let dependencyExtractorHash = '';\n\n    if (options.hasteImplModulePath) {\n      const hasteImpl = require(options.hasteImplModulePath);\n\n      if (hasteImpl.getCacheKey) {\n        hasteImplHash = String(hasteImpl.getCacheKey());\n      }\n    }\n\n    if (options.dependencyExtractor) {\n      const dependencyExtractor = require(options.dependencyExtractor);\n\n      if (dependencyExtractor.getCacheKey) {\n        dependencyExtractorHash = String(dependencyExtractor.getCacheKey());\n      }\n    }\n\n    this._cachePath = HasteMap.getCacheFilePath(this._options.cacheDirectory, `haste-map-${this._options.name}-${rootDirHash}`, VERSION, this._options.name, this._options.roots.map(root => fastPath.relative(options.rootDir, root)).join(':'), this._options.extensions.join(':'), this._options.platforms.join(':'), this._options.computeSha1.toString(), options.mocksPattern || '', (options.ignorePattern || '').toString(), hasteImplHash, dependencyExtractorHash, this._options.computeDependencies.toString());\n    this._buildPromise = null;\n    this._watchers = [];\n    this._worker = null;\n  }\n\n  static getCacheFilePath(tmpdir, name) {\n    for (var _len = arguments.length, extra = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      extra[_key - 2] = arguments[_key];\n    }\n\n    const hash = (0, _crypto().createHash)('md5').update(extra.join(''));\n    return path().join(tmpdir, name.replace(/\\W/g, '-') + '-' + hash.digest('hex'));\n  }\n\n  static getModuleMapFromJSON(json) {\n    return _ModuleMap.default.fromJSON(json);\n  }\n\n  getCacheFilePath() {\n    return this._cachePath;\n  }\n\n  build() {\n    if (!this._buildPromise) {\n      this._buildPromise = (async () => {\n        const data = await this._buildFileMap(); // Persist when we don't know if files changed (changedFiles undefined)\n        // or when we know a file was changed or deleted.\n\n        let hasteMap;\n\n        if (data.changedFiles === undefined || data.changedFiles.size > 0 || data.removedFiles.size > 0) {\n          hasteMap = await this._buildHasteMap(data);\n\n          this._persist(hasteMap);\n        } else {\n          hasteMap = data.hasteMap;\n        }\n\n        const rootDir = this._options.rootDir;\n        const hasteFS = new _HasteFS.default({\n          files: hasteMap.files,\n          rootDir\n        });\n        const moduleMap = new _ModuleMap.default({\n          duplicates: hasteMap.duplicates,\n          map: hasteMap.map,\n          mocks: hasteMap.mocks,\n          rootDir\n        });\n\n        const __hasteMapForTest = process.env.NODE_ENV === 'test' && hasteMap || null;\n\n        await this._watch(hasteMap);\n        return {\n          __hasteMapForTest,\n          hasteFS,\n          moduleMap\n        };\n      })();\n    }\n\n    return this._buildPromise;\n  }\n  /**\n   * 1. read data from the cache or create an empty structure.\n   */\n\n\n  read() {\n    let hasteMap;\n\n    try {\n      hasteMap = _jestSerializer().default.readFileSync(this._cachePath);\n    } catch {\n      hasteMap = this._createEmptyMap();\n    }\n\n    return hasteMap;\n  }\n\n  readModuleMap() {\n    const data = this.read();\n    return new _ModuleMap.default({\n      duplicates: data.duplicates,\n      map: data.map,\n      mocks: data.mocks,\n      rootDir: this._options.rootDir\n    });\n  }\n  /**\n   * 2. crawl the file system.\n   */\n\n\n  async _buildFileMap() {\n    let hasteMap;\n\n    try {\n      const read = this._options.resetCache ? this._createEmptyMap : this.read;\n      hasteMap = await read.call(this);\n    } catch {\n      hasteMap = this._createEmptyMap();\n    }\n\n    return this._crawl(hasteMap);\n  }\n  /**\n   * 3. parse and extract metadata from changed files.\n   */\n\n\n  _processFile(hasteMap, map, mocks, filePath, workerOptions) {\n    const rootDir = this._options.rootDir;\n\n    const setModule = (id, module) => {\n      let moduleMap = map.get(id);\n\n      if (!moduleMap) {\n        moduleMap = Object.create(null);\n        map.set(id, moduleMap);\n      }\n\n      const platform = (0, _getPlatformExtension.default)(module[_constants.default.PATH], this._options.platforms) || _constants.default.GENERIC_PLATFORM;\n\n      const existingModule = moduleMap[platform];\n\n      if (existingModule && existingModule[_constants.default.PATH] !== module[_constants.default.PATH]) {\n        const method = this._options.throwOnModuleCollision ? 'error' : 'warn';\n\n        this._console[method](['jest-haste-map: Haste module naming collision: ' + id, '  The following files share their name; please adjust your hasteImpl:', '    * <rootDir>' + path().sep + existingModule[_constants.default.PATH], '    * <rootDir>' + path().sep + module[_constants.default.PATH], ''].join('\\n'));\n\n        if (this._options.throwOnModuleCollision) {\n          throw new DuplicateError(existingModule[_constants.default.PATH], module[_constants.default.PATH]);\n        } // We do NOT want consumers to use a module that is ambiguous.\n\n\n        delete moduleMap[platform];\n\n        if (Object.keys(moduleMap).length === 1) {\n          map.delete(id);\n        }\n\n        let dupsByPlatform = hasteMap.duplicates.get(id);\n\n        if (dupsByPlatform == null) {\n          dupsByPlatform = new Map();\n          hasteMap.duplicates.set(id, dupsByPlatform);\n        }\n\n        const dups = new Map([[module[_constants.default.PATH], module[_constants.default.TYPE]], [existingModule[_constants.default.PATH], existingModule[_constants.default.TYPE]]]);\n        dupsByPlatform.set(platform, dups);\n        return;\n      }\n\n      const dupsByPlatform = hasteMap.duplicates.get(id);\n\n      if (dupsByPlatform != null) {\n        const dups = dupsByPlatform.get(platform);\n\n        if (dups != null) {\n          dups.set(module[_constants.default.PATH], module[_constants.default.TYPE]);\n        }\n\n        return;\n      }\n\n      moduleMap[platform] = module;\n    };\n\n    const relativeFilePath = fastPath.relative(rootDir, filePath);\n    const fileMetadata = hasteMap.files.get(relativeFilePath);\n\n    if (!fileMetadata) {\n      throw new Error('jest-haste-map: File to process was not found in the haste map.');\n    }\n\n    const moduleMetadata = hasteMap.map.get(fileMetadata[_constants.default.ID]);\n    const computeSha1 = this._options.computeSha1 && !fileMetadata[_constants.default.SHA1]; // Callback called when the response from the worker is successful.\n\n    const workerReply = metadata => {\n      // `1` for truthy values instead of `true` to save cache space.\n      fileMetadata[_constants.default.VISITED] = 1;\n      const metadataId = metadata.id;\n      const metadataModule = metadata.module;\n\n      if (metadataId && metadataModule) {\n        fileMetadata[_constants.default.ID] = metadataId;\n        setModule(metadataId, metadataModule);\n      }\n\n      fileMetadata[_constants.default.DEPENDENCIES] = metadata.dependencies ? metadata.dependencies.join(_constants.default.DEPENDENCY_DELIM) : '';\n\n      if (computeSha1) {\n        fileMetadata[_constants.default.SHA1] = metadata.sha1;\n      }\n    }; // Callback called when the response from the worker is an error.\n\n\n    const workerError = error => {\n      if (typeof error !== 'object' || !error.message || !error.stack) {\n        error = new Error(error);\n        error.stack = ''; // Remove stack for stack-less errors.\n      }\n\n      if (!['ENOENT', 'EACCES'].includes(error.code)) {\n        throw error;\n      } // If a file cannot be read we remove it from the file list and\n      // ignore the failure silently.\n\n\n      hasteMap.files.delete(relativeFilePath);\n    }; // If we retain all files in the virtual HasteFS representation, we avoid\n    // reading them if they aren't important (node_modules).\n\n\n    if (this._options.retainAllFiles && filePath.includes(NODE_MODULES)) {\n      if (computeSha1) {\n        return this._getWorker(workerOptions).getSha1({\n          computeDependencies: this._options.computeDependencies,\n          computeSha1,\n          dependencyExtractor: this._options.dependencyExtractor,\n          filePath,\n          hasteImplModulePath: this._options.hasteImplModulePath,\n          rootDir\n        }).then(workerReply, workerError);\n      }\n\n      return null;\n    }\n\n    if (this._options.mocksPattern && this._options.mocksPattern.test(filePath)) {\n      const mockPath = (0, _getMockName.default)(filePath);\n      const existingMockPath = mocks.get(mockPath);\n\n      if (existingMockPath) {\n        const secondMockPath = fastPath.relative(rootDir, filePath);\n\n        if (existingMockPath !== secondMockPath) {\n          const method = this._options.throwOnModuleCollision ? 'error' : 'warn';\n\n          this._console[method](['jest-haste-map: duplicate manual mock found: ' + mockPath, '  The following files share their name; please delete one of them:', '    * <rootDir>' + path().sep + existingMockPath, '    * <rootDir>' + path().sep + secondMockPath, ''].join('\\n'));\n\n          if (this._options.throwOnModuleCollision) {\n            throw new DuplicateError(existingMockPath, secondMockPath);\n          }\n        }\n      }\n\n      mocks.set(mockPath, relativeFilePath);\n    }\n\n    if (fileMetadata[_constants.default.VISITED]) {\n      if (!fileMetadata[_constants.default.ID]) {\n        return null;\n      }\n\n      if (moduleMetadata != null) {\n        const platform = (0, _getPlatformExtension.default)(filePath, this._options.platforms) || _constants.default.GENERIC_PLATFORM;\n\n        const module = moduleMetadata[platform];\n\n        if (module == null) {\n          return null;\n        }\n\n        const moduleId = fileMetadata[_constants.default.ID];\n        let modulesByPlatform = map.get(moduleId);\n\n        if (!modulesByPlatform) {\n          modulesByPlatform = Object.create(null);\n          map.set(moduleId, modulesByPlatform);\n        }\n\n        modulesByPlatform[platform] = module;\n        return null;\n      }\n    }\n\n    return this._getWorker(workerOptions).worker({\n      computeDependencies: this._options.computeDependencies,\n      computeSha1,\n      dependencyExtractor: this._options.dependencyExtractor,\n      filePath,\n      hasteImplModulePath: this._options.hasteImplModulePath,\n      rootDir\n    }).then(workerReply, workerError);\n  }\n\n  _buildHasteMap(data) {\n    const {\n      removedFiles,\n      changedFiles,\n      hasteMap\n    } = data; // If any files were removed or we did not track what files changed, process\n    // every file looking for changes. Otherwise, process only changed files.\n\n    let map;\n    let mocks;\n    let filesToProcess;\n\n    if (changedFiles === undefined || removedFiles.size) {\n      map = new Map();\n      mocks = new Map();\n      filesToProcess = hasteMap.files;\n    } else {\n      map = hasteMap.map;\n      mocks = hasteMap.mocks;\n      filesToProcess = changedFiles;\n    }\n\n    for (const [relativeFilePath, fileMetadata] of removedFiles) {\n      this._recoverDuplicates(hasteMap, relativeFilePath, fileMetadata[_constants.default.ID]);\n    }\n\n    const promises = [];\n\n    for (const relativeFilePath of filesToProcess.keys()) {\n      if (this._options.skipPackageJson && relativeFilePath.endsWith(PACKAGE_JSON)) {\n        continue;\n      } // SHA-1, if requested, should already be present thanks to the crawler.\n\n\n      const filePath = fastPath.resolve(this._options.rootDir, relativeFilePath);\n\n      const promise = this._processFile(hasteMap, map, mocks, filePath);\n\n      if (promise) {\n        promises.push(promise);\n      }\n    }\n\n    return Promise.all(promises).then(() => {\n      this._cleanup();\n\n      hasteMap.map = map;\n      hasteMap.mocks = mocks;\n      return hasteMap;\n    }, error => {\n      this._cleanup();\n\n      throw error;\n    });\n  }\n\n  _cleanup() {\n    const worker = this._worker; // @ts-expect-error\n\n    if (worker && typeof worker.end === 'function') {\n      // @ts-expect-error\n      worker.end();\n    }\n\n    this._worker = null;\n  }\n  /**\n   * 4. serialize the new `HasteMap` in a cache file.\n   */\n\n\n  _persist(hasteMap) {\n    _jestSerializer().default.writeFileSync(this._cachePath, hasteMap);\n  }\n  /**\n   * Creates workers or parses files and extracts metadata in-process.\n   */\n\n\n  _getWorker(options) {\n    if (!this._worker) {\n      if (options && options.forceInBand || this._options.maxWorkers <= 1) {\n        this._worker = {\n          getSha1: _worker.getSha1,\n          worker: _worker.worker\n        };\n      } else {\n        // @ts-expect-error: assignment of a worker with custom properties.\n        this._worker = new (_jestWorker().Worker)(require.resolve('./worker'), {\n          exposedMethods: ['getSha1', 'worker'],\n          maxRetries: 3,\n          numWorkers: this._options.maxWorkers\n        });\n      }\n    }\n\n    return this._worker;\n  }\n\n  _crawl(hasteMap) {\n    const options = this._options;\n\n    const ignore = this._ignore.bind(this);\n\n    const crawl = canUseWatchman && this._options.useWatchman ? _watchman.default : _node.default;\n    const crawlerOptions = {\n      computeSha1: options.computeSha1,\n      data: hasteMap,\n      enableSymlinks: options.enableSymlinks,\n      extensions: options.extensions,\n      forceNodeFilesystemAPI: options.forceNodeFilesystemAPI,\n      ignore,\n      rootDir: options.rootDir,\n      roots: options.roots\n    };\n\n    const retry = error => {\n      if (crawl === _watchman.default) {\n        this._console.warn('jest-haste-map: Watchman crawl failed. Retrying once with node ' + 'crawler.\\n' + \"  Usually this happens when watchman isn't running. Create an \" + \"empty `.watchmanconfig` file in your project's root folder or \" + 'initialize a git or hg repository in your project.\\n' + '  ' + error);\n\n        return (0, _node.default)(crawlerOptions).catch(e => {\n          throw new Error('Crawler retry failed:\\n' + `  Original error: ${error.message}\\n` + `  Retry error: ${e.message}\\n`);\n        });\n      }\n\n      throw error;\n    };\n\n    try {\n      return crawl(crawlerOptions).catch(retry);\n    } catch (error) {\n      return retry(error);\n    }\n  }\n  /**\n   * Watch mode\n   */\n\n\n  _watch(hasteMap) {\n    if (!this._options.watch) {\n      return Promise.resolve();\n    } // In watch mode, we'll only warn about module collisions and we'll retain\n    // all files, even changes to node_modules.\n\n\n    this._options.throwOnModuleCollision = false;\n    this._options.retainAllFiles = true; // WatchmanWatcher > FSEventsWatcher > sane.NodeWatcher\n\n    const Watcher = canUseWatchman && this._options.useWatchman ? _WatchmanWatcher.default : _FSEventsWatcher.default.isSupported() ? _FSEventsWatcher.default : _NodeWatcher.default;\n    const extensions = this._options.extensions;\n    const ignorePattern = this._options.ignorePattern;\n    const rootDir = this._options.rootDir;\n    let changeQueue = Promise.resolve();\n    let eventsQueue = []; // We only need to copy the entire haste map once on every \"frame\".\n\n    let mustCopy = true;\n\n    const createWatcher = root => {\n      const watcher = new Watcher(root, {\n        dot: true,\n        glob: extensions.map(extension => '**/*.' + extension),\n        ignored: ignorePattern\n      });\n      return new Promise((resolve, reject) => {\n        const rejectTimeout = setTimeout(() => reject(new Error('Failed to start watch mode.')), MAX_WAIT_TIME);\n        watcher.once('ready', () => {\n          clearTimeout(rejectTimeout);\n          watcher.on('all', onChange);\n          resolve(watcher);\n        });\n      });\n    };\n\n    const emitChange = () => {\n      if (eventsQueue.length) {\n        mustCopy = true;\n        const changeEvent = {\n          eventsQueue,\n          hasteFS: new _HasteFS.default({\n            files: hasteMap.files,\n            rootDir\n          }),\n          moduleMap: new _ModuleMap.default({\n            duplicates: hasteMap.duplicates,\n            map: hasteMap.map,\n            mocks: hasteMap.mocks,\n            rootDir\n          })\n        };\n        this.emit('change', changeEvent);\n        eventsQueue = [];\n      }\n    };\n\n    const onChange = (type, filePath, root, stat) => {\n      filePath = path().join(root, (0, _normalizePathSep.default)(filePath));\n\n      if (stat && stat.isDirectory() || this._ignore(filePath) || !extensions.some(extension => filePath.endsWith(extension))) {\n        return;\n      }\n\n      const relativeFilePath = fastPath.relative(rootDir, filePath);\n      const fileMetadata = hasteMap.files.get(relativeFilePath); // The file has been accessed, not modified\n\n      if (type === 'change' && fileMetadata && stat && fileMetadata[_constants.default.MTIME] === stat.mtime.getTime()) {\n        return;\n      }\n\n      changeQueue = changeQueue.then(() => {\n        // If we get duplicate events for the same file, ignore them.\n        if (eventsQueue.find(event => event.type === type && event.filePath === filePath && (!event.stat && !stat || !!event.stat && !!stat && event.stat.mtime.getTime() === stat.mtime.getTime()))) {\n          return null;\n        }\n\n        if (mustCopy) {\n          mustCopy = false;\n          hasteMap = {\n            clocks: new Map(hasteMap.clocks),\n            duplicates: new Map(hasteMap.duplicates),\n            files: new Map(hasteMap.files),\n            map: new Map(hasteMap.map),\n            mocks: new Map(hasteMap.mocks)\n          };\n        }\n\n        const add = () => {\n          eventsQueue.push({\n            filePath,\n            stat,\n            type\n          });\n          return null;\n        };\n\n        const fileMetadata = hasteMap.files.get(relativeFilePath); // If it's not an addition, delete the file and all its metadata\n\n        if (fileMetadata != null) {\n          const moduleName = fileMetadata[_constants.default.ID];\n\n          const platform = (0, _getPlatformExtension.default)(filePath, this._options.platforms) || _constants.default.GENERIC_PLATFORM;\n\n          hasteMap.files.delete(relativeFilePath);\n          let moduleMap = hasteMap.map.get(moduleName);\n\n          if (moduleMap != null) {\n            // We are forced to copy the object because jest-haste-map exposes\n            // the map as an immutable entity.\n            moduleMap = copy(moduleMap);\n            delete moduleMap[platform];\n\n            if (Object.keys(moduleMap).length === 0) {\n              hasteMap.map.delete(moduleName);\n            } else {\n              hasteMap.map.set(moduleName, moduleMap);\n            }\n          }\n\n          if (this._options.mocksPattern && this._options.mocksPattern.test(filePath)) {\n            const mockName = (0, _getMockName.default)(filePath);\n            hasteMap.mocks.delete(mockName);\n          }\n\n          this._recoverDuplicates(hasteMap, relativeFilePath, moduleName);\n        } // If the file was added or changed,\n        // parse it and update the haste map.\n\n\n        if (type === 'add' || type === 'change') {\n          invariant(stat, 'since the file exists or changed, it should have stats');\n          const fileMetadata = ['', stat.mtime.getTime(), stat.size, 0, '', null];\n          hasteMap.files.set(relativeFilePath, fileMetadata);\n\n          const promise = this._processFile(hasteMap, hasteMap.map, hasteMap.mocks, filePath, {\n            forceInBand: true\n          }); // Cleanup\n\n\n          this._cleanup();\n\n          if (promise) {\n            return promise.then(add);\n          } else {\n            // If a file in node_modules has changed,\n            // emit an event regardless.\n            add();\n          }\n        } else {\n          add();\n        }\n\n        return null;\n      }).catch(error => {\n        this._console.error(`jest-haste-map: watch error:\\n  ${error.stack}\\n`);\n      });\n    };\n\n    this._changeInterval = setInterval(emitChange, CHANGE_INTERVAL);\n    return Promise.all(this._options.roots.map(createWatcher)).then(watchers => {\n      this._watchers = watchers;\n    });\n  }\n  /**\n   * This function should be called when the file under `filePath` is removed\n   * or changed. When that happens, we want to figure out if that file was\n   * part of a group of files that had the same ID. If it was, we want to\n   * remove it from the group. Furthermore, if there is only one file\n   * remaining in the group, then we want to restore that single file as the\n   * correct resolution for its ID, and cleanup the duplicates index.\n   */\n\n\n  _recoverDuplicates(hasteMap, relativeFilePath, moduleName) {\n    let dupsByPlatform = hasteMap.duplicates.get(moduleName);\n\n    if (dupsByPlatform == null) {\n      return;\n    }\n\n    const platform = (0, _getPlatformExtension.default)(relativeFilePath, this._options.platforms) || _constants.default.GENERIC_PLATFORM;\n\n    let dups = dupsByPlatform.get(platform);\n\n    if (dups == null) {\n      return;\n    }\n\n    dupsByPlatform = copyMap(dupsByPlatform);\n    hasteMap.duplicates.set(moduleName, dupsByPlatform);\n    dups = copyMap(dups);\n    dupsByPlatform.set(platform, dups);\n    dups.delete(relativeFilePath);\n\n    if (dups.size !== 1) {\n      return;\n    }\n\n    const uniqueModule = dups.entries().next().value;\n\n    if (!uniqueModule) {\n      return;\n    }\n\n    let dedupMap = hasteMap.map.get(moduleName);\n\n    if (dedupMap == null) {\n      dedupMap = Object.create(null);\n      hasteMap.map.set(moduleName, dedupMap);\n    }\n\n    dedupMap[platform] = uniqueModule;\n    dupsByPlatform.delete(platform);\n\n    if (dupsByPlatform.size === 0) {\n      hasteMap.duplicates.delete(moduleName);\n    }\n  }\n\n  async end() {\n    if (this._changeInterval) {\n      clearInterval(this._changeInterval);\n    }\n\n    if (!this._watchers.length) {\n      return;\n    }\n\n    await Promise.all(this._watchers.map(watcher => watcher.close()));\n    this._watchers = [];\n  }\n  /**\n   * Helpers\n   */\n\n\n  _ignore(filePath) {\n    const ignorePattern = this._options.ignorePattern;\n    const ignoreMatched = ignorePattern instanceof RegExp ? ignorePattern.test(filePath) : ignorePattern && ignorePattern(filePath);\n    return ignoreMatched || !this._options.retainAllFiles && filePath.includes(NODE_MODULES);\n  }\n\n  _createEmptyMap() {\n    return {\n      clocks: new Map(),\n      duplicates: new Map(),\n      files: new Map(),\n      map: new Map(),\n      mocks: new Map()\n    };\n  }\n\n}\n\nexports.default = HasteMap;\n\n_defineProperty(HasteMap, 'H', _constants.default);\n\nclass DuplicateError extends Error {\n  constructor(mockPath1, mockPath2) {\n    super('Duplicated files or mocks. Please check the console for more info');\n\n    _defineProperty(this, 'mockPath1', void 0);\n\n    _defineProperty(this, 'mockPath2', void 0);\n\n    this.mockPath1 = mockPath1;\n    this.mockPath2 = mockPath2;\n  }\n\n}\n\nexports.DuplicateError = DuplicateError;\n\nfunction copy(object) {\n  return Object.assign(Object.create(null), object);\n}\n\nfunction copyMap(input) {\n  return new Map(input);\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","DuplicateError","enumerable","get","_ModuleMap","default","_child_process","data","require","_crypto","_events","_os","path","_interopRequireWildcard","_jestRegexUtil","_jestSerializer","_interopRequireDefault","_jestWorker","_HasteFS","_constants","_node","_watchman","_getMockName","fastPath","_getPlatformExtension","_normalizePathSep","_FSEventsWatcher","_NodeWatcher","_WatchmanWatcher","_worker","obj","__esModule","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","cache","has","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","_defineProperty","configurable","writable","version","VERSION","CHANGE_INTERVAL","MAX_WAIT_TIME","NODE_MODULES","sep","PACKAGE_JSON","VCS_DIRECTORIES","map","vcs","escapePathForRegex","join","canUseWatchman","execSync","stdio","invariant","condition","message","Error","HasteMap","EventEmitter","getStatic","config","haste","hasteMapModulePath","create","options","CustomHasteMap","constructor","_options","cacheDirectory","tmpdir","computeDependencies","undefined","computeSha1","dependencyExtractor","enableSymlinks","extensions","forceNodeFilesystemAPI","hasteImplModulePath","maxWorkers","mocksPattern","RegExp","name","platforms","resetCache","retainAllFiles","rootDir","roots","Array","from","Set","skipPackageJson","throwOnModuleCollision","useWatchman","watch","_console","console","global","ignorePattern","source","concat","flags","rootDirHash","createHash","update","digest","hasteImplHash","dependencyExtractorHash","hasteImpl","getCacheKey","String","_cachePath","getCacheFilePath","root","relative","toString","_buildPromise","_watchers","extra","hash","replace","getModuleMapFromJSON","json","fromJSON","build","_buildFileMap","hasteMap","changedFiles","size","removedFiles","_buildHasteMap","_persist","hasteFS","files","moduleMap","duplicates","mocks","__hasteMapForTest","process","env","NODE_ENV","_watch","read","readFileSync","_createEmptyMap","readModuleMap","_crawl","_processFile","filePath","workerOptions","setModule","id","module","platform","PATH","GENERIC_PLATFORM","existingModule","method","keys","length","delete","dupsByPlatform","Map","dups","TYPE","relativeFilePath","fileMetadata","moduleMetadata","ID","SHA1","workerReply","metadata","VISITED","metadataId","metadataModule","DEPENDENCIES","dependencies","DEPENDENCY_DELIM","sha1","workerError","error","stack","includes","code","_getWorker","getSha1","then","test","mockPath","existingMockPath","secondMockPath","moduleId","modulesByPlatform","worker","filesToProcess","_recoverDuplicates","promises","endsWith","resolve","promise","push","Promise","all","_cleanup","end","writeFileSync","forceInBand","Worker","exposedMethods","maxRetries","numWorkers","ignore","_ignore","bind","crawl","crawlerOptions","retry","warn","catch","e","Watcher","isSupported","changeQueue","eventsQueue","mustCopy","createWatcher","watcher","dot","glob","extension","ignored","reject","rejectTimeout","setTimeout","once","clearTimeout","on","onChange","emitChange","changeEvent","emit","type","stat","isDirectory","some","MTIME","mtime","getTime","find","event","clocks","add","moduleName","copy","mockName","_changeInterval","setInterval","watchers","copyMap","uniqueModule","entries","next","dedupMap","clearInterval","close","ignoreMatched","mockPath1","mockPath2","object","assign","input"],"sources":["/Users/lincolnkushwah/Desktop/All/React Projects/house_joy_new/node_modules/jest-haste-map/build/index.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.DuplicateError = void 0;\nObject.defineProperty(exports, 'ModuleMap', {\n  enumerable: true,\n  get: function () {\n    return _ModuleMap.default;\n  }\n});\nexports.default = void 0;\n\nfunction _child_process() {\n  const data = require('child_process');\n\n  _child_process = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _crypto() {\n  const data = require('crypto');\n\n  _crypto = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _events() {\n  const data = require('events');\n\n  _events = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _os() {\n  const data = require('os');\n\n  _os = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction path() {\n  const data = _interopRequireWildcard(require('path'));\n\n  path = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestRegexUtil() {\n  const data = require('jest-regex-util');\n\n  _jestRegexUtil = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestSerializer() {\n  const data = _interopRequireDefault(require('jest-serializer'));\n\n  _jestSerializer = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestWorker() {\n  const data = require('jest-worker');\n\n  _jestWorker = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _HasteFS = _interopRequireDefault(require('./HasteFS'));\n\nvar _ModuleMap = _interopRequireDefault(require('./ModuleMap'));\n\nvar _constants = _interopRequireDefault(require('./constants'));\n\nvar _node = _interopRequireDefault(require('./crawlers/node'));\n\nvar _watchman = _interopRequireDefault(require('./crawlers/watchman'));\n\nvar _getMockName = _interopRequireDefault(require('./getMockName'));\n\nvar fastPath = _interopRequireWildcard(require('./lib/fast_path'));\n\nvar _getPlatformExtension = _interopRequireDefault(\n  require('./lib/getPlatformExtension')\n);\n\nvar _normalizePathSep = _interopRequireDefault(\n  require('./lib/normalizePathSep')\n);\n\nvar _FSEventsWatcher = _interopRequireDefault(\n  require('./watchers/FSEventsWatcher')\n);\n\nvar _NodeWatcher = _interopRequireDefault(require('./watchers/NodeWatcher'));\n\nvar _WatchmanWatcher = _interopRequireDefault(\n  require('./watchers/WatchmanWatcher')\n);\n\nvar _worker = require('./worker');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== 'function') return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {\n    return {default: obj};\n  }\n  var cache = _getRequireWildcardCache(nodeInterop);\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor =\n    Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (key !== 'default' && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor\n        ? Object.getOwnPropertyDescriptor(obj, key)\n        : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\n// TypeScript doesn't like us importing from outside `rootDir`, but it doesn't\n// understand `require`.\nconst {version: VERSION} = require('../package.json');\n\nconst CHANGE_INTERVAL = 30;\nconst MAX_WAIT_TIME = 240000;\nconst NODE_MODULES = path().sep + 'node_modules' + path().sep;\nconst PACKAGE_JSON = path().sep + 'package.json';\nconst VCS_DIRECTORIES = ['.git', '.hg']\n  .map(vcs =>\n    (0, _jestRegexUtil().escapePathForRegex)(path().sep + vcs + path().sep)\n  )\n  .join('|');\n\nconst canUseWatchman = (() => {\n  try {\n    (0, _child_process().execSync)('watchman --version', {\n      stdio: ['ignore']\n    });\n    return true;\n  } catch {}\n\n  return false;\n})();\n\nfunction invariant(condition, message) {\n  if (!condition) {\n    throw new Error(message);\n  }\n}\n/**\n * HasteMap is a JavaScript implementation of Facebook's haste module system.\n *\n * This implementation is inspired by https://github.com/facebook/node-haste\n * and was built with for high-performance in large code repositories with\n * hundreds of thousands of files. This implementation is scalable and provides\n * predictable performance.\n *\n * Because the haste map creation and synchronization is critical to startup\n * performance and most tasks are blocked by I/O this class makes heavy use of\n * synchronous operations. It uses worker processes for parallelizing file\n * access and metadata extraction.\n *\n * The data structures created by `jest-haste-map` can be used directly from the\n * cache without further processing. The metadata objects in the `files` and\n * `map` objects contain cross-references: a metadata object from one can look\n * up the corresponding metadata object in the other map. Note that in most\n * projects, the number of files will be greater than the number of haste\n * modules one module can refer to many files based on platform extensions.\n *\n * type HasteMap = {\n *   clocks: WatchmanClocks,\n *   files: {[filepath: string]: FileMetaData},\n *   map: {[id: string]: ModuleMapItem},\n *   mocks: {[id: string]: string},\n * }\n *\n * // Watchman clocks are used for query synchronization and file system deltas.\n * type WatchmanClocks = {[filepath: string]: string};\n *\n * type FileMetaData = {\n *   id: ?string, // used to look up module metadata objects in `map`.\n *   mtime: number, // check for outdated files.\n *   size: number, // size of the file in bytes.\n *   visited: boolean, // whether the file has been parsed or not.\n *   dependencies: Array<string>, // all relative dependencies of this file.\n *   sha1: ?string, // SHA-1 of the file, if requested via options.\n * };\n *\n * // Modules can be targeted to a specific platform based on the file name.\n * // Example: platform.ios.js and Platform.android.js will both map to the same\n * // `Platform` module. The platform should be specified during resolution.\n * type ModuleMapItem = {[platform: string]: ModuleMetaData};\n *\n * //\n * type ModuleMetaData = {\n *   path: string, // the path to look up the file object in `files`.\n *   type: string, // the module type (either `package` or `module`).\n * };\n *\n * Note that the data structures described above are conceptual only. The actual\n * implementation uses arrays and constant keys for metadata storage. Instead of\n * `{id: 'flatMap', mtime: 3421, size: 42, visited: true, dependencies: []}` the real\n * representation is similar to `['flatMap', 3421, 42, 1, []]` to save storage space\n * and reduce parse and write time of a big JSON blob.\n *\n * The HasteMap is created as follows:\n *  1. read data from the cache or create an empty structure.\n *\n *  2. crawl the file system.\n *     * empty cache: crawl the entire file system.\n *     * cache available:\n *       * if watchman is available: get file system delta changes.\n *       * if watchman is unavailable: crawl the entire file system.\n *     * build metadata objects for every file. This builds the `files` part of\n *       the `HasteMap`.\n *\n *  3. parse and extract metadata from changed files.\n *     * this is done in parallel over worker processes to improve performance.\n *     * the worst case is to parse all files.\n *     * the best case is no file system access and retrieving all data from\n *       the cache.\n *     * the average case is a small number of changed files.\n *\n *  4. serialize the new `HasteMap` in a cache file.\n *     Worker processes can directly access the cache through `HasteMap.read()`.\n *\n */\n\nclass HasteMap extends _events().EventEmitter {\n  static getStatic(config) {\n    if (config.haste.hasteMapModulePath) {\n      return require(config.haste.hasteMapModulePath);\n    }\n\n    return HasteMap;\n  }\n\n  static create(options) {\n    if (options.hasteMapModulePath) {\n      const CustomHasteMap = require(options.hasteMapModulePath);\n\n      return new CustomHasteMap(options);\n    }\n\n    return new HasteMap(options);\n  }\n\n  constructor(options) {\n    super();\n\n    _defineProperty(this, '_buildPromise', void 0);\n\n    _defineProperty(this, '_cachePath', void 0);\n\n    _defineProperty(this, '_changeInterval', void 0);\n\n    _defineProperty(this, '_console', void 0);\n\n    _defineProperty(this, '_options', void 0);\n\n    _defineProperty(this, '_watchers', void 0);\n\n    _defineProperty(this, '_worker', void 0);\n\n    this._options = {\n      cacheDirectory: options.cacheDirectory || (0, _os().tmpdir)(),\n      computeDependencies:\n        options.computeDependencies === undefined\n          ? true\n          : options.computeDependencies,\n      computeSha1: options.computeSha1 || false,\n      dependencyExtractor: options.dependencyExtractor || null,\n      enableSymlinks: options.enableSymlinks || false,\n      extensions: options.extensions,\n      forceNodeFilesystemAPI: !!options.forceNodeFilesystemAPI,\n      hasteImplModulePath: options.hasteImplModulePath,\n      maxWorkers: options.maxWorkers,\n      mocksPattern: options.mocksPattern\n        ? new RegExp(options.mocksPattern)\n        : null,\n      name: options.name,\n      platforms: options.platforms,\n      resetCache: options.resetCache,\n      retainAllFiles: options.retainAllFiles,\n      rootDir: options.rootDir,\n      roots: Array.from(new Set(options.roots)),\n      skipPackageJson: !!options.skipPackageJson,\n      throwOnModuleCollision: !!options.throwOnModuleCollision,\n      useWatchman: options.useWatchman == null ? true : options.useWatchman,\n      watch: !!options.watch\n    };\n    this._console = options.console || global.console;\n\n    if (options.ignorePattern) {\n      if (options.ignorePattern instanceof RegExp) {\n        this._options.ignorePattern = new RegExp(\n          options.ignorePattern.source.concat('|' + VCS_DIRECTORIES),\n          options.ignorePattern.flags\n        );\n      } else {\n        throw new Error(\n          'jest-haste-map: the `ignorePattern` option must be a RegExp'\n        );\n      }\n    } else {\n      this._options.ignorePattern = new RegExp(VCS_DIRECTORIES);\n    }\n\n    if (this._options.enableSymlinks && this._options.useWatchman) {\n      throw new Error(\n        'jest-haste-map: enableSymlinks config option was set, but ' +\n          'is incompatible with watchman.\\n' +\n          'Set either `enableSymlinks` to false or `useWatchman` to false.'\n      );\n    }\n\n    const rootDirHash = (0, _crypto().createHash)('md5')\n      .update(options.rootDir)\n      .digest('hex');\n    let hasteImplHash = '';\n    let dependencyExtractorHash = '';\n\n    if (options.hasteImplModulePath) {\n      const hasteImpl = require(options.hasteImplModulePath);\n\n      if (hasteImpl.getCacheKey) {\n        hasteImplHash = String(hasteImpl.getCacheKey());\n      }\n    }\n\n    if (options.dependencyExtractor) {\n      const dependencyExtractor = require(options.dependencyExtractor);\n\n      if (dependencyExtractor.getCacheKey) {\n        dependencyExtractorHash = String(dependencyExtractor.getCacheKey());\n      }\n    }\n\n    this._cachePath = HasteMap.getCacheFilePath(\n      this._options.cacheDirectory,\n      `haste-map-${this._options.name}-${rootDirHash}`,\n      VERSION,\n      this._options.name,\n      this._options.roots\n        .map(root => fastPath.relative(options.rootDir, root))\n        .join(':'),\n      this._options.extensions.join(':'),\n      this._options.platforms.join(':'),\n      this._options.computeSha1.toString(),\n      options.mocksPattern || '',\n      (options.ignorePattern || '').toString(),\n      hasteImplHash,\n      dependencyExtractorHash,\n      this._options.computeDependencies.toString()\n    );\n    this._buildPromise = null;\n    this._watchers = [];\n    this._worker = null;\n  }\n\n  static getCacheFilePath(tmpdir, name, ...extra) {\n    const hash = (0, _crypto().createHash)('md5').update(extra.join(''));\n    return path().join(\n      tmpdir,\n      name.replace(/\\W/g, '-') + '-' + hash.digest('hex')\n    );\n  }\n\n  static getModuleMapFromJSON(json) {\n    return _ModuleMap.default.fromJSON(json);\n  }\n\n  getCacheFilePath() {\n    return this._cachePath;\n  }\n\n  build() {\n    if (!this._buildPromise) {\n      this._buildPromise = (async () => {\n        const data = await this._buildFileMap(); // Persist when we don't know if files changed (changedFiles undefined)\n        // or when we know a file was changed or deleted.\n\n        let hasteMap;\n\n        if (\n          data.changedFiles === undefined ||\n          data.changedFiles.size > 0 ||\n          data.removedFiles.size > 0\n        ) {\n          hasteMap = await this._buildHasteMap(data);\n\n          this._persist(hasteMap);\n        } else {\n          hasteMap = data.hasteMap;\n        }\n\n        const rootDir = this._options.rootDir;\n        const hasteFS = new _HasteFS.default({\n          files: hasteMap.files,\n          rootDir\n        });\n        const moduleMap = new _ModuleMap.default({\n          duplicates: hasteMap.duplicates,\n          map: hasteMap.map,\n          mocks: hasteMap.mocks,\n          rootDir\n        });\n\n        const __hasteMapForTest =\n          (process.env.NODE_ENV === 'test' && hasteMap) || null;\n\n        await this._watch(hasteMap);\n        return {\n          __hasteMapForTest,\n          hasteFS,\n          moduleMap\n        };\n      })();\n    }\n\n    return this._buildPromise;\n  }\n  /**\n   * 1. read data from the cache or create an empty structure.\n   */\n\n  read() {\n    let hasteMap;\n\n    try {\n      hasteMap = _jestSerializer().default.readFileSync(this._cachePath);\n    } catch {\n      hasteMap = this._createEmptyMap();\n    }\n\n    return hasteMap;\n  }\n\n  readModuleMap() {\n    const data = this.read();\n    return new _ModuleMap.default({\n      duplicates: data.duplicates,\n      map: data.map,\n      mocks: data.mocks,\n      rootDir: this._options.rootDir\n    });\n  }\n  /**\n   * 2. crawl the file system.\n   */\n\n  async _buildFileMap() {\n    let hasteMap;\n\n    try {\n      const read = this._options.resetCache ? this._createEmptyMap : this.read;\n      hasteMap = await read.call(this);\n    } catch {\n      hasteMap = this._createEmptyMap();\n    }\n\n    return this._crawl(hasteMap);\n  }\n  /**\n   * 3. parse and extract metadata from changed files.\n   */\n\n  _processFile(hasteMap, map, mocks, filePath, workerOptions) {\n    const rootDir = this._options.rootDir;\n\n    const setModule = (id, module) => {\n      let moduleMap = map.get(id);\n\n      if (!moduleMap) {\n        moduleMap = Object.create(null);\n        map.set(id, moduleMap);\n      }\n\n      const platform =\n        (0, _getPlatformExtension.default)(\n          module[_constants.default.PATH],\n          this._options.platforms\n        ) || _constants.default.GENERIC_PLATFORM;\n\n      const existingModule = moduleMap[platform];\n\n      if (\n        existingModule &&\n        existingModule[_constants.default.PATH] !==\n          module[_constants.default.PATH]\n      ) {\n        const method = this._options.throwOnModuleCollision ? 'error' : 'warn';\n\n        this._console[method](\n          [\n            'jest-haste-map: Haste module naming collision: ' + id,\n            '  The following files share their name; please adjust your hasteImpl:',\n            '    * <rootDir>' +\n              path().sep +\n              existingModule[_constants.default.PATH],\n            '    * <rootDir>' + path().sep + module[_constants.default.PATH],\n            ''\n          ].join('\\n')\n        );\n\n        if (this._options.throwOnModuleCollision) {\n          throw new DuplicateError(\n            existingModule[_constants.default.PATH],\n            module[_constants.default.PATH]\n          );\n        } // We do NOT want consumers to use a module that is ambiguous.\n\n        delete moduleMap[platform];\n\n        if (Object.keys(moduleMap).length === 1) {\n          map.delete(id);\n        }\n\n        let dupsByPlatform = hasteMap.duplicates.get(id);\n\n        if (dupsByPlatform == null) {\n          dupsByPlatform = new Map();\n          hasteMap.duplicates.set(id, dupsByPlatform);\n        }\n\n        const dups = new Map([\n          [module[_constants.default.PATH], module[_constants.default.TYPE]],\n          [\n            existingModule[_constants.default.PATH],\n            existingModule[_constants.default.TYPE]\n          ]\n        ]);\n        dupsByPlatform.set(platform, dups);\n        return;\n      }\n\n      const dupsByPlatform = hasteMap.duplicates.get(id);\n\n      if (dupsByPlatform != null) {\n        const dups = dupsByPlatform.get(platform);\n\n        if (dups != null) {\n          dups.set(\n            module[_constants.default.PATH],\n            module[_constants.default.TYPE]\n          );\n        }\n\n        return;\n      }\n\n      moduleMap[platform] = module;\n    };\n\n    const relativeFilePath = fastPath.relative(rootDir, filePath);\n    const fileMetadata = hasteMap.files.get(relativeFilePath);\n\n    if (!fileMetadata) {\n      throw new Error(\n        'jest-haste-map: File to process was not found in the haste map.'\n      );\n    }\n\n    const moduleMetadata = hasteMap.map.get(\n      fileMetadata[_constants.default.ID]\n    );\n    const computeSha1 =\n      this._options.computeSha1 && !fileMetadata[_constants.default.SHA1]; // Callback called when the response from the worker is successful.\n\n    const workerReply = metadata => {\n      // `1` for truthy values instead of `true` to save cache space.\n      fileMetadata[_constants.default.VISITED] = 1;\n      const metadataId = metadata.id;\n      const metadataModule = metadata.module;\n\n      if (metadataId && metadataModule) {\n        fileMetadata[_constants.default.ID] = metadataId;\n        setModule(metadataId, metadataModule);\n      }\n\n      fileMetadata[_constants.default.DEPENDENCIES] = metadata.dependencies\n        ? metadata.dependencies.join(_constants.default.DEPENDENCY_DELIM)\n        : '';\n\n      if (computeSha1) {\n        fileMetadata[_constants.default.SHA1] = metadata.sha1;\n      }\n    }; // Callback called when the response from the worker is an error.\n\n    const workerError = error => {\n      if (typeof error !== 'object' || !error.message || !error.stack) {\n        error = new Error(error);\n        error.stack = ''; // Remove stack for stack-less errors.\n      }\n\n      if (!['ENOENT', 'EACCES'].includes(error.code)) {\n        throw error;\n      } // If a file cannot be read we remove it from the file list and\n      // ignore the failure silently.\n\n      hasteMap.files.delete(relativeFilePath);\n    }; // If we retain all files in the virtual HasteFS representation, we avoid\n    // reading them if they aren't important (node_modules).\n\n    if (this._options.retainAllFiles && filePath.includes(NODE_MODULES)) {\n      if (computeSha1) {\n        return this._getWorker(workerOptions)\n          .getSha1({\n            computeDependencies: this._options.computeDependencies,\n            computeSha1,\n            dependencyExtractor: this._options.dependencyExtractor,\n            filePath,\n            hasteImplModulePath: this._options.hasteImplModulePath,\n            rootDir\n          })\n          .then(workerReply, workerError);\n      }\n\n      return null;\n    }\n\n    if (\n      this._options.mocksPattern &&\n      this._options.mocksPattern.test(filePath)\n    ) {\n      const mockPath = (0, _getMockName.default)(filePath);\n      const existingMockPath = mocks.get(mockPath);\n\n      if (existingMockPath) {\n        const secondMockPath = fastPath.relative(rootDir, filePath);\n\n        if (existingMockPath !== secondMockPath) {\n          const method = this._options.throwOnModuleCollision\n            ? 'error'\n            : 'warn';\n\n          this._console[method](\n            [\n              'jest-haste-map: duplicate manual mock found: ' + mockPath,\n              '  The following files share their name; please delete one of them:',\n              '    * <rootDir>' + path().sep + existingMockPath,\n              '    * <rootDir>' + path().sep + secondMockPath,\n              ''\n            ].join('\\n')\n          );\n\n          if (this._options.throwOnModuleCollision) {\n            throw new DuplicateError(existingMockPath, secondMockPath);\n          }\n        }\n      }\n\n      mocks.set(mockPath, relativeFilePath);\n    }\n\n    if (fileMetadata[_constants.default.VISITED]) {\n      if (!fileMetadata[_constants.default.ID]) {\n        return null;\n      }\n\n      if (moduleMetadata != null) {\n        const platform =\n          (0, _getPlatformExtension.default)(\n            filePath,\n            this._options.platforms\n          ) || _constants.default.GENERIC_PLATFORM;\n\n        const module = moduleMetadata[platform];\n\n        if (module == null) {\n          return null;\n        }\n\n        const moduleId = fileMetadata[_constants.default.ID];\n        let modulesByPlatform = map.get(moduleId);\n\n        if (!modulesByPlatform) {\n          modulesByPlatform = Object.create(null);\n          map.set(moduleId, modulesByPlatform);\n        }\n\n        modulesByPlatform[platform] = module;\n        return null;\n      }\n    }\n\n    return this._getWorker(workerOptions)\n      .worker({\n        computeDependencies: this._options.computeDependencies,\n        computeSha1,\n        dependencyExtractor: this._options.dependencyExtractor,\n        filePath,\n        hasteImplModulePath: this._options.hasteImplModulePath,\n        rootDir\n      })\n      .then(workerReply, workerError);\n  }\n\n  _buildHasteMap(data) {\n    const {removedFiles, changedFiles, hasteMap} = data; // If any files were removed or we did not track what files changed, process\n    // every file looking for changes. Otherwise, process only changed files.\n\n    let map;\n    let mocks;\n    let filesToProcess;\n\n    if (changedFiles === undefined || removedFiles.size) {\n      map = new Map();\n      mocks = new Map();\n      filesToProcess = hasteMap.files;\n    } else {\n      map = hasteMap.map;\n      mocks = hasteMap.mocks;\n      filesToProcess = changedFiles;\n    }\n\n    for (const [relativeFilePath, fileMetadata] of removedFiles) {\n      this._recoverDuplicates(\n        hasteMap,\n        relativeFilePath,\n        fileMetadata[_constants.default.ID]\n      );\n    }\n\n    const promises = [];\n\n    for (const relativeFilePath of filesToProcess.keys()) {\n      if (\n        this._options.skipPackageJson &&\n        relativeFilePath.endsWith(PACKAGE_JSON)\n      ) {\n        continue;\n      } // SHA-1, if requested, should already be present thanks to the crawler.\n\n      const filePath = fastPath.resolve(\n        this._options.rootDir,\n        relativeFilePath\n      );\n\n      const promise = this._processFile(hasteMap, map, mocks, filePath);\n\n      if (promise) {\n        promises.push(promise);\n      }\n    }\n\n    return Promise.all(promises).then(\n      () => {\n        this._cleanup();\n\n        hasteMap.map = map;\n        hasteMap.mocks = mocks;\n        return hasteMap;\n      },\n      error => {\n        this._cleanup();\n\n        throw error;\n      }\n    );\n  }\n\n  _cleanup() {\n    const worker = this._worker; // @ts-expect-error\n\n    if (worker && typeof worker.end === 'function') {\n      // @ts-expect-error\n      worker.end();\n    }\n\n    this._worker = null;\n  }\n  /**\n   * 4. serialize the new `HasteMap` in a cache file.\n   */\n\n  _persist(hasteMap) {\n    _jestSerializer().default.writeFileSync(this._cachePath, hasteMap);\n  }\n  /**\n   * Creates workers or parses files and extracts metadata in-process.\n   */\n\n  _getWorker(options) {\n    if (!this._worker) {\n      if ((options && options.forceInBand) || this._options.maxWorkers <= 1) {\n        this._worker = {\n          getSha1: _worker.getSha1,\n          worker: _worker.worker\n        };\n      } else {\n        // @ts-expect-error: assignment of a worker with custom properties.\n        this._worker = new (_jestWorker().Worker)(require.resolve('./worker'), {\n          exposedMethods: ['getSha1', 'worker'],\n          maxRetries: 3,\n          numWorkers: this._options.maxWorkers\n        });\n      }\n    }\n\n    return this._worker;\n  }\n\n  _crawl(hasteMap) {\n    const options = this._options;\n\n    const ignore = this._ignore.bind(this);\n\n    const crawl =\n      canUseWatchman && this._options.useWatchman\n        ? _watchman.default\n        : _node.default;\n    const crawlerOptions = {\n      computeSha1: options.computeSha1,\n      data: hasteMap,\n      enableSymlinks: options.enableSymlinks,\n      extensions: options.extensions,\n      forceNodeFilesystemAPI: options.forceNodeFilesystemAPI,\n      ignore,\n      rootDir: options.rootDir,\n      roots: options.roots\n    };\n\n    const retry = error => {\n      if (crawl === _watchman.default) {\n        this._console.warn(\n          'jest-haste-map: Watchman crawl failed. Retrying once with node ' +\n            'crawler.\\n' +\n            \"  Usually this happens when watchman isn't running. Create an \" +\n            \"empty `.watchmanconfig` file in your project's root folder or \" +\n            'initialize a git or hg repository in your project.\\n' +\n            '  ' +\n            error\n        );\n\n        return (0, _node.default)(crawlerOptions).catch(e => {\n          throw new Error(\n            'Crawler retry failed:\\n' +\n              `  Original error: ${error.message}\\n` +\n              `  Retry error: ${e.message}\\n`\n          );\n        });\n      }\n\n      throw error;\n    };\n\n    try {\n      return crawl(crawlerOptions).catch(retry);\n    } catch (error) {\n      return retry(error);\n    }\n  }\n  /**\n   * Watch mode\n   */\n\n  _watch(hasteMap) {\n    if (!this._options.watch) {\n      return Promise.resolve();\n    } // In watch mode, we'll only warn about module collisions and we'll retain\n    // all files, even changes to node_modules.\n\n    this._options.throwOnModuleCollision = false;\n    this._options.retainAllFiles = true; // WatchmanWatcher > FSEventsWatcher > sane.NodeWatcher\n\n    const Watcher =\n      canUseWatchman && this._options.useWatchman\n        ? _WatchmanWatcher.default\n        : _FSEventsWatcher.default.isSupported()\n        ? _FSEventsWatcher.default\n        : _NodeWatcher.default;\n    const extensions = this._options.extensions;\n    const ignorePattern = this._options.ignorePattern;\n    const rootDir = this._options.rootDir;\n    let changeQueue = Promise.resolve();\n    let eventsQueue = []; // We only need to copy the entire haste map once on every \"frame\".\n\n    let mustCopy = true;\n\n    const createWatcher = root => {\n      const watcher = new Watcher(root, {\n        dot: true,\n        glob: extensions.map(extension => '**/*.' + extension),\n        ignored: ignorePattern\n      });\n      return new Promise((resolve, reject) => {\n        const rejectTimeout = setTimeout(\n          () => reject(new Error('Failed to start watch mode.')),\n          MAX_WAIT_TIME\n        );\n        watcher.once('ready', () => {\n          clearTimeout(rejectTimeout);\n          watcher.on('all', onChange);\n          resolve(watcher);\n        });\n      });\n    };\n\n    const emitChange = () => {\n      if (eventsQueue.length) {\n        mustCopy = true;\n        const changeEvent = {\n          eventsQueue,\n          hasteFS: new _HasteFS.default({\n            files: hasteMap.files,\n            rootDir\n          }),\n          moduleMap: new _ModuleMap.default({\n            duplicates: hasteMap.duplicates,\n            map: hasteMap.map,\n            mocks: hasteMap.mocks,\n            rootDir\n          })\n        };\n        this.emit('change', changeEvent);\n        eventsQueue = [];\n      }\n    };\n\n    const onChange = (type, filePath, root, stat) => {\n      filePath = path().join(root, (0, _normalizePathSep.default)(filePath));\n\n      if (\n        (stat && stat.isDirectory()) ||\n        this._ignore(filePath) ||\n        !extensions.some(extension => filePath.endsWith(extension))\n      ) {\n        return;\n      }\n\n      const relativeFilePath = fastPath.relative(rootDir, filePath);\n      const fileMetadata = hasteMap.files.get(relativeFilePath); // The file has been accessed, not modified\n\n      if (\n        type === 'change' &&\n        fileMetadata &&\n        stat &&\n        fileMetadata[_constants.default.MTIME] === stat.mtime.getTime()\n      ) {\n        return;\n      }\n\n      changeQueue = changeQueue\n        .then(() => {\n          // If we get duplicate events for the same file, ignore them.\n          if (\n            eventsQueue.find(\n              event =>\n                event.type === type &&\n                event.filePath === filePath &&\n                ((!event.stat && !stat) ||\n                  (!!event.stat &&\n                    !!stat &&\n                    event.stat.mtime.getTime() === stat.mtime.getTime()))\n            )\n          ) {\n            return null;\n          }\n\n          if (mustCopy) {\n            mustCopy = false;\n            hasteMap = {\n              clocks: new Map(hasteMap.clocks),\n              duplicates: new Map(hasteMap.duplicates),\n              files: new Map(hasteMap.files),\n              map: new Map(hasteMap.map),\n              mocks: new Map(hasteMap.mocks)\n            };\n          }\n\n          const add = () => {\n            eventsQueue.push({\n              filePath,\n              stat,\n              type\n            });\n            return null;\n          };\n\n          const fileMetadata = hasteMap.files.get(relativeFilePath); // If it's not an addition, delete the file and all its metadata\n\n          if (fileMetadata != null) {\n            const moduleName = fileMetadata[_constants.default.ID];\n\n            const platform =\n              (0, _getPlatformExtension.default)(\n                filePath,\n                this._options.platforms\n              ) || _constants.default.GENERIC_PLATFORM;\n\n            hasteMap.files.delete(relativeFilePath);\n            let moduleMap = hasteMap.map.get(moduleName);\n\n            if (moduleMap != null) {\n              // We are forced to copy the object because jest-haste-map exposes\n              // the map as an immutable entity.\n              moduleMap = copy(moduleMap);\n              delete moduleMap[platform];\n\n              if (Object.keys(moduleMap).length === 0) {\n                hasteMap.map.delete(moduleName);\n              } else {\n                hasteMap.map.set(moduleName, moduleMap);\n              }\n            }\n\n            if (\n              this._options.mocksPattern &&\n              this._options.mocksPattern.test(filePath)\n            ) {\n              const mockName = (0, _getMockName.default)(filePath);\n              hasteMap.mocks.delete(mockName);\n            }\n\n            this._recoverDuplicates(hasteMap, relativeFilePath, moduleName);\n          } // If the file was added or changed,\n          // parse it and update the haste map.\n\n          if (type === 'add' || type === 'change') {\n            invariant(\n              stat,\n              'since the file exists or changed, it should have stats'\n            );\n            const fileMetadata = [\n              '',\n              stat.mtime.getTime(),\n              stat.size,\n              0,\n              '',\n              null\n            ];\n            hasteMap.files.set(relativeFilePath, fileMetadata);\n\n            const promise = this._processFile(\n              hasteMap,\n              hasteMap.map,\n              hasteMap.mocks,\n              filePath,\n              {\n                forceInBand: true\n              }\n            ); // Cleanup\n\n            this._cleanup();\n\n            if (promise) {\n              return promise.then(add);\n            } else {\n              // If a file in node_modules has changed,\n              // emit an event regardless.\n              add();\n            }\n          } else {\n            add();\n          }\n\n          return null;\n        })\n        .catch(error => {\n          this._console.error(\n            `jest-haste-map: watch error:\\n  ${error.stack}\\n`\n          );\n        });\n    };\n\n    this._changeInterval = setInterval(emitChange, CHANGE_INTERVAL);\n    return Promise.all(this._options.roots.map(createWatcher)).then(\n      watchers => {\n        this._watchers = watchers;\n      }\n    );\n  }\n  /**\n   * This function should be called when the file under `filePath` is removed\n   * or changed. When that happens, we want to figure out if that file was\n   * part of a group of files that had the same ID. If it was, we want to\n   * remove it from the group. Furthermore, if there is only one file\n   * remaining in the group, then we want to restore that single file as the\n   * correct resolution for its ID, and cleanup the duplicates index.\n   */\n\n  _recoverDuplicates(hasteMap, relativeFilePath, moduleName) {\n    let dupsByPlatform = hasteMap.duplicates.get(moduleName);\n\n    if (dupsByPlatform == null) {\n      return;\n    }\n\n    const platform =\n      (0, _getPlatformExtension.default)(\n        relativeFilePath,\n        this._options.platforms\n      ) || _constants.default.GENERIC_PLATFORM;\n\n    let dups = dupsByPlatform.get(platform);\n\n    if (dups == null) {\n      return;\n    }\n\n    dupsByPlatform = copyMap(dupsByPlatform);\n    hasteMap.duplicates.set(moduleName, dupsByPlatform);\n    dups = copyMap(dups);\n    dupsByPlatform.set(platform, dups);\n    dups.delete(relativeFilePath);\n\n    if (dups.size !== 1) {\n      return;\n    }\n\n    const uniqueModule = dups.entries().next().value;\n\n    if (!uniqueModule) {\n      return;\n    }\n\n    let dedupMap = hasteMap.map.get(moduleName);\n\n    if (dedupMap == null) {\n      dedupMap = Object.create(null);\n      hasteMap.map.set(moduleName, dedupMap);\n    }\n\n    dedupMap[platform] = uniqueModule;\n    dupsByPlatform.delete(platform);\n\n    if (dupsByPlatform.size === 0) {\n      hasteMap.duplicates.delete(moduleName);\n    }\n  }\n\n  async end() {\n    if (this._changeInterval) {\n      clearInterval(this._changeInterval);\n    }\n\n    if (!this._watchers.length) {\n      return;\n    }\n\n    await Promise.all(this._watchers.map(watcher => watcher.close()));\n    this._watchers = [];\n  }\n  /**\n   * Helpers\n   */\n\n  _ignore(filePath) {\n    const ignorePattern = this._options.ignorePattern;\n    const ignoreMatched =\n      ignorePattern instanceof RegExp\n        ? ignorePattern.test(filePath)\n        : ignorePattern && ignorePattern(filePath);\n    return (\n      ignoreMatched ||\n      (!this._options.retainAllFiles && filePath.includes(NODE_MODULES))\n    );\n  }\n\n  _createEmptyMap() {\n    return {\n      clocks: new Map(),\n      duplicates: new Map(),\n      files: new Map(),\n      map: new Map(),\n      mocks: new Map()\n    };\n  }\n}\n\nexports.default = HasteMap;\n\n_defineProperty(HasteMap, 'H', _constants.default);\n\nclass DuplicateError extends Error {\n  constructor(mockPath1, mockPath2) {\n    super('Duplicated files or mocks. Please check the console for more info');\n\n    _defineProperty(this, 'mockPath1', void 0);\n\n    _defineProperty(this, 'mockPath2', void 0);\n\n    this.mockPath1 = mockPath1;\n    this.mockPath2 = mockPath2;\n  }\n}\n\nexports.DuplicateError = DuplicateError;\n\nfunction copy(object) {\n  return Object.assign(Object.create(null), object);\n}\n\nfunction copyMap(input) {\n  return new Map(input);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}