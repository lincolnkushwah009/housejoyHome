{"ast":null,"code":"/* -*- Mode: js; js-indent-level: 2; -*- */\n\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\n/**\n * This is a helper function for getting values from parameter/options\n * objects.\n *\n * @param args The object we are extracting values from\n * @param name The name of the property we are getting.\n * @param defaultValue An optional value to return if the property is missing\n * from the object. If this is not specified and the property is missing, an\n * error will be thrown.\n */\nfunction getArg(aArgs, aName, aDefaultValue) {\n  if (aName in aArgs) {\n    return aArgs[aName];\n  } else if (arguments.length === 3) {\n    return aDefaultValue;\n  }\n\n  throw new Error('\"' + aName + '\" is a required argument.');\n}\n\nexports.getArg = getArg;\nconst urlRegexp = /^(?:([\\w+\\-.]+):)?\\/\\/(?:(\\w+:\\w+)@)?([\\w.-]*)(?::(\\d+))?(.*)$/;\nconst dataUrlRegexp = /^data:.+\\,.+$/;\n\nfunction urlParse(aUrl) {\n  const match = aUrl.match(urlRegexp);\n\n  if (!match) {\n    return null;\n  }\n\n  return {\n    scheme: match[1],\n    auth: match[2],\n    host: match[3],\n    port: match[4],\n    path: match[5]\n  };\n}\n\nexports.urlParse = urlParse;\n\nfunction urlGenerate(aParsedUrl) {\n  let url = \"\";\n\n  if (aParsedUrl.scheme) {\n    url += aParsedUrl.scheme + \":\";\n  }\n\n  url += \"//\";\n\n  if (aParsedUrl.auth) {\n    url += aParsedUrl.auth + \"@\";\n  }\n\n  if (aParsedUrl.host) {\n    url += aParsedUrl.host;\n  }\n\n  if (aParsedUrl.port) {\n    url += \":\" + aParsedUrl.port;\n  }\n\n  if (aParsedUrl.path) {\n    url += aParsedUrl.path;\n  }\n\n  return url;\n}\n\nexports.urlGenerate = urlGenerate;\nconst MAX_CACHED_INPUTS = 32;\n/**\n * Takes some function `f(input) -> result` and returns a memoized version of\n * `f`.\n *\n * We keep at most `MAX_CACHED_INPUTS` memoized results of `f` alive. The\n * memoization is a dumb-simple, linear least-recently-used cache.\n */\n\nfunction lruMemoize(f) {\n  const cache = [];\n  return function (input) {\n    for (let i = 0; i < cache.length; i++) {\n      if (cache[i].input === input) {\n        const temp = cache[0];\n        cache[0] = cache[i];\n        cache[i] = temp;\n        return cache[0].result;\n      }\n    }\n\n    const result = f(input);\n    cache.unshift({\n      input,\n      result\n    });\n\n    if (cache.length > MAX_CACHED_INPUTS) {\n      cache.pop();\n    }\n\n    return result;\n  };\n}\n/**\n * Normalizes a path, or the path portion of a URL:\n *\n * - Replaces consecutive slashes with one slash.\n * - Removes unnecessary '.' parts.\n * - Removes unnecessary '<dir>/..' parts.\n *\n * Based on code in the Node.js 'path' core module.\n *\n * @param aPath The path or url to normalize.\n */\n\n\nconst normalize = lruMemoize(function normalize(aPath) {\n  let path = aPath;\n  const url = urlParse(aPath);\n\n  if (url) {\n    if (!url.path) {\n      return aPath;\n    }\n\n    path = url.path;\n  }\n\n  const isAbsolute = exports.isAbsolute(path); // Split the path into parts between `/` characters. This is much faster than\n  // using `.split(/\\/+/g)`.\n\n  const parts = [];\n  let start = 0;\n  let i = 0;\n\n  while (true) {\n    start = i;\n    i = path.indexOf(\"/\", start);\n\n    if (i === -1) {\n      parts.push(path.slice(start));\n      break;\n    } else {\n      parts.push(path.slice(start, i));\n\n      while (i < path.length && path[i] === \"/\") {\n        i++;\n      }\n    }\n  }\n\n  let up = 0;\n\n  for (i = parts.length - 1; i >= 0; i--) {\n    const part = parts[i];\n\n    if (part === \".\") {\n      parts.splice(i, 1);\n    } else if (part === \"..\") {\n      up++;\n    } else if (up > 0) {\n      if (part === \"\") {\n        // The first part is blank if the path is absolute. Trying to go\n        // above the root is a no-op. Therefore we can remove all '..' parts\n        // directly after the root.\n        parts.splice(i + 1, up);\n        up = 0;\n      } else {\n        parts.splice(i, 2);\n        up--;\n      }\n    }\n  }\n\n  path = parts.join(\"/\");\n\n  if (path === \"\") {\n    path = isAbsolute ? \"/\" : \".\";\n  }\n\n  if (url) {\n    url.path = path;\n    return urlGenerate(url);\n  }\n\n  return path;\n});\nexports.normalize = normalize;\n/**\n * Joins two paths/URLs.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be joined with the root.\n *\n * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a\n *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended\n *   first.\n * - Otherwise aPath is a path. If aRoot is a URL, then its path portion\n *   is updated with the result and aRoot is returned. Otherwise the result\n *   is returned.\n *   - If aPath is absolute, the result is aPath.\n *   - Otherwise the two paths are joined with a slash.\n * - Joining for example 'http://' and 'www.example.com' is also supported.\n */\n\nfunction join(aRoot, aPath) {\n  if (aRoot === \"\") {\n    aRoot = \".\";\n  }\n\n  if (aPath === \"\") {\n    aPath = \".\";\n  }\n\n  const aPathUrl = urlParse(aPath);\n  const aRootUrl = urlParse(aRoot);\n\n  if (aRootUrl) {\n    aRoot = aRootUrl.path || \"/\";\n  } // `join(foo, '//www.example.org')`\n\n\n  if (aPathUrl && !aPathUrl.scheme) {\n    if (aRootUrl) {\n      aPathUrl.scheme = aRootUrl.scheme;\n    }\n\n    return urlGenerate(aPathUrl);\n  }\n\n  if (aPathUrl || aPath.match(dataUrlRegexp)) {\n    return aPath;\n  } // `join('http://', 'www.example.com')`\n\n\n  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {\n    aRootUrl.host = aPath;\n    return urlGenerate(aRootUrl);\n  }\n\n  const joined = aPath.charAt(0) === \"/\" ? aPath : normalize(aRoot.replace(/\\/+$/, \"\") + \"/\" + aPath);\n\n  if (aRootUrl) {\n    aRootUrl.path = joined;\n    return urlGenerate(aRootUrl);\n  }\n\n  return joined;\n}\n\nexports.join = join;\n\nexports.isAbsolute = function (aPath) {\n  return aPath.charAt(0) === \"/\" || urlRegexp.test(aPath);\n};\n/**\n * Make a path relative to a URL or another path.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be made relative to aRoot.\n */\n\n\nfunction relative(aRoot, aPath) {\n  if (aRoot === \"\") {\n    aRoot = \".\";\n  }\n\n  aRoot = aRoot.replace(/\\/$/, \"\"); // It is possible for the path to be above the root. In this case, simply\n  // checking whether the root is a prefix of the path won't work. Instead, we\n  // need to remove components from the root one by one, until either we find\n  // a prefix that fits, or we run out of components to remove.\n\n  let level = 0;\n\n  while (aPath.indexOf(aRoot + \"/\") !== 0) {\n    const index = aRoot.lastIndexOf(\"/\");\n\n    if (index < 0) {\n      return aPath;\n    } // If the only part of the root that is left is the scheme (i.e. http://,\n    // file:///, etc.), one or more slashes (/), or simply nothing at all, we\n    // have exhausted all components, so the path is not relative to the root.\n\n\n    aRoot = aRoot.slice(0, index);\n\n    if (aRoot.match(/^([^\\/]+:\\/)?\\/*$/)) {\n      return aPath;\n    }\n\n    ++level;\n  } // Make sure we add a \"../\" for each component we removed from the root.\n\n\n  return Array(level + 1).join(\"../\") + aPath.substr(aRoot.length + 1);\n}\n\nexports.relative = relative;\n\nconst supportsNullProto = function () {\n  const obj = Object.create(null);\n  return !(\"__proto__\" in obj);\n}();\n\nfunction identity(s) {\n  return s;\n}\n/**\n * Because behavior goes wacky when you set `__proto__` on objects, we\n * have to prefix all the strings in our set with an arbitrary character.\n *\n * See https://github.com/mozilla/source-map/pull/31 and\n * https://github.com/mozilla/source-map/issues/30\n *\n * @param String aStr\n */\n\n\nfunction toSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return \"$\" + aStr;\n  }\n\n  return aStr;\n}\n\nexports.toSetString = supportsNullProto ? identity : toSetString;\n\nfunction fromSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return aStr.slice(1);\n  }\n\n  return aStr;\n}\n\nexports.fromSetString = supportsNullProto ? identity : fromSetString;\n\nfunction isProtoString(s) {\n  if (!s) {\n    return false;\n  }\n\n  const length = s.length;\n\n  if (length < 9\n  /* \"__proto__\".length */\n  ) {\n    return false;\n  }\n  /* eslint-disable no-multi-spaces */\n\n\n  if (s.charCodeAt(length - 1) !== 95\n  /* '_' */\n  || s.charCodeAt(length - 2) !== 95\n  /* '_' */\n  || s.charCodeAt(length - 3) !== 111\n  /* 'o' */\n  || s.charCodeAt(length - 4) !== 116\n  /* 't' */\n  || s.charCodeAt(length - 5) !== 111\n  /* 'o' */\n  || s.charCodeAt(length - 6) !== 114\n  /* 'r' */\n  || s.charCodeAt(length - 7) !== 112\n  /* 'p' */\n  || s.charCodeAt(length - 8) !== 95\n  /* '_' */\n  || s.charCodeAt(length - 9) !== 95\n  /* '_' */\n  ) {\n    return false;\n  }\n  /* eslint-enable no-multi-spaces */\n\n\n  for (let i = length - 10; i >= 0; i--) {\n    if (s.charCodeAt(i) !== 36\n    /* '$' */\n    ) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\n * Comparator between two mappings where the original positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same original source/line/column, but different generated\n * line and column the same. Useful when searching for a mapping with a\n * stubbed out mapping.\n */\n\n\nfunction compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {\n  let cmp = strcmp(mappingA.source, mappingB.source);\n\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n\n  if (cmp !== 0 || onlyCompareOriginal) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedLine - mappingB.generatedLine;\n\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\n\nexports.compareByOriginalPositions = compareByOriginalPositions;\n/**\n * Comparator between two mappings with deflated source and name indices where\n * the generated positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same generated line and column, but different\n * source/name/original line and column the same. Useful when searching for a\n * mapping with a stubbed out mapping.\n */\n\nfunction compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {\n  let cmp = mappingA.generatedLine - mappingB.generatedLine;\n\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n\n  if (cmp !== 0 || onlyCompareGenerated) {\n    return cmp;\n  }\n\n  cmp = strcmp(mappingA.source, mappingB.source);\n\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\n\nexports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;\n\nfunction strcmp(aStr1, aStr2) {\n  if (aStr1 === aStr2) {\n    return 0;\n  }\n\n  if (aStr1 === null) {\n    return 1; // aStr2 !== null\n  }\n\n  if (aStr2 === null) {\n    return -1; // aStr1 !== null\n  }\n\n  if (aStr1 > aStr2) {\n    return 1;\n  }\n\n  return -1;\n}\n/**\n * Comparator between two mappings with inflated source and name strings where\n * the generated positions are compared.\n */\n\n\nfunction compareByGeneratedPositionsInflated(mappingA, mappingB) {\n  let cmp = mappingA.generatedLine - mappingB.generatedLine;\n\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = strcmp(mappingA.source, mappingB.source);\n\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\n\nexports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;\n/**\n * Strip any JSON XSSI avoidance prefix from the string (as documented\n * in the source maps specification), and then parse the string as\n * JSON.\n */\n\nfunction parseSourceMapInput(str) {\n  return JSON.parse(str.replace(/^\\)]}'[^\\n]*\\n/, \"\"));\n}\n\nexports.parseSourceMapInput = parseSourceMapInput;\n/**\n * Compute the URL of a source given the the source root, the source's\n * URL, and the source map's URL.\n */\n\nfunction computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {\n  sourceURL = sourceURL || \"\";\n\n  if (sourceRoot) {\n    // This follows what Chrome does.\n    if (sourceRoot[sourceRoot.length - 1] !== \"/\" && sourceURL[0] !== \"/\") {\n      sourceRoot += \"/\";\n    } // The spec says:\n    //   Line 4: An optional source root, useful for relocating source\n    //   files on a server or removing repeated values in the\n    //   “sources” entry.  This value is prepended to the individual\n    //   entries in the “source” field.\n\n\n    sourceURL = sourceRoot + sourceURL;\n  } // Historically, SourceMapConsumer did not take the sourceMapURL as\n  // a parameter.  This mode is still somewhat supported, which is why\n  // this code block is conditional.  However, it's preferable to pass\n  // the source map URL to SourceMapConsumer, so that this function\n  // can implement the source URL resolution algorithm as outlined in\n  // the spec.  This block is basically the equivalent of:\n  //    new URL(sourceURL, sourceMapURL).toString()\n  // ... except it avoids using URL, which wasn't available in the\n  // older releases of node still supported by this library.\n  //\n  // The spec says:\n  //   If the sources are not absolute URLs after prepending of the\n  //   “sourceRoot”, the sources are resolved relative to the\n  //   SourceMap (like resolving script src in a html document).\n\n\n  if (sourceMapURL) {\n    const parsed = urlParse(sourceMapURL);\n\n    if (!parsed) {\n      throw new Error(\"sourceMapURL could not be parsed\");\n    }\n\n    if (parsed.path) {\n      // Strip the last path component, but keep the \"/\".\n      const index = parsed.path.lastIndexOf(\"/\");\n\n      if (index >= 0) {\n        parsed.path = parsed.path.substring(0, index + 1);\n      }\n    }\n\n    sourceURL = join(urlGenerate(parsed), sourceURL);\n  }\n\n  return normalize(sourceURL);\n}\n\nexports.computeSourceURL = computeSourceURL;","map":{"version":3,"names":["getArg","aArgs","aName","aDefaultValue","arguments","length","Error","exports","urlRegexp","dataUrlRegexp","urlParse","aUrl","match","scheme","auth","host","port","path","urlGenerate","aParsedUrl","url","MAX_CACHED_INPUTS","lruMemoize","f","cache","input","i","temp","result","unshift","pop","normalize","aPath","isAbsolute","parts","start","indexOf","push","slice","up","part","splice","join","aRoot","aPathUrl","aRootUrl","joined","charAt","replace","test","relative","level","index","lastIndexOf","Array","substr","supportsNullProto","obj","Object","create","identity","s","toSetString","aStr","isProtoString","fromSetString","charCodeAt","compareByOriginalPositions","mappingA","mappingB","onlyCompareOriginal","cmp","strcmp","source","originalLine","originalColumn","generatedColumn","generatedLine","name","compareByGeneratedPositionsDeflated","onlyCompareGenerated","aStr1","aStr2","compareByGeneratedPositionsInflated","parseSourceMapInput","str","JSON","parse","computeSourceURL","sourceRoot","sourceURL","sourceMapURL","parsed","substring"],"sources":["/Users/lincolnkushwah/Desktop/All/React Projects/house_joy_new/node_modules/v8-to-istanbul/node_modules/source-map/lib/util.js"],"sourcesContent":["/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\n/**\n * This is a helper function for getting values from parameter/options\n * objects.\n *\n * @param args The object we are extracting values from\n * @param name The name of the property we are getting.\n * @param defaultValue An optional value to return if the property is missing\n * from the object. If this is not specified and the property is missing, an\n * error will be thrown.\n */\nfunction getArg(aArgs, aName, aDefaultValue) {\n  if (aName in aArgs) {\n    return aArgs[aName];\n  } else if (arguments.length === 3) {\n    return aDefaultValue;\n  }\n    throw new Error('\"' + aName + '\" is a required argument.');\n\n}\nexports.getArg = getArg;\n\nconst urlRegexp = /^(?:([\\w+\\-.]+):)?\\/\\/(?:(\\w+:\\w+)@)?([\\w.-]*)(?::(\\d+))?(.*)$/;\nconst dataUrlRegexp = /^data:.+\\,.+$/;\n\nfunction urlParse(aUrl) {\n  const match = aUrl.match(urlRegexp);\n  if (!match) {\n    return null;\n  }\n  return {\n    scheme: match[1],\n    auth: match[2],\n    host: match[3],\n    port: match[4],\n    path: match[5]\n  };\n}\nexports.urlParse = urlParse;\n\nfunction urlGenerate(aParsedUrl) {\n  let url = \"\";\n  if (aParsedUrl.scheme) {\n    url += aParsedUrl.scheme + \":\";\n  }\n  url += \"//\";\n  if (aParsedUrl.auth) {\n    url += aParsedUrl.auth + \"@\";\n  }\n  if (aParsedUrl.host) {\n    url += aParsedUrl.host;\n  }\n  if (aParsedUrl.port) {\n    url += \":\" + aParsedUrl.port;\n  }\n  if (aParsedUrl.path) {\n    url += aParsedUrl.path;\n  }\n  return url;\n}\nexports.urlGenerate = urlGenerate;\n\nconst MAX_CACHED_INPUTS = 32;\n\n/**\n * Takes some function `f(input) -> result` and returns a memoized version of\n * `f`.\n *\n * We keep at most `MAX_CACHED_INPUTS` memoized results of `f` alive. The\n * memoization is a dumb-simple, linear least-recently-used cache.\n */\nfunction lruMemoize(f) {\n  const cache = [];\n\n  return function(input) {\n    for (let i = 0; i < cache.length; i++) {\n      if (cache[i].input === input) {\n        const temp = cache[0];\n        cache[0] = cache[i];\n        cache[i] = temp;\n        return cache[0].result;\n      }\n    }\n\n    const result = f(input);\n\n    cache.unshift({\n      input,\n      result,\n    });\n\n    if (cache.length > MAX_CACHED_INPUTS) {\n      cache.pop();\n    }\n\n    return result;\n  };\n}\n\n/**\n * Normalizes a path, or the path portion of a URL:\n *\n * - Replaces consecutive slashes with one slash.\n * - Removes unnecessary '.' parts.\n * - Removes unnecessary '<dir>/..' parts.\n *\n * Based on code in the Node.js 'path' core module.\n *\n * @param aPath The path or url to normalize.\n */\nconst normalize = lruMemoize(function normalize(aPath) {\n  let path = aPath;\n  const url = urlParse(aPath);\n  if (url) {\n    if (!url.path) {\n      return aPath;\n    }\n    path = url.path;\n  }\n  const isAbsolute = exports.isAbsolute(path);\n\n  // Split the path into parts between `/` characters. This is much faster than\n  // using `.split(/\\/+/g)`.\n  const parts = [];\n  let start = 0;\n  let i = 0;\n  while (true) {\n    start = i;\n    i = path.indexOf(\"/\", start);\n    if (i === -1) {\n      parts.push(path.slice(start));\n      break;\n    } else {\n      parts.push(path.slice(start, i));\n      while (i < path.length && path[i] === \"/\") {\n        i++;\n      }\n    }\n  }\n\n  let up = 0;\n  for (i = parts.length - 1; i >= 0; i--) {\n    const part = parts[i];\n    if (part === \".\") {\n      parts.splice(i, 1);\n    } else if (part === \"..\") {\n      up++;\n    } else if (up > 0) {\n      if (part === \"\") {\n        // The first part is blank if the path is absolute. Trying to go\n        // above the root is a no-op. Therefore we can remove all '..' parts\n        // directly after the root.\n        parts.splice(i + 1, up);\n        up = 0;\n      } else {\n        parts.splice(i, 2);\n        up--;\n      }\n    }\n  }\n  path = parts.join(\"/\");\n\n  if (path === \"\") {\n    path = isAbsolute ? \"/\" : \".\";\n  }\n\n  if (url) {\n    url.path = path;\n    return urlGenerate(url);\n  }\n  return path;\n});\nexports.normalize = normalize;\n\n/**\n * Joins two paths/URLs.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be joined with the root.\n *\n * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a\n *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended\n *   first.\n * - Otherwise aPath is a path. If aRoot is a URL, then its path portion\n *   is updated with the result and aRoot is returned. Otherwise the result\n *   is returned.\n *   - If aPath is absolute, the result is aPath.\n *   - Otherwise the two paths are joined with a slash.\n * - Joining for example 'http://' and 'www.example.com' is also supported.\n */\nfunction join(aRoot, aPath) {\n  if (aRoot === \"\") {\n    aRoot = \".\";\n  }\n  if (aPath === \"\") {\n    aPath = \".\";\n  }\n  const aPathUrl = urlParse(aPath);\n  const aRootUrl = urlParse(aRoot);\n  if (aRootUrl) {\n    aRoot = aRootUrl.path || \"/\";\n  }\n\n  // `join(foo, '//www.example.org')`\n  if (aPathUrl && !aPathUrl.scheme) {\n    if (aRootUrl) {\n      aPathUrl.scheme = aRootUrl.scheme;\n    }\n    return urlGenerate(aPathUrl);\n  }\n\n  if (aPathUrl || aPath.match(dataUrlRegexp)) {\n    return aPath;\n  }\n\n  // `join('http://', 'www.example.com')`\n  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {\n    aRootUrl.host = aPath;\n    return urlGenerate(aRootUrl);\n  }\n\n  const joined = aPath.charAt(0) === \"/\"\n    ? aPath\n    : normalize(aRoot.replace(/\\/+$/, \"\") + \"/\" + aPath);\n\n  if (aRootUrl) {\n    aRootUrl.path = joined;\n    return urlGenerate(aRootUrl);\n  }\n  return joined;\n}\nexports.join = join;\n\nexports.isAbsolute = function(aPath) {\n  return aPath.charAt(0) === \"/\" || urlRegexp.test(aPath);\n};\n\n/**\n * Make a path relative to a URL or another path.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be made relative to aRoot.\n */\nfunction relative(aRoot, aPath) {\n  if (aRoot === \"\") {\n    aRoot = \".\";\n  }\n\n  aRoot = aRoot.replace(/\\/$/, \"\");\n\n  // It is possible for the path to be above the root. In this case, simply\n  // checking whether the root is a prefix of the path won't work. Instead, we\n  // need to remove components from the root one by one, until either we find\n  // a prefix that fits, or we run out of components to remove.\n  let level = 0;\n  while (aPath.indexOf(aRoot + \"/\") !== 0) {\n    const index = aRoot.lastIndexOf(\"/\");\n    if (index < 0) {\n      return aPath;\n    }\n\n    // If the only part of the root that is left is the scheme (i.e. http://,\n    // file:///, etc.), one or more slashes (/), or simply nothing at all, we\n    // have exhausted all components, so the path is not relative to the root.\n    aRoot = aRoot.slice(0, index);\n    if (aRoot.match(/^([^\\/]+:\\/)?\\/*$/)) {\n      return aPath;\n    }\n\n    ++level;\n  }\n\n  // Make sure we add a \"../\" for each component we removed from the root.\n  return Array(level + 1).join(\"../\") + aPath.substr(aRoot.length + 1);\n}\nexports.relative = relative;\n\nconst supportsNullProto = (function() {\n  const obj = Object.create(null);\n  return !(\"__proto__\" in obj);\n}());\n\nfunction identity(s) {\n  return s;\n}\n\n/**\n * Because behavior goes wacky when you set `__proto__` on objects, we\n * have to prefix all the strings in our set with an arbitrary character.\n *\n * See https://github.com/mozilla/source-map/pull/31 and\n * https://github.com/mozilla/source-map/issues/30\n *\n * @param String aStr\n */\nfunction toSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return \"$\" + aStr;\n  }\n\n  return aStr;\n}\nexports.toSetString = supportsNullProto ? identity : toSetString;\n\nfunction fromSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return aStr.slice(1);\n  }\n\n  return aStr;\n}\nexports.fromSetString = supportsNullProto ? identity : fromSetString;\n\nfunction isProtoString(s) {\n  if (!s) {\n    return false;\n  }\n\n  const length = s.length;\n\n  if (length < 9 /* \"__proto__\".length */) {\n    return false;\n  }\n\n  /* eslint-disable no-multi-spaces */\n  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 2) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||\n      s.charCodeAt(length - 4) !== 116 /* 't' */ ||\n      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||\n      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||\n      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||\n      s.charCodeAt(length - 8) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 9) !== 95  /* '_' */) {\n    return false;\n  }\n  /* eslint-enable no-multi-spaces */\n\n  for (let i = length - 10; i >= 0; i--) {\n    if (s.charCodeAt(i) !== 36 /* '$' */) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Comparator between two mappings where the original positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same original source/line/column, but different generated\n * line and column the same. Useful when searching for a mapping with a\n * stubbed out mapping.\n */\nfunction compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {\n  let cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0 || onlyCompareOriginal) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByOriginalPositions = compareByOriginalPositions;\n\n/**\n * Comparator between two mappings with deflated source and name indices where\n * the generated positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same generated line and column, but different\n * source/name/original line and column the same. Useful when searching for a\n * mapping with a stubbed out mapping.\n */\nfunction compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {\n  let cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0 || onlyCompareGenerated) {\n    return cmp;\n  }\n\n  cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;\n\nfunction strcmp(aStr1, aStr2) {\n  if (aStr1 === aStr2) {\n    return 0;\n  }\n\n  if (aStr1 === null) {\n    return 1; // aStr2 !== null\n  }\n\n  if (aStr2 === null) {\n    return -1; // aStr1 !== null\n  }\n\n  if (aStr1 > aStr2) {\n    return 1;\n  }\n\n  return -1;\n}\n\n/**\n * Comparator between two mappings with inflated source and name strings where\n * the generated positions are compared.\n */\nfunction compareByGeneratedPositionsInflated(mappingA, mappingB) {\n  let cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;\n\n/**\n * Strip any JSON XSSI avoidance prefix from the string (as documented\n * in the source maps specification), and then parse the string as\n * JSON.\n */\nfunction parseSourceMapInput(str) {\n  return JSON.parse(str.replace(/^\\)]}'[^\\n]*\\n/, \"\"));\n}\nexports.parseSourceMapInput = parseSourceMapInput;\n\n/**\n * Compute the URL of a source given the the source root, the source's\n * URL, and the source map's URL.\n */\nfunction computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {\n  sourceURL = sourceURL || \"\";\n\n  if (sourceRoot) {\n    // This follows what Chrome does.\n    if (sourceRoot[sourceRoot.length - 1] !== \"/\" && sourceURL[0] !== \"/\") {\n      sourceRoot += \"/\";\n    }\n    // The spec says:\n    //   Line 4: An optional source root, useful for relocating source\n    //   files on a server or removing repeated values in the\n    //   “sources” entry.  This value is prepended to the individual\n    //   entries in the “source” field.\n    sourceURL = sourceRoot + sourceURL;\n  }\n\n  // Historically, SourceMapConsumer did not take the sourceMapURL as\n  // a parameter.  This mode is still somewhat supported, which is why\n  // this code block is conditional.  However, it's preferable to pass\n  // the source map URL to SourceMapConsumer, so that this function\n  // can implement the source URL resolution algorithm as outlined in\n  // the spec.  This block is basically the equivalent of:\n  //    new URL(sourceURL, sourceMapURL).toString()\n  // ... except it avoids using URL, which wasn't available in the\n  // older releases of node still supported by this library.\n  //\n  // The spec says:\n  //   If the sources are not absolute URLs after prepending of the\n  //   “sourceRoot”, the sources are resolved relative to the\n  //   SourceMap (like resolving script src in a html document).\n  if (sourceMapURL) {\n    const parsed = urlParse(sourceMapURL);\n    if (!parsed) {\n      throw new Error(\"sourceMapURL could not be parsed\");\n    }\n    if (parsed.path) {\n      // Strip the last path component, but keep the \"/\".\n      const index = parsed.path.lastIndexOf(\"/\");\n      if (index >= 0) {\n        parsed.path = parsed.path.substring(0, index + 1);\n      }\n    }\n    sourceURL = join(urlGenerate(parsed), sourceURL);\n  }\n\n  return normalize(sourceURL);\n}\nexports.computeSourceURL = computeSourceURL;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}