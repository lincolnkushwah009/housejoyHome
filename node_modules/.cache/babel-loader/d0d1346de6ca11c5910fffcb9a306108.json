{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.createTestScheduler = createTestScheduler;\n\nfunction _chalk() {\n  const data = _interopRequireDefault(require('chalk'));\n\n  _chalk = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _exit() {\n  const data = _interopRequireDefault(require('exit'));\n\n  _exit = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _reporters() {\n  const data = require('@jest/reporters');\n\n  _reporters = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _testResult() {\n  const data = require('@jest/test-result');\n\n  _testResult = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _transform() {\n  const data = require('@jest/transform');\n\n  _transform = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestMessageUtil() {\n  const data = require('jest-message-util');\n\n  _jestMessageUtil = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestSnapshot() {\n  const data = _interopRequireDefault(require('jest-snapshot'));\n\n  _jestSnapshot = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestUtil() {\n  const data = require('jest-util');\n\n  _jestUtil = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _ReporterDispatcher = _interopRequireDefault(require('./ReporterDispatcher'));\n\nvar _testSchedulerHelper = require('./testSchedulerHelper');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nasync function createTestScheduler(globalConfig, options, context) {\n  const scheduler = new TestScheduler(globalConfig, options, context);\n  await scheduler._setupReporters();\n  return scheduler;\n}\n\nclass TestScheduler {\n  constructor(globalConfig, options, context) {\n    _defineProperty(this, '_dispatcher', void 0);\n\n    _defineProperty(this, '_globalConfig', void 0);\n\n    _defineProperty(this, '_options', void 0);\n\n    _defineProperty(this, '_context', void 0);\n\n    this._dispatcher = new _ReporterDispatcher.default();\n    this._globalConfig = globalConfig;\n    this._options = options;\n    this._context = context;\n  }\n\n  addReporter(reporter) {\n    this._dispatcher.register(reporter);\n  }\n\n  removeReporter(ReporterClass) {\n    this._dispatcher.unregister(ReporterClass);\n  }\n\n  async scheduleTests(tests, watcher) {\n    const onTestFileStart = this._dispatcher.onTestFileStart.bind(this._dispatcher);\n\n    const timings = [];\n    const contexts = new Set();\n    tests.forEach(test => {\n      contexts.add(test.context);\n\n      if (test.duration) {\n        timings.push(test.duration);\n      }\n    });\n    const aggregatedResults = createAggregatedResults(tests.length);\n    const estimatedTime = Math.ceil(getEstimatedTime(timings, this._globalConfig.maxWorkers) / 1000);\n    const runInBand = (0, _testSchedulerHelper.shouldRunInBand)(tests, timings, this._globalConfig);\n\n    const onResult = async (test, testResult) => {\n      if (watcher.isInterrupted()) {\n        return Promise.resolve();\n      }\n\n      if (testResult.testResults.length === 0) {\n        const message = 'Your test suite must contain at least one test.';\n        return onFailure(test, {\n          message,\n          stack: new Error(message).stack\n        });\n      } // Throws when the context is leaked after executing a test.\n\n\n      if (testResult.leaks) {\n        const message = _chalk().default.red.bold('EXPERIMENTAL FEATURE!\\n') + 'Your test suite is leaking memory. Please ensure all references are cleaned.\\n' + '\\n' + 'There is a number of things that can leak memory:\\n' + '  - Async operations that have not finished (e.g. fs.readFile).\\n' + '  - Timers not properly mocked (e.g. setInterval, setTimeout).\\n' + '  - Keeping references to the global scope.';\n        return onFailure(test, {\n          message,\n          stack: new Error(message).stack\n        });\n      }\n\n      (0, _testResult().addResult)(aggregatedResults, testResult);\n      await this._dispatcher.onTestFileResult(test, testResult, aggregatedResults);\n      return this._bailIfNeeded(contexts, aggregatedResults, watcher);\n    };\n\n    const onFailure = async (test, error) => {\n      if (watcher.isInterrupted()) {\n        return;\n      }\n\n      const testResult = (0, _testResult().buildFailureTestResult)(test.path, error);\n      testResult.failureMessage = (0, _jestMessageUtil().formatExecError)(testResult.testExecError, test.context.config, this._globalConfig, test.path);\n      (0, _testResult().addResult)(aggregatedResults, testResult);\n      await this._dispatcher.onTestFileResult(test, testResult, aggregatedResults);\n    };\n\n    const updateSnapshotState = async () => {\n      const contextsWithSnapshotResolvers = await Promise.all(Array.from(contexts).map(async context => [context, await _jestSnapshot().default.buildSnapshotResolver(context.config)]));\n      contextsWithSnapshotResolvers.forEach(_ref => {\n        let [context, snapshotResolver] = _ref;\n\n        const status = _jestSnapshot().default.cleanup(context.hasteFS, this._globalConfig.updateSnapshot, snapshotResolver, context.config.testPathIgnorePatterns);\n\n        aggregatedResults.snapshot.filesRemoved += status.filesRemoved;\n        aggregatedResults.snapshot.filesRemovedList = (aggregatedResults.snapshot.filesRemovedList || []).concat(status.filesRemovedList);\n      });\n      const updateAll = this._globalConfig.updateSnapshot === 'all';\n      aggregatedResults.snapshot.didUpdate = updateAll;\n      aggregatedResults.snapshot.failure = !!(!updateAll && (aggregatedResults.snapshot.unchecked || aggregatedResults.snapshot.unmatched || aggregatedResults.snapshot.filesRemoved));\n    };\n\n    await this._dispatcher.onRunStart(aggregatedResults, {\n      estimatedTime,\n      showStatus: !runInBand\n    });\n    const testRunners = Object.create(null);\n    const contextsByTestRunner = new WeakMap();\n    await Promise.all(Array.from(contexts).map(async context => {\n      const {\n        config\n      } = context;\n\n      if (!testRunners[config.runner]) {\n        var _this$_context, _this$_context2;\n\n        const transformer = await (0, _transform().createScriptTransformer)(config);\n        const Runner = await transformer.requireAndTranspileModule(config.runner);\n        const runner = new Runner(this._globalConfig, {\n          changedFiles: (_this$_context = this._context) === null || _this$_context === void 0 ? void 0 : _this$_context.changedFiles,\n          sourcesRelatedToTestsInChangedFiles: (_this$_context2 = this._context) === null || _this$_context2 === void 0 ? void 0 : _this$_context2.sourcesRelatedToTestsInChangedFiles\n        });\n        testRunners[config.runner] = runner;\n        contextsByTestRunner.set(runner, context);\n      }\n    }));\n\n    const testsByRunner = this._partitionTests(testRunners, tests);\n\n    if (testsByRunner) {\n      try {\n        for (const runner of Object.keys(testRunners)) {\n          const testRunner = testRunners[runner];\n          const context = contextsByTestRunner.get(testRunner);\n          invariant(context);\n          const tests = testsByRunner[runner];\n          const testRunnerOptions = {\n            serial: runInBand || Boolean(testRunner.isSerial)\n          };\n          /**\n           * Test runners with event emitters are still not supported\n           * for third party test runners.\n           */\n\n          if (testRunner.__PRIVATE_UNSTABLE_API_supportsEventEmitters__) {\n            const unsubscribes = [testRunner.on('test-file-start', _ref2 => {\n              let [test] = _ref2;\n              return onTestFileStart(test);\n            }), testRunner.on('test-file-success', _ref3 => {\n              let [test, testResult] = _ref3;\n              return onResult(test, testResult);\n            }), testRunner.on('test-file-failure', _ref4 => {\n              let [test, error] = _ref4;\n              return onFailure(test, error);\n            }), testRunner.on('test-case-result', _ref5 => {\n              let [testPath, testCaseResult] = _ref5;\n              const test = {\n                context,\n                path: testPath\n              };\n\n              this._dispatcher.onTestCaseResult(test, testCaseResult);\n            })];\n            await testRunner.runTests(tests, watcher, undefined, undefined, undefined, testRunnerOptions);\n            unsubscribes.forEach(sub => sub());\n          } else {\n            await testRunner.runTests(tests, watcher, onTestFileStart, onResult, onFailure, testRunnerOptions);\n          }\n        }\n      } catch (error) {\n        if (!watcher.isInterrupted()) {\n          throw error;\n        }\n      }\n    }\n\n    await updateSnapshotState();\n    aggregatedResults.wasInterrupted = watcher.isInterrupted();\n    await this._dispatcher.onRunComplete(contexts, aggregatedResults);\n    const anyTestFailures = !(aggregatedResults.numFailedTests === 0 && aggregatedResults.numRuntimeErrorTestSuites === 0);\n\n    const anyReporterErrors = this._dispatcher.hasErrors();\n\n    aggregatedResults.success = !(anyTestFailures || aggregatedResults.snapshot.failure || anyReporterErrors);\n    return aggregatedResults;\n  }\n\n  _partitionTests(testRunners, tests) {\n    if (Object.keys(testRunners).length > 1) {\n      return tests.reduce((testRuns, test) => {\n        const runner = test.context.config.runner;\n\n        if (!testRuns[runner]) {\n          testRuns[runner] = [];\n        }\n\n        testRuns[runner].push(test);\n        return testRuns;\n      }, Object.create(null));\n    } else if (tests.length > 0 && tests[0] != null) {\n      // If there is only one runner, don't partition the tests.\n      return Object.assign(Object.create(null), {\n        [tests[0].context.config.runner]: tests\n      });\n    } else {\n      return null;\n    }\n  }\n\n  _shouldAddDefaultReporters(reporters) {\n    return !reporters || !!reporters.find(reporter => this._getReporterProps(reporter).path === 'default');\n  }\n\n  async _setupReporters() {\n    const {\n      collectCoverage,\n      notify,\n      reporters\n    } = this._globalConfig;\n\n    const isDefault = this._shouldAddDefaultReporters(reporters);\n\n    if (isDefault) {\n      this._setupDefaultReporters(collectCoverage);\n    }\n\n    if (!isDefault && collectCoverage) {\n      var _this$_context3, _this$_context4;\n\n      this.addReporter(new (_reporters().CoverageReporter)(this._globalConfig, {\n        changedFiles: (_this$_context3 = this._context) === null || _this$_context3 === void 0 ? void 0 : _this$_context3.changedFiles,\n        sourcesRelatedToTestsInChangedFiles: (_this$_context4 = this._context) === null || _this$_context4 === void 0 ? void 0 : _this$_context4.sourcesRelatedToTestsInChangedFiles\n      }));\n    }\n\n    if (notify) {\n      this.addReporter(new (_reporters().NotifyReporter)(this._globalConfig, this._options.startRun, this._context));\n    }\n\n    if (reporters && Array.isArray(reporters)) {\n      await this._addCustomReporters(reporters);\n    }\n  }\n\n  _setupDefaultReporters(collectCoverage) {\n    this.addReporter(this._globalConfig.verbose ? new (_reporters().VerboseReporter)(this._globalConfig) : new (_reporters().DefaultReporter)(this._globalConfig));\n\n    if (collectCoverage) {\n      var _this$_context5, _this$_context6;\n\n      this.addReporter(new (_reporters().CoverageReporter)(this._globalConfig, {\n        changedFiles: (_this$_context5 = this._context) === null || _this$_context5 === void 0 ? void 0 : _this$_context5.changedFiles,\n        sourcesRelatedToTestsInChangedFiles: (_this$_context6 = this._context) === null || _this$_context6 === void 0 ? void 0 : _this$_context6.sourcesRelatedToTestsInChangedFiles\n      }));\n    }\n\n    this.addReporter(new (_reporters().SummaryReporter)(this._globalConfig));\n  }\n\n  async _addCustomReporters(reporters) {\n    for (const reporter of reporters) {\n      const {\n        options,\n        path\n      } = this._getReporterProps(reporter);\n\n      if (path === 'default') continue;\n\n      try {\n        const Reporter = await (0, _jestUtil().requireOrImportModule)(path, true);\n        this.addReporter(new Reporter(this._globalConfig, options));\n      } catch (error) {\n        error.message = 'An error occurred while adding the reporter at path \"' + _chalk().default.bold(path) + '\".' + error.message;\n        throw error;\n      }\n    }\n  }\n  /**\n   * Get properties of a reporter in an object\n   * to make dealing with them less painful.\n   */\n\n\n  _getReporterProps(reporter) {\n    if (typeof reporter === 'string') {\n      return {\n        options: this._options,\n        path: reporter\n      };\n    } else if (Array.isArray(reporter)) {\n      const [path, options] = reporter;\n      return {\n        options,\n        path\n      };\n    }\n\n    throw new Error('Reporter should be either a string or an array');\n  }\n\n  async _bailIfNeeded(contexts, aggregatedResults, watcher) {\n    if (this._globalConfig.bail !== 0 && aggregatedResults.numFailedTests >= this._globalConfig.bail) {\n      if (watcher.isWatchMode()) {\n        await watcher.setState({\n          interrupted: true\n        });\n        return;\n      }\n\n      try {\n        await this._dispatcher.onRunComplete(contexts, aggregatedResults);\n      } finally {\n        const exitCode = this._globalConfig.testFailureExitCode;\n        (0, _exit().default)(exitCode);\n      }\n    }\n  }\n\n}\n\nfunction invariant(condition, message) {\n  if (!condition) {\n    throw new Error(message);\n  }\n}\n\nconst createAggregatedResults = numTotalTestSuites => {\n  const result = (0, _testResult().makeEmptyAggregatedTestResult)();\n  result.numTotalTestSuites = numTotalTestSuites;\n  result.startTime = Date.now();\n  result.success = false;\n  return result;\n};\n\nconst getEstimatedTime = (timings, workers) => {\n  if (timings.length === 0) {\n    return 0;\n  }\n\n  const max = Math.max(...timings);\n  return timings.length <= workers ? max : Math.max(timings.reduce((sum, time) => sum + time) / workers, max);\n};","map":{"version":3,"names":["Object","defineProperty","exports","value","createTestScheduler","_chalk","data","_interopRequireDefault","require","_exit","_reporters","_testResult","_transform","_jestMessageUtil","_jestSnapshot","_jestUtil","_ReporterDispatcher","_testSchedulerHelper","obj","__esModule","default","_defineProperty","key","enumerable","configurable","writable","globalConfig","options","context","scheduler","TestScheduler","_setupReporters","constructor","_dispatcher","_globalConfig","_options","_context","addReporter","reporter","register","removeReporter","ReporterClass","unregister","scheduleTests","tests","watcher","onTestFileStart","bind","timings","contexts","Set","forEach","test","add","duration","push","aggregatedResults","createAggregatedResults","length","estimatedTime","Math","ceil","getEstimatedTime","maxWorkers","runInBand","shouldRunInBand","onResult","testResult","isInterrupted","Promise","resolve","testResults","message","onFailure","stack","Error","leaks","red","bold","addResult","onTestFileResult","_bailIfNeeded","error","buildFailureTestResult","path","failureMessage","formatExecError","testExecError","config","updateSnapshotState","contextsWithSnapshotResolvers","all","Array","from","map","buildSnapshotResolver","snapshotResolver","status","cleanup","hasteFS","updateSnapshot","testPathIgnorePatterns","snapshot","filesRemoved","filesRemovedList","concat","updateAll","didUpdate","failure","unchecked","unmatched","onRunStart","showStatus","testRunners","create","contextsByTestRunner","WeakMap","runner","_this$_context","_this$_context2","transformer","createScriptTransformer","Runner","requireAndTranspileModule","changedFiles","sourcesRelatedToTestsInChangedFiles","set","testsByRunner","_partitionTests","keys","testRunner","get","invariant","testRunnerOptions","serial","Boolean","isSerial","__PRIVATE_UNSTABLE_API_supportsEventEmitters__","unsubscribes","on","testPath","testCaseResult","onTestCaseResult","runTests","undefined","sub","wasInterrupted","onRunComplete","anyTestFailures","numFailedTests","numRuntimeErrorTestSuites","anyReporterErrors","hasErrors","success","reduce","testRuns","assign","_shouldAddDefaultReporters","reporters","find","_getReporterProps","collectCoverage","notify","isDefault","_setupDefaultReporters","_this$_context3","_this$_context4","CoverageReporter","NotifyReporter","startRun","isArray","_addCustomReporters","verbose","VerboseReporter","DefaultReporter","_this$_context5","_this$_context6","SummaryReporter","Reporter","requireOrImportModule","bail","isWatchMode","setState","interrupted","exitCode","testFailureExitCode","condition","numTotalTestSuites","result","makeEmptyAggregatedTestResult","startTime","Date","now","workers","max","sum","time"],"sources":["/Users/lincolnkushwah/Desktop/All/React Projects/house_joy_new/node_modules/@jest/core/build/TestScheduler.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.createTestScheduler = createTestScheduler;\n\nfunction _chalk() {\n  const data = _interopRequireDefault(require('chalk'));\n\n  _chalk = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _exit() {\n  const data = _interopRequireDefault(require('exit'));\n\n  _exit = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _reporters() {\n  const data = require('@jest/reporters');\n\n  _reporters = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _testResult() {\n  const data = require('@jest/test-result');\n\n  _testResult = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _transform() {\n  const data = require('@jest/transform');\n\n  _transform = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestMessageUtil() {\n  const data = require('jest-message-util');\n\n  _jestMessageUtil = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestSnapshot() {\n  const data = _interopRequireDefault(require('jest-snapshot'));\n\n  _jestSnapshot = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestUtil() {\n  const data = require('jest-util');\n\n  _jestUtil = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _ReporterDispatcher = _interopRequireDefault(\n  require('./ReporterDispatcher')\n);\n\nvar _testSchedulerHelper = require('./testSchedulerHelper');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\nasync function createTestScheduler(globalConfig, options, context) {\n  const scheduler = new TestScheduler(globalConfig, options, context);\n  await scheduler._setupReporters();\n  return scheduler;\n}\n\nclass TestScheduler {\n  constructor(globalConfig, options, context) {\n    _defineProperty(this, '_dispatcher', void 0);\n\n    _defineProperty(this, '_globalConfig', void 0);\n\n    _defineProperty(this, '_options', void 0);\n\n    _defineProperty(this, '_context', void 0);\n\n    this._dispatcher = new _ReporterDispatcher.default();\n    this._globalConfig = globalConfig;\n    this._options = options;\n    this._context = context;\n  }\n\n  addReporter(reporter) {\n    this._dispatcher.register(reporter);\n  }\n\n  removeReporter(ReporterClass) {\n    this._dispatcher.unregister(ReporterClass);\n  }\n\n  async scheduleTests(tests, watcher) {\n    const onTestFileStart = this._dispatcher.onTestFileStart.bind(\n      this._dispatcher\n    );\n\n    const timings = [];\n    const contexts = new Set();\n    tests.forEach(test => {\n      contexts.add(test.context);\n\n      if (test.duration) {\n        timings.push(test.duration);\n      }\n    });\n    const aggregatedResults = createAggregatedResults(tests.length);\n    const estimatedTime = Math.ceil(\n      getEstimatedTime(timings, this._globalConfig.maxWorkers) / 1000\n    );\n    const runInBand = (0, _testSchedulerHelper.shouldRunInBand)(\n      tests,\n      timings,\n      this._globalConfig\n    );\n\n    const onResult = async (test, testResult) => {\n      if (watcher.isInterrupted()) {\n        return Promise.resolve();\n      }\n\n      if (testResult.testResults.length === 0) {\n        const message = 'Your test suite must contain at least one test.';\n        return onFailure(test, {\n          message,\n          stack: new Error(message).stack\n        });\n      } // Throws when the context is leaked after executing a test.\n\n      if (testResult.leaks) {\n        const message =\n          _chalk().default.red.bold('EXPERIMENTAL FEATURE!\\n') +\n          'Your test suite is leaking memory. Please ensure all references are cleaned.\\n' +\n          '\\n' +\n          'There is a number of things that can leak memory:\\n' +\n          '  - Async operations that have not finished (e.g. fs.readFile).\\n' +\n          '  - Timers not properly mocked (e.g. setInterval, setTimeout).\\n' +\n          '  - Keeping references to the global scope.';\n        return onFailure(test, {\n          message,\n          stack: new Error(message).stack\n        });\n      }\n\n      (0, _testResult().addResult)(aggregatedResults, testResult);\n      await this._dispatcher.onTestFileResult(\n        test,\n        testResult,\n        aggregatedResults\n      );\n      return this._bailIfNeeded(contexts, aggregatedResults, watcher);\n    };\n\n    const onFailure = async (test, error) => {\n      if (watcher.isInterrupted()) {\n        return;\n      }\n\n      const testResult = (0, _testResult().buildFailureTestResult)(\n        test.path,\n        error\n      );\n      testResult.failureMessage = (0, _jestMessageUtil().formatExecError)(\n        testResult.testExecError,\n        test.context.config,\n        this._globalConfig,\n        test.path\n      );\n      (0, _testResult().addResult)(aggregatedResults, testResult);\n      await this._dispatcher.onTestFileResult(\n        test,\n        testResult,\n        aggregatedResults\n      );\n    };\n\n    const updateSnapshotState = async () => {\n      const contextsWithSnapshotResolvers = await Promise.all(\n        Array.from(contexts).map(async context => [\n          context,\n          await _jestSnapshot().default.buildSnapshotResolver(context.config)\n        ])\n      );\n      contextsWithSnapshotResolvers.forEach(([context, snapshotResolver]) => {\n        const status = _jestSnapshot().default.cleanup(\n          context.hasteFS,\n          this._globalConfig.updateSnapshot,\n          snapshotResolver,\n          context.config.testPathIgnorePatterns\n        );\n\n        aggregatedResults.snapshot.filesRemoved += status.filesRemoved;\n        aggregatedResults.snapshot.filesRemovedList = (\n          aggregatedResults.snapshot.filesRemovedList || []\n        ).concat(status.filesRemovedList);\n      });\n      const updateAll = this._globalConfig.updateSnapshot === 'all';\n      aggregatedResults.snapshot.didUpdate = updateAll;\n      aggregatedResults.snapshot.failure = !!(\n        !updateAll &&\n        (aggregatedResults.snapshot.unchecked ||\n          aggregatedResults.snapshot.unmatched ||\n          aggregatedResults.snapshot.filesRemoved)\n      );\n    };\n\n    await this._dispatcher.onRunStart(aggregatedResults, {\n      estimatedTime,\n      showStatus: !runInBand\n    });\n    const testRunners = Object.create(null);\n    const contextsByTestRunner = new WeakMap();\n    await Promise.all(\n      Array.from(contexts).map(async context => {\n        const {config} = context;\n\n        if (!testRunners[config.runner]) {\n          var _this$_context, _this$_context2;\n\n          const transformer = await (0, _transform().createScriptTransformer)(\n            config\n          );\n          const Runner = await transformer.requireAndTranspileModule(\n            config.runner\n          );\n          const runner = new Runner(this._globalConfig, {\n            changedFiles:\n              (_this$_context = this._context) === null ||\n              _this$_context === void 0\n                ? void 0\n                : _this$_context.changedFiles,\n            sourcesRelatedToTestsInChangedFiles:\n              (_this$_context2 = this._context) === null ||\n              _this$_context2 === void 0\n                ? void 0\n                : _this$_context2.sourcesRelatedToTestsInChangedFiles\n          });\n          testRunners[config.runner] = runner;\n          contextsByTestRunner.set(runner, context);\n        }\n      })\n    );\n\n    const testsByRunner = this._partitionTests(testRunners, tests);\n\n    if (testsByRunner) {\n      try {\n        for (const runner of Object.keys(testRunners)) {\n          const testRunner = testRunners[runner];\n          const context = contextsByTestRunner.get(testRunner);\n          invariant(context);\n          const tests = testsByRunner[runner];\n          const testRunnerOptions = {\n            serial: runInBand || Boolean(testRunner.isSerial)\n          };\n          /**\n           * Test runners with event emitters are still not supported\n           * for third party test runners.\n           */\n\n          if (testRunner.__PRIVATE_UNSTABLE_API_supportsEventEmitters__) {\n            const unsubscribes = [\n              testRunner.on('test-file-start', ([test]) =>\n                onTestFileStart(test)\n              ),\n              testRunner.on('test-file-success', ([test, testResult]) =>\n                onResult(test, testResult)\n              ),\n              testRunner.on('test-file-failure', ([test, error]) =>\n                onFailure(test, error)\n              ),\n              testRunner.on(\n                'test-case-result',\n                ([testPath, testCaseResult]) => {\n                  const test = {\n                    context,\n                    path: testPath\n                  };\n\n                  this._dispatcher.onTestCaseResult(test, testCaseResult);\n                }\n              )\n            ];\n            await testRunner.runTests(\n              tests,\n              watcher,\n              undefined,\n              undefined,\n              undefined,\n              testRunnerOptions\n            );\n            unsubscribes.forEach(sub => sub());\n          } else {\n            await testRunner.runTests(\n              tests,\n              watcher,\n              onTestFileStart,\n              onResult,\n              onFailure,\n              testRunnerOptions\n            );\n          }\n        }\n      } catch (error) {\n        if (!watcher.isInterrupted()) {\n          throw error;\n        }\n      }\n    }\n\n    await updateSnapshotState();\n    aggregatedResults.wasInterrupted = watcher.isInterrupted();\n    await this._dispatcher.onRunComplete(contexts, aggregatedResults);\n    const anyTestFailures = !(\n      aggregatedResults.numFailedTests === 0 &&\n      aggregatedResults.numRuntimeErrorTestSuites === 0\n    );\n\n    const anyReporterErrors = this._dispatcher.hasErrors();\n\n    aggregatedResults.success = !(\n      anyTestFailures ||\n      aggregatedResults.snapshot.failure ||\n      anyReporterErrors\n    );\n    return aggregatedResults;\n  }\n\n  _partitionTests(testRunners, tests) {\n    if (Object.keys(testRunners).length > 1) {\n      return tests.reduce((testRuns, test) => {\n        const runner = test.context.config.runner;\n\n        if (!testRuns[runner]) {\n          testRuns[runner] = [];\n        }\n\n        testRuns[runner].push(test);\n        return testRuns;\n      }, Object.create(null));\n    } else if (tests.length > 0 && tests[0] != null) {\n      // If there is only one runner, don't partition the tests.\n      return Object.assign(Object.create(null), {\n        [tests[0].context.config.runner]: tests\n      });\n    } else {\n      return null;\n    }\n  }\n\n  _shouldAddDefaultReporters(reporters) {\n    return (\n      !reporters ||\n      !!reporters.find(\n        reporter => this._getReporterProps(reporter).path === 'default'\n      )\n    );\n  }\n\n  async _setupReporters() {\n    const {collectCoverage, notify, reporters} = this._globalConfig;\n\n    const isDefault = this._shouldAddDefaultReporters(reporters);\n\n    if (isDefault) {\n      this._setupDefaultReporters(collectCoverage);\n    }\n\n    if (!isDefault && collectCoverage) {\n      var _this$_context3, _this$_context4;\n\n      this.addReporter(\n        new (_reporters().CoverageReporter)(this._globalConfig, {\n          changedFiles:\n            (_this$_context3 = this._context) === null ||\n            _this$_context3 === void 0\n              ? void 0\n              : _this$_context3.changedFiles,\n          sourcesRelatedToTestsInChangedFiles:\n            (_this$_context4 = this._context) === null ||\n            _this$_context4 === void 0\n              ? void 0\n              : _this$_context4.sourcesRelatedToTestsInChangedFiles\n        })\n      );\n    }\n\n    if (notify) {\n      this.addReporter(\n        new (_reporters().NotifyReporter)(\n          this._globalConfig,\n          this._options.startRun,\n          this._context\n        )\n      );\n    }\n\n    if (reporters && Array.isArray(reporters)) {\n      await this._addCustomReporters(reporters);\n    }\n  }\n\n  _setupDefaultReporters(collectCoverage) {\n    this.addReporter(\n      this._globalConfig.verbose\n        ? new (_reporters().VerboseReporter)(this._globalConfig)\n        : new (_reporters().DefaultReporter)(this._globalConfig)\n    );\n\n    if (collectCoverage) {\n      var _this$_context5, _this$_context6;\n\n      this.addReporter(\n        new (_reporters().CoverageReporter)(this._globalConfig, {\n          changedFiles:\n            (_this$_context5 = this._context) === null ||\n            _this$_context5 === void 0\n              ? void 0\n              : _this$_context5.changedFiles,\n          sourcesRelatedToTestsInChangedFiles:\n            (_this$_context6 = this._context) === null ||\n            _this$_context6 === void 0\n              ? void 0\n              : _this$_context6.sourcesRelatedToTestsInChangedFiles\n        })\n      );\n    }\n\n    this.addReporter(new (_reporters().SummaryReporter)(this._globalConfig));\n  }\n\n  async _addCustomReporters(reporters) {\n    for (const reporter of reporters) {\n      const {options, path} = this._getReporterProps(reporter);\n\n      if (path === 'default') continue;\n\n      try {\n        const Reporter = await (0, _jestUtil().requireOrImportModule)(\n          path,\n          true\n        );\n        this.addReporter(new Reporter(this._globalConfig, options));\n      } catch (error) {\n        error.message =\n          'An error occurred while adding the reporter at path \"' +\n          _chalk().default.bold(path) +\n          '\".' +\n          error.message;\n        throw error;\n      }\n    }\n  }\n  /**\n   * Get properties of a reporter in an object\n   * to make dealing with them less painful.\n   */\n\n  _getReporterProps(reporter) {\n    if (typeof reporter === 'string') {\n      return {\n        options: this._options,\n        path: reporter\n      };\n    } else if (Array.isArray(reporter)) {\n      const [path, options] = reporter;\n      return {\n        options,\n        path\n      };\n    }\n\n    throw new Error('Reporter should be either a string or an array');\n  }\n\n  async _bailIfNeeded(contexts, aggregatedResults, watcher) {\n    if (\n      this._globalConfig.bail !== 0 &&\n      aggregatedResults.numFailedTests >= this._globalConfig.bail\n    ) {\n      if (watcher.isWatchMode()) {\n        await watcher.setState({\n          interrupted: true\n        });\n        return;\n      }\n\n      try {\n        await this._dispatcher.onRunComplete(contexts, aggregatedResults);\n      } finally {\n        const exitCode = this._globalConfig.testFailureExitCode;\n        (0, _exit().default)(exitCode);\n      }\n    }\n  }\n}\n\nfunction invariant(condition, message) {\n  if (!condition) {\n    throw new Error(message);\n  }\n}\n\nconst createAggregatedResults = numTotalTestSuites => {\n  const result = (0, _testResult().makeEmptyAggregatedTestResult)();\n  result.numTotalTestSuites = numTotalTestSuites;\n  result.startTime = Date.now();\n  result.success = false;\n  return result;\n};\n\nconst getEstimatedTime = (timings, workers) => {\n  if (timings.length === 0) {\n    return 0;\n  }\n\n  const max = Math.max(...timings);\n  return timings.length <= workers\n    ? max\n    : Math.max(timings.reduce((sum, time) => sum + time) / workers, max);\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}