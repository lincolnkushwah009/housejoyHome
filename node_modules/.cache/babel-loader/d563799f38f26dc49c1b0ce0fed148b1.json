{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.addHook = addHook;\n\nvar _module = _interopRequireDefault(require(\"module\"));\n\nvar _path = _interopRequireDefault(require(\"path\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/* (c) 2015 Ari Porad (@ariporad) <http://ariporad.com>. License: ariporad.mit-license.org */\n\n\nconst nodeModulesRegex = /^(?:.*[\\\\/])?node_modules(?:[\\\\/].*)?$/; // Guard against poorly mocked module constructors.\n\nconst Module = module.constructor.length > 1 ? module.constructor : _module.default;\nconst HOOK_RETURNED_NOTHING_ERROR_MESSAGE = '[Pirates] A hook returned a non-string, or nothing at all! This is a' + ' violation of intergalactic law!\\n' + '--------------------\\n' + 'If you have no idea what this means or what Pirates is, let me explain: ' + 'Pirates is a module that makes is easy to implement require hooks. One of' + \" the require hooks you're using uses it. One of these require hooks\" + \" didn't return anything from it's handler, so we don't know what to\" + ' do. You might want to debug this.';\n/**\n * @param {string} filename The filename to check.\n * @param {string[]} exts The extensions to hook. Should start with '.' (ex. ['.js']).\n * @param {Matcher|null} matcher A matcher function, will be called with path to a file. Should return truthy if the file should be hooked, falsy otherwise.\n * @param {boolean} ignoreNodeModules Auto-ignore node_modules. Independent of any matcher.\n */\n\nfunction shouldCompile(filename, exts, matcher, ignoreNodeModules) {\n  if (typeof filename !== 'string') {\n    return false;\n  }\n\n  if (exts.indexOf(_path.default.extname(filename)) === -1) {\n    return false;\n  }\n\n  const resolvedFilename = _path.default.resolve(filename);\n\n  if (ignoreNodeModules && nodeModulesRegex.test(resolvedFilename)) {\n    return false;\n  }\n\n  if (matcher && typeof matcher === 'function') {\n    return !!matcher(resolvedFilename);\n  }\n\n  return true;\n}\n/**\n * @callback Hook The hook. Accepts the code of the module and the filename.\n * @param {string} code\n * @param {string} filename\n * @returns {string}\n */\n\n/**\n * @callback Matcher A matcher function, will be called with path to a file.\n *\n * Should return truthy if the file should be hooked, falsy otherwise.\n * @param {string} path\n * @returns {boolean}\n */\n\n/**\n * @callback RevertFunction Reverts the hook when called.\n * @returns {void}\n */\n\n/**\n * @typedef {object} Options\n * @property {Matcher|null} [matcher=null] A matcher function, will be called with path to a file.\n *\n * Should return truthy if the file should be hooked, falsy otherwise.\n *\n * @property {string[]} [extensions=['.js']] The extensions to hook. Should start with '.' (ex. ['.js']).\n * @property {string[]} [exts=['.js']] The extensions to hook. Should start with '.' (ex. ['.js']).\n *\n * @property {string[]} [extension=['.js']] The extensions to hook. Should start with '.' (ex. ['.js']).\n * @property {string[]} [ext=['.js']] The extensions to hook. Should start with '.' (ex. ['.js']).\n *\n * @property {boolean} [ignoreNodeModules=true] Auto-ignore node_modules. Independent of any matcher.\n */\n\n/**\n * Add a require hook.\n *\n * @param {Hook} hook The hook. Accepts the code of the module and the filename. Required.\n * @param {Options} [opts] Options\n * @returns {RevertFunction} The `revert` function. Reverts the hook when called.\n */\n\n\nfunction addHook(hook) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let reverted = false;\n  const loaders = [];\n  const oldLoaders = [];\n  let exts; // We need to do this to fix #15. Basically, if you use a non-standard extension (ie. .jsx), then\n  // We modify the .js loader, then use the modified .js loader for as the base for .jsx.\n  // This prevents that.\n\n  const originalJSLoader = Module._extensions['.js'];\n  const matcher = opts.matcher || null;\n  const ignoreNodeModules = opts.ignoreNodeModules !== false;\n  exts = opts.extensions || opts.exts || opts.extension || opts.ext || ['.js'];\n\n  if (!Array.isArray(exts)) {\n    exts = [exts];\n  }\n\n  exts.forEach(ext => {\n    if (typeof ext !== 'string') {\n      throw new TypeError(`Invalid Extension: ${ext}`);\n    }\n\n    const oldLoader = Module._extensions[ext] || originalJSLoader;\n    oldLoaders[ext] = Module._extensions[ext];\n\n    loaders[ext] = Module._extensions[ext] = function newLoader(mod, filename) {\n      let compile;\n\n      if (!reverted) {\n        if (shouldCompile(filename, exts, matcher, ignoreNodeModules)) {\n          compile = mod._compile;\n\n          mod._compile = function _compile(code) {\n            // reset the compile immediately as otherwise we end up having the\n            // compile function being changed even though this loader might be reverted\n            // Not reverting it here leads to long useless compile chains when doing\n            // addHook -> revert -> addHook -> revert -> ...\n            // The compile function is also anyway created new when the loader is called a second time.\n            mod._compile = compile;\n            const newCode = hook(code, filename);\n\n            if (typeof newCode !== 'string') {\n              throw new Error(HOOK_RETURNED_NOTHING_ERROR_MESSAGE);\n            }\n\n            return mod._compile(newCode, filename);\n          };\n        }\n      }\n\n      oldLoader(mod, filename);\n    };\n  });\n  return function revert() {\n    if (reverted) return;\n    reverted = true;\n    exts.forEach(ext => {\n      // if the current loader for the extension is our loader then unregister it and set the oldLoader again\n      // if not we can not do anything as we cannot remove a loader from within the loader-chain\n      if (Module._extensions[ext] === loaders[ext]) {\n        if (!oldLoaders[ext]) {\n          delete Module._extensions[ext];\n        } else {\n          Module._extensions[ext] = oldLoaders[ext];\n        }\n      }\n    });\n  };\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","addHook","_module","_interopRequireDefault","require","_path","obj","__esModule","default","nodeModulesRegex","Module","module","constructor","length","HOOK_RETURNED_NOTHING_ERROR_MESSAGE","shouldCompile","filename","exts","matcher","ignoreNodeModules","indexOf","extname","resolvedFilename","resolve","test","hook","opts","reverted","loaders","oldLoaders","originalJSLoader","_extensions","extensions","extension","ext","Array","isArray","forEach","TypeError","oldLoader","newLoader","mod","compile","_compile","code","newCode","Error","revert"],"sources":["/Users/lincolnkushwah/Desktop/All/React Projects/house_joy_new/node_modules/pirates/lib/index.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.addHook = addHook;\n\nvar _module = _interopRequireDefault(require(\"module\"));\n\nvar _path = _interopRequireDefault(require(\"path\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/* (c) 2015 Ari Porad (@ariporad) <http://ariporad.com>. License: ariporad.mit-license.org */\nconst nodeModulesRegex = /^(?:.*[\\\\/])?node_modules(?:[\\\\/].*)?$/; // Guard against poorly mocked module constructors.\n\nconst Module = module.constructor.length > 1 ? module.constructor : _module.default;\nconst HOOK_RETURNED_NOTHING_ERROR_MESSAGE = '[Pirates] A hook returned a non-string, or nothing at all! This is a' + ' violation of intergalactic law!\\n' + '--------------------\\n' + 'If you have no idea what this means or what Pirates is, let me explain: ' + 'Pirates is a module that makes is easy to implement require hooks. One of' + \" the require hooks you're using uses it. One of these require hooks\" + \" didn't return anything from it's handler, so we don't know what to\" + ' do. You might want to debug this.';\n/**\n * @param {string} filename The filename to check.\n * @param {string[]} exts The extensions to hook. Should start with '.' (ex. ['.js']).\n * @param {Matcher|null} matcher A matcher function, will be called with path to a file. Should return truthy if the file should be hooked, falsy otherwise.\n * @param {boolean} ignoreNodeModules Auto-ignore node_modules. Independent of any matcher.\n */\n\nfunction shouldCompile(filename, exts, matcher, ignoreNodeModules) {\n  if (typeof filename !== 'string') {\n    return false;\n  }\n\n  if (exts.indexOf(_path.default.extname(filename)) === -1) {\n    return false;\n  }\n\n  const resolvedFilename = _path.default.resolve(filename);\n\n  if (ignoreNodeModules && nodeModulesRegex.test(resolvedFilename)) {\n    return false;\n  }\n\n  if (matcher && typeof matcher === 'function') {\n    return !!matcher(resolvedFilename);\n  }\n\n  return true;\n}\n/**\n * @callback Hook The hook. Accepts the code of the module and the filename.\n * @param {string} code\n * @param {string} filename\n * @returns {string}\n */\n\n/**\n * @callback Matcher A matcher function, will be called with path to a file.\n *\n * Should return truthy if the file should be hooked, falsy otherwise.\n * @param {string} path\n * @returns {boolean}\n */\n\n/**\n * @callback RevertFunction Reverts the hook when called.\n * @returns {void}\n */\n\n/**\n * @typedef {object} Options\n * @property {Matcher|null} [matcher=null] A matcher function, will be called with path to a file.\n *\n * Should return truthy if the file should be hooked, falsy otherwise.\n *\n * @property {string[]} [extensions=['.js']] The extensions to hook. Should start with '.' (ex. ['.js']).\n * @property {string[]} [exts=['.js']] The extensions to hook. Should start with '.' (ex. ['.js']).\n *\n * @property {string[]} [extension=['.js']] The extensions to hook. Should start with '.' (ex. ['.js']).\n * @property {string[]} [ext=['.js']] The extensions to hook. Should start with '.' (ex. ['.js']).\n *\n * @property {boolean} [ignoreNodeModules=true] Auto-ignore node_modules. Independent of any matcher.\n */\n\n/**\n * Add a require hook.\n *\n * @param {Hook} hook The hook. Accepts the code of the module and the filename. Required.\n * @param {Options} [opts] Options\n * @returns {RevertFunction} The `revert` function. Reverts the hook when called.\n */\n\n\nfunction addHook(hook, opts = {}) {\n  let reverted = false;\n  const loaders = [];\n  const oldLoaders = [];\n  let exts; // We need to do this to fix #15. Basically, if you use a non-standard extension (ie. .jsx), then\n  // We modify the .js loader, then use the modified .js loader for as the base for .jsx.\n  // This prevents that.\n\n  const originalJSLoader = Module._extensions['.js'];\n  const matcher = opts.matcher || null;\n  const ignoreNodeModules = opts.ignoreNodeModules !== false;\n  exts = opts.extensions || opts.exts || opts.extension || opts.ext || ['.js'];\n\n  if (!Array.isArray(exts)) {\n    exts = [exts];\n  }\n\n  exts.forEach(ext => {\n    if (typeof ext !== 'string') {\n      throw new TypeError(`Invalid Extension: ${ext}`);\n    }\n\n    const oldLoader = Module._extensions[ext] || originalJSLoader;\n    oldLoaders[ext] = Module._extensions[ext];\n\n    loaders[ext] = Module._extensions[ext] = function newLoader(mod, filename) {\n      let compile;\n\n      if (!reverted) {\n        if (shouldCompile(filename, exts, matcher, ignoreNodeModules)) {\n          compile = mod._compile;\n\n          mod._compile = function _compile(code) {\n            // reset the compile immediately as otherwise we end up having the\n            // compile function being changed even though this loader might be reverted\n            // Not reverting it here leads to long useless compile chains when doing\n            // addHook -> revert -> addHook -> revert -> ...\n            // The compile function is also anyway created new when the loader is called a second time.\n            mod._compile = compile;\n            const newCode = hook(code, filename);\n\n            if (typeof newCode !== 'string') {\n              throw new Error(HOOK_RETURNED_NOTHING_ERROR_MESSAGE);\n            }\n\n            return mod._compile(newCode, filename);\n          };\n        }\n      }\n\n      oldLoader(mod, filename);\n    };\n  });\n  return function revert() {\n    if (reverted) return;\n    reverted = true;\n    exts.forEach(ext => {\n      // if the current loader for the extension is our loader then unregister it and set the oldLoader again\n      // if not we can not do anything as we cannot remove a loader from within the loader-chain\n      if (Module._extensions[ext] === loaders[ext]) {\n        if (!oldLoaders[ext]) {\n          delete Module._extensions[ext];\n        } else {\n          Module._extensions[ext] = oldLoaders[ext];\n        }\n      }\n    });\n  };\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}