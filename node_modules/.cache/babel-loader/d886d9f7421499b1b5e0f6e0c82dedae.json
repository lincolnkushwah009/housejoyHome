{"ast":null,"code":"'use strict';\n\nconst os = require('os');\n\nconst onExit = require('signal-exit');\n\nconst DEFAULT_FORCE_KILL_TIMEOUT = 1000 * 5; // Monkey-patches `childProcess.kill()` to add `forceKillAfterTimeout` behavior\n\nconst spawnedKill = function (kill) {\n  let signal = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'SIGTERM';\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const killResult = kill(signal);\n  setKillTimeout(kill, signal, options, killResult);\n  return killResult;\n};\n\nconst setKillTimeout = (kill, signal, options, killResult) => {\n  if (!shouldForceKill(signal, options, killResult)) {\n    return;\n  }\n\n  const timeout = getForceKillAfterTimeout(options);\n  const t = setTimeout(() => {\n    kill('SIGKILL');\n  }, timeout); // Guarded because there's no `.unref()` when `execa` is used in the renderer\n  // process in Electron. This cannot be tested since we don't run tests in\n  // Electron.\n  // istanbul ignore else\n\n  if (t.unref) {\n    t.unref();\n  }\n};\n\nconst shouldForceKill = (signal, _ref, killResult) => {\n  let {\n    forceKillAfterTimeout\n  } = _ref;\n  return isSigterm(signal) && forceKillAfterTimeout !== false && killResult;\n};\n\nconst isSigterm = signal => {\n  return signal === os.constants.signals.SIGTERM || typeof signal === 'string' && signal.toUpperCase() === 'SIGTERM';\n};\n\nconst getForceKillAfterTimeout = _ref2 => {\n  let {\n    forceKillAfterTimeout = true\n  } = _ref2;\n\n  if (forceKillAfterTimeout === true) {\n    return DEFAULT_FORCE_KILL_TIMEOUT;\n  }\n\n  if (!Number.isFinite(forceKillAfterTimeout) || forceKillAfterTimeout < 0) {\n    throw new TypeError(`Expected the \\`forceKillAfterTimeout\\` option to be a non-negative integer, got \\`${forceKillAfterTimeout}\\` (${typeof forceKillAfterTimeout})`);\n  }\n\n  return forceKillAfterTimeout;\n}; // `childProcess.cancel()`\n\n\nconst spawnedCancel = (spawned, context) => {\n  const killResult = spawned.kill();\n\n  if (killResult) {\n    context.isCanceled = true;\n  }\n};\n\nconst timeoutKill = (spawned, signal, reject) => {\n  spawned.kill(signal);\n  reject(Object.assign(new Error('Timed out'), {\n    timedOut: true,\n    signal\n  }));\n}; // `timeout` option handling\n\n\nconst setupTimeout = (spawned, _ref3, spawnedPromise) => {\n  let {\n    timeout,\n    killSignal = 'SIGTERM'\n  } = _ref3;\n\n  if (timeout === 0 || timeout === undefined) {\n    return spawnedPromise;\n  }\n\n  let timeoutId;\n  const timeoutPromise = new Promise((resolve, reject) => {\n    timeoutId = setTimeout(() => {\n      timeoutKill(spawned, killSignal, reject);\n    }, timeout);\n  });\n  const safeSpawnedPromise = spawnedPromise.finally(() => {\n    clearTimeout(timeoutId);\n  });\n  return Promise.race([timeoutPromise, safeSpawnedPromise]);\n};\n\nconst validateTimeout = _ref4 => {\n  let {\n    timeout\n  } = _ref4;\n\n  if (timeout !== undefined && (!Number.isFinite(timeout) || timeout < 0)) {\n    throw new TypeError(`Expected the \\`timeout\\` option to be a non-negative integer, got \\`${timeout}\\` (${typeof timeout})`);\n  }\n}; // `cleanup` option handling\n\n\nconst setExitHandler = async (spawned, _ref5, timedPromise) => {\n  let {\n    cleanup,\n    detached\n  } = _ref5;\n\n  if (!cleanup || detached) {\n    return timedPromise;\n  }\n\n  const removeExitHandler = onExit(() => {\n    spawned.kill();\n  });\n  return timedPromise.finally(() => {\n    removeExitHandler();\n  });\n};\n\nmodule.exports = {\n  spawnedKill,\n  spawnedCancel,\n  setupTimeout,\n  validateTimeout,\n  setExitHandler\n};","map":{"version":3,"names":["os","require","onExit","DEFAULT_FORCE_KILL_TIMEOUT","spawnedKill","kill","signal","options","killResult","setKillTimeout","shouldForceKill","timeout","getForceKillAfterTimeout","t","setTimeout","unref","forceKillAfterTimeout","isSigterm","constants","signals","SIGTERM","toUpperCase","Number","isFinite","TypeError","spawnedCancel","spawned","context","isCanceled","timeoutKill","reject","Object","assign","Error","timedOut","setupTimeout","spawnedPromise","killSignal","undefined","timeoutId","timeoutPromise","Promise","resolve","safeSpawnedPromise","finally","clearTimeout","race","validateTimeout","setExitHandler","timedPromise","cleanup","detached","removeExitHandler","module","exports"],"sources":["/Users/lincolnkushwah/Desktop/All/React Projects/house_joy_new/node_modules/execa/lib/kill.js"],"sourcesContent":["'use strict';\nconst os = require('os');\nconst onExit = require('signal-exit');\n\nconst DEFAULT_FORCE_KILL_TIMEOUT = 1000 * 5;\n\n// Monkey-patches `childProcess.kill()` to add `forceKillAfterTimeout` behavior\nconst spawnedKill = (kill, signal = 'SIGTERM', options = {}) => {\n\tconst killResult = kill(signal);\n\tsetKillTimeout(kill, signal, options, killResult);\n\treturn killResult;\n};\n\nconst setKillTimeout = (kill, signal, options, killResult) => {\n\tif (!shouldForceKill(signal, options, killResult)) {\n\t\treturn;\n\t}\n\n\tconst timeout = getForceKillAfterTimeout(options);\n\tconst t = setTimeout(() => {\n\t\tkill('SIGKILL');\n\t}, timeout);\n\n\t// Guarded because there's no `.unref()` when `execa` is used in the renderer\n\t// process in Electron. This cannot be tested since we don't run tests in\n\t// Electron.\n\t// istanbul ignore else\n\tif (t.unref) {\n\t\tt.unref();\n\t}\n};\n\nconst shouldForceKill = (signal, {forceKillAfterTimeout}, killResult) => {\n\treturn isSigterm(signal) && forceKillAfterTimeout !== false && killResult;\n};\n\nconst isSigterm = signal => {\n\treturn signal === os.constants.signals.SIGTERM ||\n\t\t(typeof signal === 'string' && signal.toUpperCase() === 'SIGTERM');\n};\n\nconst getForceKillAfterTimeout = ({forceKillAfterTimeout = true}) => {\n\tif (forceKillAfterTimeout === true) {\n\t\treturn DEFAULT_FORCE_KILL_TIMEOUT;\n\t}\n\n\tif (!Number.isFinite(forceKillAfterTimeout) || forceKillAfterTimeout < 0) {\n\t\tthrow new TypeError(`Expected the \\`forceKillAfterTimeout\\` option to be a non-negative integer, got \\`${forceKillAfterTimeout}\\` (${typeof forceKillAfterTimeout})`);\n\t}\n\n\treturn forceKillAfterTimeout;\n};\n\n// `childProcess.cancel()`\nconst spawnedCancel = (spawned, context) => {\n\tconst killResult = spawned.kill();\n\n\tif (killResult) {\n\t\tcontext.isCanceled = true;\n\t}\n};\n\nconst timeoutKill = (spawned, signal, reject) => {\n\tspawned.kill(signal);\n\treject(Object.assign(new Error('Timed out'), {timedOut: true, signal}));\n};\n\n// `timeout` option handling\nconst setupTimeout = (spawned, {timeout, killSignal = 'SIGTERM'}, spawnedPromise) => {\n\tif (timeout === 0 || timeout === undefined) {\n\t\treturn spawnedPromise;\n\t}\n\n\tlet timeoutId;\n\tconst timeoutPromise = new Promise((resolve, reject) => {\n\t\ttimeoutId = setTimeout(() => {\n\t\t\ttimeoutKill(spawned, killSignal, reject);\n\t\t}, timeout);\n\t});\n\n\tconst safeSpawnedPromise = spawnedPromise.finally(() => {\n\t\tclearTimeout(timeoutId);\n\t});\n\n\treturn Promise.race([timeoutPromise, safeSpawnedPromise]);\n};\n\nconst validateTimeout = ({timeout}) => {\n\tif (timeout !== undefined && (!Number.isFinite(timeout) || timeout < 0)) {\n\t\tthrow new TypeError(`Expected the \\`timeout\\` option to be a non-negative integer, got \\`${timeout}\\` (${typeof timeout})`);\n\t}\n};\n\n// `cleanup` option handling\nconst setExitHandler = async (spawned, {cleanup, detached}, timedPromise) => {\n\tif (!cleanup || detached) {\n\t\treturn timedPromise;\n\t}\n\n\tconst removeExitHandler = onExit(() => {\n\t\tspawned.kill();\n\t});\n\n\treturn timedPromise.finally(() => {\n\t\tremoveExitHandler();\n\t});\n};\n\nmodule.exports = {\n\tspawnedKill,\n\tspawnedCancel,\n\tsetupTimeout,\n\tvalidateTimeout,\n\tsetExitHandler\n};\n"],"mappings":"AAAA;;AACA,MAAMA,EAAE,GAAGC,OAAO,CAAC,IAAD,CAAlB;;AACA,MAAMC,MAAM,GAAGD,OAAO,CAAC,aAAD,CAAtB;;AAEA,MAAME,0BAA0B,GAAG,OAAO,CAA1C,C,CAEA;;AACA,MAAMC,WAAW,GAAG,UAACC,IAAD,EAA4C;EAAA,IAArCC,MAAqC,uEAA5B,SAA4B;EAAA,IAAjBC,OAAiB,uEAAP,EAAO;EAC/D,MAAMC,UAAU,GAAGH,IAAI,CAACC,MAAD,CAAvB;EACAG,cAAc,CAACJ,IAAD,EAAOC,MAAP,EAAeC,OAAf,EAAwBC,UAAxB,CAAd;EACA,OAAOA,UAAP;AACA,CAJD;;AAMA,MAAMC,cAAc,GAAG,CAACJ,IAAD,EAAOC,MAAP,EAAeC,OAAf,EAAwBC,UAAxB,KAAuC;EAC7D,IAAI,CAACE,eAAe,CAACJ,MAAD,EAASC,OAAT,EAAkBC,UAAlB,CAApB,EAAmD;IAClD;EACA;;EAED,MAAMG,OAAO,GAAGC,wBAAwB,CAACL,OAAD,CAAxC;EACA,MAAMM,CAAC,GAAGC,UAAU,CAAC,MAAM;IAC1BT,IAAI,CAAC,SAAD,CAAJ;EACA,CAFmB,EAEjBM,OAFiB,CAApB,CAN6D,CAU7D;EACA;EACA;EACA;;EACA,IAAIE,CAAC,CAACE,KAAN,EAAa;IACZF,CAAC,CAACE,KAAF;EACA;AACD,CAjBD;;AAmBA,MAAML,eAAe,GAAG,CAACJ,MAAD,QAAkCE,UAAlC,KAAiD;EAAA,IAAxC;IAACQ;EAAD,CAAwC;EACxE,OAAOC,SAAS,CAACX,MAAD,CAAT,IAAqBU,qBAAqB,KAAK,KAA/C,IAAwDR,UAA/D;AACA,CAFD;;AAIA,MAAMS,SAAS,GAAGX,MAAM,IAAI;EAC3B,OAAOA,MAAM,KAAKN,EAAE,CAACkB,SAAH,CAAaC,OAAb,CAAqBC,OAAhC,IACL,OAAOd,MAAP,KAAkB,QAAlB,IAA8BA,MAAM,CAACe,WAAP,OAAyB,SADzD;AAEA,CAHD;;AAKA,MAAMT,wBAAwB,GAAG,SAAoC;EAAA,IAAnC;IAACI,qBAAqB,GAAG;EAAzB,CAAmC;;EACpE,IAAIA,qBAAqB,KAAK,IAA9B,EAAoC;IACnC,OAAOb,0BAAP;EACA;;EAED,IAAI,CAACmB,MAAM,CAACC,QAAP,CAAgBP,qBAAhB,CAAD,IAA2CA,qBAAqB,GAAG,CAAvE,EAA0E;IACzE,MAAM,IAAIQ,SAAJ,CAAe,qFAAoFR,qBAAsB,OAAM,OAAOA,qBAAsB,GAA5J,CAAN;EACA;;EAED,OAAOA,qBAAP;AACA,CAVD,C,CAYA;;;AACA,MAAMS,aAAa,GAAG,CAACC,OAAD,EAAUC,OAAV,KAAsB;EAC3C,MAAMnB,UAAU,GAAGkB,OAAO,CAACrB,IAAR,EAAnB;;EAEA,IAAIG,UAAJ,EAAgB;IACfmB,OAAO,CAACC,UAAR,GAAqB,IAArB;EACA;AACD,CAND;;AAQA,MAAMC,WAAW,GAAG,CAACH,OAAD,EAAUpB,MAAV,EAAkBwB,MAAlB,KAA6B;EAChDJ,OAAO,CAACrB,IAAR,CAAaC,MAAb;EACAwB,MAAM,CAACC,MAAM,CAACC,MAAP,CAAc,IAAIC,KAAJ,CAAU,WAAV,CAAd,EAAsC;IAACC,QAAQ,EAAE,IAAX;IAAiB5B;EAAjB,CAAtC,CAAD,CAAN;AACA,CAHD,C,CAKA;;;AACA,MAAM6B,YAAY,GAAG,CAACT,OAAD,SAA6CU,cAA7C,KAAgE;EAAA,IAAtD;IAACzB,OAAD;IAAU0B,UAAU,GAAG;EAAvB,CAAsD;;EACpF,IAAI1B,OAAO,KAAK,CAAZ,IAAiBA,OAAO,KAAK2B,SAAjC,EAA4C;IAC3C,OAAOF,cAAP;EACA;;EAED,IAAIG,SAAJ;EACA,MAAMC,cAAc,GAAG,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUZ,MAAV,KAAqB;IACvDS,SAAS,GAAGzB,UAAU,CAAC,MAAM;MAC5Be,WAAW,CAACH,OAAD,EAAUW,UAAV,EAAsBP,MAAtB,CAAX;IACA,CAFqB,EAEnBnB,OAFmB,CAAtB;EAGA,CAJsB,CAAvB;EAMA,MAAMgC,kBAAkB,GAAGP,cAAc,CAACQ,OAAf,CAAuB,MAAM;IACvDC,YAAY,CAACN,SAAD,CAAZ;EACA,CAF0B,CAA3B;EAIA,OAAOE,OAAO,CAACK,IAAR,CAAa,CAACN,cAAD,EAAiBG,kBAAjB,CAAb,CAAP;AACA,CAjBD;;AAmBA,MAAMI,eAAe,GAAG,SAAe;EAAA,IAAd;IAACpC;EAAD,CAAc;;EACtC,IAAIA,OAAO,KAAK2B,SAAZ,KAA0B,CAAChB,MAAM,CAACC,QAAP,CAAgBZ,OAAhB,CAAD,IAA6BA,OAAO,GAAG,CAAjE,CAAJ,EAAyE;IACxE,MAAM,IAAIa,SAAJ,CAAe,uEAAsEb,OAAQ,OAAM,OAAOA,OAAQ,GAAlH,CAAN;EACA;AACD,CAJD,C,CAMA;;;AACA,MAAMqC,cAAc,GAAG,OAAOtB,OAAP,SAAqCuB,YAArC,KAAsD;EAAA,IAAtC;IAACC,OAAD;IAAUC;EAAV,CAAsC;;EAC5E,IAAI,CAACD,OAAD,IAAYC,QAAhB,EAA0B;IACzB,OAAOF,YAAP;EACA;;EAED,MAAMG,iBAAiB,GAAGlD,MAAM,CAAC,MAAM;IACtCwB,OAAO,CAACrB,IAAR;EACA,CAF+B,CAAhC;EAIA,OAAO4C,YAAY,CAACL,OAAb,CAAqB,MAAM;IACjCQ,iBAAiB;EACjB,CAFM,CAAP;AAGA,CAZD;;AAcAC,MAAM,CAACC,OAAP,GAAiB;EAChBlD,WADgB;EAEhBqB,aAFgB;EAGhBU,YAHgB;EAIhBY,eAJgB;EAKhBC;AALgB,CAAjB"},"metadata":{},"sourceType":"script"}