{"ast":null,"code":"/* -*- Mode: js; js-indent-level: 2; -*- */\n\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\nconst util = require(\"./util\");\n\nconst binarySearch = require(\"./binary-search\");\n\nconst ArraySet = require(\"./array-set\").ArraySet;\n\nconst base64VLQ = require(\"./base64-vlq\"); // eslint-disable-line no-unused-vars\n\n\nconst readWasm = require(\"../lib/read-wasm\");\n\nconst wasm = require(\"./wasm\");\n\nconst INTERNAL = Symbol(\"smcInternal\");\n\nclass SourceMapConsumer {\n  constructor(aSourceMap, aSourceMapURL) {\n    // If the constructor was called by super(), just return Promise<this>.\n    // Yes, this is a hack to retain the pre-existing API of the base-class\n    // constructor also being an async factory function.\n    if (aSourceMap == INTERNAL) {\n      return Promise.resolve(this);\n    }\n\n    return _factory(aSourceMap, aSourceMapURL);\n  }\n\n  static initialize(opts) {\n    readWasm.initialize(opts[\"lib/mappings.wasm\"]);\n  }\n\n  static fromSourceMap(aSourceMap, aSourceMapURL) {\n    return _factoryBSM(aSourceMap, aSourceMapURL);\n  }\n  /**\n   * Construct a new `SourceMapConsumer` from `rawSourceMap` and `sourceMapUrl`\n   * (see the `SourceMapConsumer` constructor for details. Then, invoke the `async\n   * function f(SourceMapConsumer) -> T` with the newly constructed consumer, wait\n   * for `f` to complete, call `destroy` on the consumer, and return `f`'s return\n   * value.\n   *\n   * You must not use the consumer after `f` completes!\n   *\n   * By using `with`, you do not have to remember to manually call `destroy` on\n   * the consumer, since it will be called automatically once `f` completes.\n   *\n   * ```js\n   * const xSquared = await SourceMapConsumer.with(\n   *   myRawSourceMap,\n   *   null,\n   *   async function (consumer) {\n   *     // Use `consumer` inside here and don't worry about remembering\n   *     // to call `destroy`.\n   *\n   *     const x = await whatever(consumer);\n   *     return x * x;\n   *   }\n   * );\n   *\n   * // You may not use that `consumer` anymore out here; it has\n   * // been destroyed. But you can use `xSquared`.\n   * console.log(xSquared);\n   * ```\n   */\n\n\n  static async with(rawSourceMap, sourceMapUrl, f) {\n    const consumer = await new SourceMapConsumer(rawSourceMap, sourceMapUrl);\n\n    try {\n      return await f(consumer);\n    } finally {\n      consumer.destroy();\n    }\n  }\n  /**\n   * Parse the mappings in a string in to a data structure which we can easily\n   * query (the ordered arrays in the `this.__generatedMappings` and\n   * `this.__originalMappings` properties).\n   */\n\n\n  _parseMappings(aStr, aSourceRoot) {\n    throw new Error(\"Subclasses must implement _parseMappings\");\n  }\n  /**\n   * Iterate over each mapping between an original source/line/column and a\n   * generated line/column in this source map.\n   *\n   * @param Function aCallback\n   *        The function that is called with each mapping.\n   * @param Object aContext\n   *        Optional. If specified, this object will be the value of `this` every\n   *        time that `aCallback` is called.\n   * @param aOrder\n   *        Either `SourceMapConsumer.GENERATED_ORDER` or\n   *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to\n   *        iterate over the mappings sorted by the generated file's line/column\n   *        order or the original's source/line/column order, respectively. Defaults to\n   *        `SourceMapConsumer.GENERATED_ORDER`.\n   */\n\n\n  eachMapping(aCallback, aContext, aOrder) {\n    throw new Error(\"Subclasses must implement eachMapping\");\n  }\n  /**\n   * Returns all generated line and column information for the original source,\n   * line, and column provided. If no column is provided, returns all mappings\n   * corresponding to a either the line we are searching for or the next\n   * closest line that has any mappings. Otherwise, returns all mappings\n   * corresponding to the given line and either the column we are searching for\n   * or the next closest column that has any offsets.\n   *\n   * The only argument is an object with the following properties:\n   *\n   *   - source: The filename of the original source.\n   *   - line: The line number in the original source.  The line number is 1-based.\n   *   - column: Optional. the column number in the original source.\n   *    The column number is 0-based.\n   *\n   * and an array of objects is returned, each with the following properties:\n   *\n   *   - line: The line number in the generated source, or null.  The\n   *    line number is 1-based.\n   *   - column: The column number in the generated source, or null.\n   *    The column number is 0-based.\n   */\n\n\n  allGeneratedPositionsFor(aArgs) {\n    throw new Error(\"Subclasses must implement allGeneratedPositionsFor\");\n  }\n\n  destroy() {\n    throw new Error(\"Subclasses must implement destroy\");\n  }\n\n}\n/**\n * The version of the source mapping spec that we are consuming.\n */\n\n\nSourceMapConsumer.prototype._version = 3;\nSourceMapConsumer.GENERATED_ORDER = 1;\nSourceMapConsumer.ORIGINAL_ORDER = 2;\nSourceMapConsumer.GREATEST_LOWER_BOUND = 1;\nSourceMapConsumer.LEAST_UPPER_BOUND = 2;\nexports.SourceMapConsumer = SourceMapConsumer;\n/**\n * A BasicSourceMapConsumer instance represents a parsed source map which we can\n * query for information about the original file positions by giving it a file\n * position in the generated source.\n *\n * The first parameter is the raw source map (either as a JSON string, or\n * already parsed to an object). According to the spec, source maps have the\n * following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - sources: An array of URLs to the original source files.\n *   - names: An array of identifiers which can be referenced by individual mappings.\n *   - sourceRoot: Optional. The URL root from which all sources are relative.\n *   - sourcesContent: Optional. An array of contents of the original source files.\n *   - mappings: A string of base64 VLQs which contain the actual mappings.\n *   - file: Optional. The generated file this source map is associated with.\n *\n * Here is an example source map, taken from the source map spec[0]:\n *\n *     {\n *       version : 3,\n *       file: \"out.js\",\n *       sourceRoot : \"\",\n *       sources: [\"foo.js\", \"bar.js\"],\n *       names: [\"src\", \"maps\", \"are\", \"fun\"],\n *       mappings: \"AA,AB;;ABCDE;\"\n *     }\n *\n * The second parameter, if given, is a string whose value is the URL\n * at which the source map was found.  This URL is used to compute the\n * sources array.\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#\n */\n\nclass BasicSourceMapConsumer extends SourceMapConsumer {\n  constructor(aSourceMap, aSourceMapURL) {\n    return super(INTERNAL).then(that => {\n      let sourceMap = aSourceMap;\n\n      if (typeof aSourceMap === \"string\") {\n        sourceMap = util.parseSourceMapInput(aSourceMap);\n      }\n\n      const version = util.getArg(sourceMap, \"version\");\n      let sources = util.getArg(sourceMap, \"sources\"); // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which\n      // requires the array) to play nice here.\n\n      const names = util.getArg(sourceMap, \"names\", []);\n      let sourceRoot = util.getArg(sourceMap, \"sourceRoot\", null);\n      const sourcesContent = util.getArg(sourceMap, \"sourcesContent\", null);\n      const mappings = util.getArg(sourceMap, \"mappings\");\n      const file = util.getArg(sourceMap, \"file\", null); // Once again, Sass deviates from the spec and supplies the version as a\n      // string rather than a number, so we use loose equality checking here.\n\n      if (version != that._version) {\n        throw new Error(\"Unsupported version: \" + version);\n      }\n\n      if (sourceRoot) {\n        sourceRoot = util.normalize(sourceRoot);\n      }\n\n      sources = sources.map(String) // Some source maps produce relative source paths like \"./foo.js\" instead of\n      // \"foo.js\".  Normalize these first so that future comparisons will succeed.\n      // See bugzil.la/1090768.\n      .map(util.normalize) // Always ensure that absolute sources are internally stored relative to\n      // the source root, if the source root is absolute. Not doing this would\n      // be particularly problematic when the source root is a prefix of the\n      // source (valid, but why??). See github issue #199 and bugzil.la/1188982.\n      .map(function (source) {\n        return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;\n      }); // Pass `true` below to allow duplicate names and sources. While source maps\n      // are intended to be compressed and deduplicated, the TypeScript compiler\n      // sometimes generates source maps with duplicates in them. See Github issue\n      // #72 and bugzil.la/889492.\n\n      that._names = ArraySet.fromArray(names.map(String), true);\n      that._sources = ArraySet.fromArray(sources, true);\n      that._absoluteSources = that._sources.toArray().map(function (s) {\n        return util.computeSourceURL(sourceRoot, s, aSourceMapURL);\n      });\n      that.sourceRoot = sourceRoot;\n      that.sourcesContent = sourcesContent;\n      that._mappings = mappings;\n      that._sourceMapURL = aSourceMapURL;\n      that.file = file;\n      that._computedColumnSpans = false;\n      that._mappingsPtr = 0;\n      that._wasm = null;\n      return wasm().then(w => {\n        that._wasm = w;\n        return that;\n      });\n    });\n  }\n  /**\n   * Utility function to find the index of a source.  Returns -1 if not\n   * found.\n   */\n\n\n  _findSourceIndex(aSource) {\n    let relativeSource = aSource;\n\n    if (this.sourceRoot != null) {\n      relativeSource = util.relative(this.sourceRoot, relativeSource);\n    }\n\n    if (this._sources.has(relativeSource)) {\n      return this._sources.indexOf(relativeSource);\n    } // Maybe aSource is an absolute URL as returned by |sources|.  In\n    // this case we can't simply undo the transform.\n\n\n    for (let i = 0; i < this._absoluteSources.length; ++i) {\n      if (this._absoluteSources[i] == aSource) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n  /**\n   * Create a BasicSourceMapConsumer from a SourceMapGenerator.\n   *\n   * @param SourceMapGenerator aSourceMap\n   *        The source map that will be consumed.\n   * @param String aSourceMapURL\n   *        The URL at which the source map can be found (optional)\n   * @returns BasicSourceMapConsumer\n   */\n\n\n  static fromSourceMap(aSourceMap, aSourceMapURL) {\n    return new BasicSourceMapConsumer(aSourceMap.toString());\n  }\n\n  get sources() {\n    return this._absoluteSources.slice();\n  }\n\n  _getMappingsPtr() {\n    if (this._mappingsPtr === 0) {\n      this._parseMappings(this._mappings, this.sourceRoot);\n    }\n\n    return this._mappingsPtr;\n  }\n  /**\n   * Parse the mappings in a string in to a data structure which we can easily\n   * query (the ordered arrays in the `this.__generatedMappings` and\n   * `this.__originalMappings` properties).\n   */\n\n\n  _parseMappings(aStr, aSourceRoot) {\n    const size = aStr.length;\n\n    const mappingsBufPtr = this._wasm.exports.allocate_mappings(size);\n\n    const mappingsBuf = new Uint8Array(this._wasm.exports.memory.buffer, mappingsBufPtr, size);\n\n    for (let i = 0; i < size; i++) {\n      mappingsBuf[i] = aStr.charCodeAt(i);\n    }\n\n    const mappingsPtr = this._wasm.exports.parse_mappings(mappingsBufPtr);\n\n    if (!mappingsPtr) {\n      const error = this._wasm.exports.get_last_error();\n\n      let msg = `Error parsing mappings (code ${error}): `; // XXX: keep these error codes in sync with `fitzgen/source-map-mappings`.\n\n      switch (error) {\n        case 1:\n          msg += \"the mappings contained a negative line, column, source index, or name index\";\n          break;\n\n        case 2:\n          msg += \"the mappings contained a number larger than 2**32\";\n          break;\n\n        case 3:\n          msg += \"reached EOF while in the middle of parsing a VLQ\";\n          break;\n\n        case 4:\n          msg += \"invalid base 64 character while parsing a VLQ\";\n          break;\n\n        default:\n          msg += \"unknown error code\";\n          break;\n      }\n\n      throw new Error(msg);\n    }\n\n    this._mappingsPtr = mappingsPtr;\n  }\n\n  eachMapping(aCallback, aContext, aOrder) {\n    const context = aContext || null;\n    const order = aOrder || SourceMapConsumer.GENERATED_ORDER;\n    const sourceRoot = this.sourceRoot;\n\n    this._wasm.withMappingCallback(mapping => {\n      if (mapping.source !== null) {\n        mapping.source = this._sources.at(mapping.source);\n        mapping.source = util.computeSourceURL(sourceRoot, mapping.source, this._sourceMapURL);\n\n        if (mapping.name !== null) {\n          mapping.name = this._names.at(mapping.name);\n        }\n      }\n\n      aCallback.call(context, mapping);\n    }, () => {\n      switch (order) {\n        case SourceMapConsumer.GENERATED_ORDER:\n          this._wasm.exports.by_generated_location(this._getMappingsPtr());\n\n          break;\n\n        case SourceMapConsumer.ORIGINAL_ORDER:\n          this._wasm.exports.by_original_location(this._getMappingsPtr());\n\n          break;\n\n        default:\n          throw new Error(\"Unknown order of iteration.\");\n      }\n    });\n  }\n\n  allGeneratedPositionsFor(aArgs) {\n    let source = util.getArg(aArgs, \"source\");\n    const originalLine = util.getArg(aArgs, \"line\");\n    const originalColumn = aArgs.column || 0;\n    source = this._findSourceIndex(source);\n\n    if (source < 0) {\n      return [];\n    }\n\n    if (originalLine < 1) {\n      throw new Error(\"Line numbers must be >= 1\");\n    }\n\n    if (originalColumn < 0) {\n      throw new Error(\"Column numbers must be >= 0\");\n    }\n\n    const mappings = [];\n\n    this._wasm.withMappingCallback(m => {\n      let lastColumn = m.lastGeneratedColumn;\n\n      if (this._computedColumnSpans && lastColumn === null) {\n        lastColumn = Infinity;\n      }\n\n      mappings.push({\n        line: m.generatedLine,\n        column: m.generatedColumn,\n        lastColumn\n      });\n    }, () => {\n      this._wasm.exports.all_generated_locations_for(this._getMappingsPtr(), source, originalLine - 1, \"column\" in aArgs, originalColumn);\n    });\n\n    return mappings;\n  }\n\n  destroy() {\n    if (this._mappingsPtr !== 0) {\n      this._wasm.exports.free_mappings(this._mappingsPtr);\n\n      this._mappingsPtr = 0;\n    }\n  }\n  /**\n   * Compute the last column for each generated mapping. The last column is\n   * inclusive.\n   */\n\n\n  computeColumnSpans() {\n    if (this._computedColumnSpans) {\n      return;\n    }\n\n    this._wasm.exports.compute_column_spans(this._getMappingsPtr());\n\n    this._computedColumnSpans = true;\n  }\n  /**\n   * Returns the original source, line, and column information for the generated\n   * source's line and column positions provided. The only argument is an object\n   * with the following properties:\n   *\n   *   - line: The line number in the generated source.  The line number\n   *     is 1-based.\n   *   - column: The column number in the generated source.  The column\n   *     number is 0-based.\n   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n   *     closest element that is smaller than or greater than the one we are\n   *     searching for, respectively, if the exact element cannot be found.\n   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n   *\n   * and an object is returned with the following properties:\n   *\n   *   - source: The original source file, or null.\n   *   - line: The line number in the original source, or null.  The\n   *     line number is 1-based.\n   *   - column: The column number in the original source, or null.  The\n   *     column number is 0-based.\n   *   - name: The original identifier, or null.\n   */\n\n\n  originalPositionFor(aArgs) {\n    const needle = {\n      generatedLine: util.getArg(aArgs, \"line\"),\n      generatedColumn: util.getArg(aArgs, \"column\")\n    };\n\n    if (needle.generatedLine < 1) {\n      throw new Error(\"Line numbers must be >= 1\");\n    }\n\n    if (needle.generatedColumn < 0) {\n      throw new Error(\"Column numbers must be >= 0\");\n    }\n\n    let bias = util.getArg(aArgs, \"bias\", SourceMapConsumer.GREATEST_LOWER_BOUND);\n\n    if (bias == null) {\n      bias = SourceMapConsumer.GREATEST_LOWER_BOUND;\n    }\n\n    let mapping;\n\n    this._wasm.withMappingCallback(m => mapping = m, () => {\n      this._wasm.exports.original_location_for(this._getMappingsPtr(), needle.generatedLine - 1, needle.generatedColumn, bias);\n    });\n\n    if (mapping) {\n      if (mapping.generatedLine === needle.generatedLine) {\n        let source = util.getArg(mapping, \"source\", null);\n\n        if (source !== null) {\n          source = this._sources.at(source);\n          source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);\n        }\n\n        let name = util.getArg(mapping, \"name\", null);\n\n        if (name !== null) {\n          name = this._names.at(name);\n        }\n\n        return {\n          source,\n          line: util.getArg(mapping, \"originalLine\", null),\n          column: util.getArg(mapping, \"originalColumn\", null),\n          name\n        };\n      }\n    }\n\n    return {\n      source: null,\n      line: null,\n      column: null,\n      name: null\n    };\n  }\n  /**\n   * Return true if we have the source content for every source in the source\n   * map, false otherwise.\n   */\n\n\n  hasContentsOfAllSources() {\n    if (!this.sourcesContent) {\n      return false;\n    }\n\n    return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function (sc) {\n      return sc == null;\n    });\n  }\n  /**\n   * Returns the original source content. The only argument is the url of the\n   * original source file. Returns null if no original source content is\n   * available.\n   */\n\n\n  sourceContentFor(aSource, nullOnMissing) {\n    if (!this.sourcesContent) {\n      return null;\n    }\n\n    const index = this._findSourceIndex(aSource);\n\n    if (index >= 0) {\n      return this.sourcesContent[index];\n    }\n\n    let relativeSource = aSource;\n\n    if (this.sourceRoot != null) {\n      relativeSource = util.relative(this.sourceRoot, relativeSource);\n    }\n\n    let url;\n\n    if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {\n      // XXX: file:// URIs and absolute paths lead to unexpected behavior for\n      // many users. We can help them out when they expect file:// URIs to\n      // behave like it would if they were running a local HTTP server. See\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.\n      const fileUriAbsPath = relativeSource.replace(/^file:\\/\\//, \"\");\n\n      if (url.scheme == \"file\" && this._sources.has(fileUriAbsPath)) {\n        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];\n      }\n\n      if ((!url.path || url.path == \"/\") && this._sources.has(\"/\" + relativeSource)) {\n        return this.sourcesContent[this._sources.indexOf(\"/\" + relativeSource)];\n      }\n    } // This function is used recursively from\n    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we\n    // don't want to throw if we can't find the source - we just want to\n    // return null, so we provide a flag to exit gracefully.\n\n\n    if (nullOnMissing) {\n      return null;\n    }\n\n    throw new Error('\"' + relativeSource + '\" is not in the SourceMap.');\n  }\n  /**\n   * Returns the generated line and column information for the original source,\n   * line, and column positions provided. The only argument is an object with\n   * the following properties:\n   *\n   *   - source: The filename of the original source.\n   *   - line: The line number in the original source.  The line number\n   *     is 1-based.\n   *   - column: The column number in the original source.  The column\n   *     number is 0-based.\n   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n   *     closest element that is smaller than or greater than the one we are\n   *     searching for, respectively, if the exact element cannot be found.\n   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n   *\n   * and an object is returned with the following properties:\n   *\n   *   - line: The line number in the generated source, or null.  The\n   *     line number is 1-based.\n   *   - column: The column number in the generated source, or null.\n   *     The column number is 0-based.\n   */\n\n\n  generatedPositionFor(aArgs) {\n    let source = util.getArg(aArgs, \"source\");\n    source = this._findSourceIndex(source);\n\n    if (source < 0) {\n      return {\n        line: null,\n        column: null,\n        lastColumn: null\n      };\n    }\n\n    const needle = {\n      source,\n      originalLine: util.getArg(aArgs, \"line\"),\n      originalColumn: util.getArg(aArgs, \"column\")\n    };\n\n    if (needle.originalLine < 1) {\n      throw new Error(\"Line numbers must be >= 1\");\n    }\n\n    if (needle.originalColumn < 0) {\n      throw new Error(\"Column numbers must be >= 0\");\n    }\n\n    let bias = util.getArg(aArgs, \"bias\", SourceMapConsumer.GREATEST_LOWER_BOUND);\n\n    if (bias == null) {\n      bias = SourceMapConsumer.GREATEST_LOWER_BOUND;\n    }\n\n    let mapping;\n\n    this._wasm.withMappingCallback(m => mapping = m, () => {\n      this._wasm.exports.generated_location_for(this._getMappingsPtr(), needle.source, needle.originalLine - 1, needle.originalColumn, bias);\n    });\n\n    if (mapping) {\n      if (mapping.source === needle.source) {\n        let lastColumn = mapping.lastGeneratedColumn;\n\n        if (this._computedColumnSpans && lastColumn === null) {\n          lastColumn = Infinity;\n        }\n\n        return {\n          line: util.getArg(mapping, \"generatedLine\", null),\n          column: util.getArg(mapping, \"generatedColumn\", null),\n          lastColumn\n        };\n      }\n    }\n\n    return {\n      line: null,\n      column: null,\n      lastColumn: null\n    };\n  }\n\n}\n\nBasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;\nexports.BasicSourceMapConsumer = BasicSourceMapConsumer;\n/**\n * An IndexedSourceMapConsumer instance represents a parsed source map which\n * we can query for information. It differs from BasicSourceMapConsumer in\n * that it takes \"indexed\" source maps (i.e. ones with a \"sections\" field) as\n * input.\n *\n * The first parameter is a raw source map (either as a JSON string, or already\n * parsed to an object). According to the spec for indexed source maps, they\n * have the following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - file: Optional. The generated file this source map is associated with.\n *   - sections: A list of section definitions.\n *\n * Each value under the \"sections\" field has two fields:\n *   - offset: The offset into the original specified at which this section\n *       begins to apply, defined as an object with a \"line\" and \"column\"\n *       field.\n *   - map: A source map definition. This source map could also be indexed,\n *       but doesn't have to be.\n *\n * Instead of the \"map\" field, it's also possible to have a \"url\" field\n * specifying a URL to retrieve a source map from, but that's currently\n * unsupported.\n *\n * Here's an example source map, taken from the source map spec[0], but\n * modified to omit a section which uses the \"url\" field.\n *\n *  {\n *    version : 3,\n *    file: \"app.js\",\n *    sections: [{\n *      offset: {line:100, column:10},\n *      map: {\n *        version : 3,\n *        file: \"section.js\",\n *        sources: [\"foo.js\", \"bar.js\"],\n *        names: [\"src\", \"maps\", \"are\", \"fun\"],\n *        mappings: \"AAAA,E;;ABCDE;\"\n *      }\n *    }],\n *  }\n *\n * The second parameter, if given, is a string whose value is the URL\n * at which the source map was found.  This URL is used to compute the\n * sources array.\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt\n */\n\nclass IndexedSourceMapConsumer extends SourceMapConsumer {\n  constructor(aSourceMap, aSourceMapURL) {\n    return super(INTERNAL).then(that => {\n      let sourceMap = aSourceMap;\n\n      if (typeof aSourceMap === \"string\") {\n        sourceMap = util.parseSourceMapInput(aSourceMap);\n      }\n\n      const version = util.getArg(sourceMap, \"version\");\n      const sections = util.getArg(sourceMap, \"sections\");\n\n      if (version != that._version) {\n        throw new Error(\"Unsupported version: \" + version);\n      }\n\n      that._sources = new ArraySet();\n      that._names = new ArraySet();\n      that.__generatedMappings = null;\n      that.__originalMappings = null;\n      that.__generatedMappingsUnsorted = null;\n      that.__originalMappingsUnsorted = null;\n      let lastOffset = {\n        line: -1,\n        column: 0\n      };\n      return Promise.all(sections.map(s => {\n        if (s.url) {\n          // The url field will require support for asynchronicity.\n          // See https://github.com/mozilla/source-map/issues/16\n          throw new Error(\"Support for url field in sections not implemented.\");\n        }\n\n        const offset = util.getArg(s, \"offset\");\n        const offsetLine = util.getArg(offset, \"line\");\n        const offsetColumn = util.getArg(offset, \"column\");\n\n        if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {\n          throw new Error(\"Section offsets must be ordered and non-overlapping.\");\n        }\n\n        lastOffset = offset;\n        const cons = new SourceMapConsumer(util.getArg(s, \"map\"), aSourceMapURL);\n        return cons.then(consumer => {\n          return {\n            generatedOffset: {\n              // The offset fields are 0-based, but we use 1-based indices when\n              // encoding/decoding from VLQ.\n              generatedLine: offsetLine + 1,\n              generatedColumn: offsetColumn + 1\n            },\n            consumer\n          };\n        });\n      })).then(s => {\n        that._sections = s;\n        return that;\n      });\n    });\n  } // `__generatedMappings` and `__originalMappings` are arrays that hold the\n  // parsed mapping coordinates from the source map's \"mappings\" attribute. They\n  // are lazily instantiated, accessed via the `_generatedMappings` and\n  // `_originalMappings` getters respectively, and we only parse the mappings\n  // and create these arrays once queried for a source location. We jump through\n  // these hoops because there can be many thousands of mappings, and parsing\n  // them is expensive, so we only want to do it if we must.\n  //\n  // Each object in the arrays is of the form:\n  //\n  //     {\n  //       generatedLine: The line number in the generated code,\n  //       generatedColumn: The column number in the generated code,\n  //       source: The path to the original source file that generated this\n  //               chunk of code,\n  //       originalLine: The line number in the original source that\n  //                     corresponds to this chunk of generated code,\n  //       originalColumn: The column number in the original source that\n  //                       corresponds to this chunk of generated code,\n  //       name: The name of the original symbol which generated this chunk of\n  //             code.\n  //     }\n  //\n  // All properties except for `generatedLine` and `generatedColumn` can be\n  // `null`.\n  //\n  // `_generatedMappings` is ordered by the generated positions.\n  //\n  // `_originalMappings` is ordered by the original positions.\n\n\n  get _generatedMappings() {\n    if (!this.__generatedMappings) {\n      this._sortGeneratedMappings();\n    }\n\n    return this.__generatedMappings;\n  }\n\n  get _originalMappings() {\n    if (!this.__originalMappings) {\n      this._sortOriginalMappings();\n    }\n\n    return this.__originalMappings;\n  }\n\n  get _generatedMappingsUnsorted() {\n    if (!this.__generatedMappingsUnsorted) {\n      this._parseMappings(this._mappings, this.sourceRoot);\n    }\n\n    return this.__generatedMappingsUnsorted;\n  }\n\n  get _originalMappingsUnsorted() {\n    if (!this.__originalMappingsUnsorted) {\n      this._parseMappings(this._mappings, this.sourceRoot);\n    }\n\n    return this.__originalMappingsUnsorted;\n  }\n\n  _sortGeneratedMappings() {\n    const mappings = this._generatedMappingsUnsorted;\n    mappings.sort(util.compareByGeneratedPositionsDeflated);\n    this.__generatedMappings = mappings;\n  }\n\n  _sortOriginalMappings() {\n    const mappings = this._originalMappingsUnsorted;\n    mappings.sort(util.compareByOriginalPositions);\n    this.__originalMappings = mappings;\n  }\n  /**\n   * The list of original sources.\n   */\n\n\n  get sources() {\n    const sources = [];\n\n    for (let i = 0; i < this._sections.length; i++) {\n      for (let j = 0; j < this._sections[i].consumer.sources.length; j++) {\n        sources.push(this._sections[i].consumer.sources[j]);\n      }\n    }\n\n    return sources;\n  }\n  /**\n   * Returns the original source, line, and column information for the generated\n   * source's line and column positions provided. The only argument is an object\n   * with the following properties:\n   *\n   *   - line: The line number in the generated source.  The line number\n   *     is 1-based.\n   *   - column: The column number in the generated source.  The column\n   *     number is 0-based.\n   *\n   * and an object is returned with the following properties:\n   *\n   *   - source: The original source file, or null.\n   *   - line: The line number in the original source, or null.  The\n   *     line number is 1-based.\n   *   - column: The column number in the original source, or null.  The\n   *     column number is 0-based.\n   *   - name: The original identifier, or null.\n   */\n\n\n  originalPositionFor(aArgs) {\n    const needle = {\n      generatedLine: util.getArg(aArgs, \"line\"),\n      generatedColumn: util.getArg(aArgs, \"column\")\n    }; // Find the section containing the generated position we're trying to map\n    // to an original position.\n\n    const sectionIndex = binarySearch.search(needle, this._sections, function (aNeedle, section) {\n      const cmp = aNeedle.generatedLine - section.generatedOffset.generatedLine;\n\n      if (cmp) {\n        return cmp;\n      }\n\n      return aNeedle.generatedColumn - section.generatedOffset.generatedColumn;\n    });\n    const section = this._sections[sectionIndex];\n\n    if (!section) {\n      return {\n        source: null,\n        line: null,\n        column: null,\n        name: null\n      };\n    }\n\n    return section.consumer.originalPositionFor({\n      line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),\n      column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),\n      bias: aArgs.bias\n    });\n  }\n  /**\n   * Return true if we have the source content for every source in the source\n   * map, false otherwise.\n   */\n\n\n  hasContentsOfAllSources() {\n    return this._sections.every(function (s) {\n      return s.consumer.hasContentsOfAllSources();\n    });\n  }\n  /**\n   * Returns the original source content. The only argument is the url of the\n   * original source file. Returns null if no original source content is\n   * available.\n   */\n\n\n  sourceContentFor(aSource, nullOnMissing) {\n    for (let i = 0; i < this._sections.length; i++) {\n      const section = this._sections[i];\n      const content = section.consumer.sourceContentFor(aSource, true);\n\n      if (content) {\n        return content;\n      }\n    }\n\n    if (nullOnMissing) {\n      return null;\n    }\n\n    throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n  }\n  /**\n   * Returns the generated line and column information for the original source,\n   * line, and column positions provided. The only argument is an object with\n   * the following properties:\n   *\n   *   - source: The filename of the original source.\n   *   - line: The line number in the original source.  The line number\n   *     is 1-based.\n   *   - column: The column number in the original source.  The column\n   *     number is 0-based.\n   *\n   * and an object is returned with the following properties:\n   *\n   *   - line: The line number in the generated source, or null.  The\n   *     line number is 1-based.\n   *   - column: The column number in the generated source, or null.\n   *     The column number is 0-based.\n   */\n\n\n  generatedPositionFor(aArgs) {\n    for (let i = 0; i < this._sections.length; i++) {\n      const section = this._sections[i]; // Only consider this section if the requested source is in the list of\n      // sources of the consumer.\n\n      if (section.consumer._findSourceIndex(util.getArg(aArgs, \"source\")) === -1) {\n        continue;\n      }\n\n      const generatedPosition = section.consumer.generatedPositionFor(aArgs);\n\n      if (generatedPosition) {\n        const ret = {\n          line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),\n          column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)\n        };\n        return ret;\n      }\n    }\n\n    return {\n      line: null,\n      column: null\n    };\n  }\n  /**\n   * Parse the mappings in a string in to a data structure which we can easily\n   * query (the ordered arrays in the `this.__generatedMappings` and\n   * `this.__originalMappings` properties).\n   */\n\n\n  _parseMappings(aStr, aSourceRoot) {\n    const generatedMappings = this.__generatedMappingsUnsorted = [];\n    const originalMappings = this.__originalMappingsUnsorted = [];\n\n    for (let i = 0; i < this._sections.length; i++) {\n      const section = this._sections[i];\n      const sectionMappings = [];\n      section.consumer.eachMapping(m => sectionMappings.push(m));\n\n      for (let j = 0; j < sectionMappings.length; j++) {\n        const mapping = sectionMappings[j]; // TODO: test if null is correct here.  The original code used\n        // `source`, which would actually have gotten used as null because\n        // var's get hoisted.\n        // See: https://github.com/mozilla/source-map/issues/333\n\n        let source = util.computeSourceURL(section.consumer.sourceRoot, null, this._sourceMapURL);\n\n        this._sources.add(source);\n\n        source = this._sources.indexOf(source);\n        let name = null;\n\n        if (mapping.name) {\n          this._names.add(mapping.name);\n\n          name = this._names.indexOf(mapping.name);\n        } // The mappings coming from the consumer for the section have\n        // generated positions relative to the start of the section, so we\n        // need to offset them to be relative to the start of the concatenated\n        // generated file.\n\n\n        const adjustedMapping = {\n          source,\n          generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),\n          generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),\n          originalLine: mapping.originalLine,\n          originalColumn: mapping.originalColumn,\n          name\n        };\n        generatedMappings.push(adjustedMapping);\n\n        if (typeof adjustedMapping.originalLine === \"number\") {\n          originalMappings.push(adjustedMapping);\n        }\n      }\n    }\n  }\n\n  eachMapping(aCallback, aContext, aOrder) {\n    const context = aContext || null;\n    const order = aOrder || SourceMapConsumer.GENERATED_ORDER;\n    let mappings;\n\n    switch (order) {\n      case SourceMapConsumer.GENERATED_ORDER:\n        mappings = this._generatedMappings;\n        break;\n\n      case SourceMapConsumer.ORIGINAL_ORDER:\n        mappings = this._originalMappings;\n        break;\n\n      default:\n        throw new Error(\"Unknown order of iteration.\");\n    }\n\n    const sourceRoot = this.sourceRoot;\n    mappings.map(function (mapping) {\n      let source = null;\n\n      if (mapping.source !== null) {\n        source = this._sources.at(mapping.source);\n        source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);\n      }\n\n      return {\n        source,\n        generatedLine: mapping.generatedLine,\n        generatedColumn: mapping.generatedColumn,\n        originalLine: mapping.originalLine,\n        originalColumn: mapping.originalColumn,\n        name: mapping.name === null ? null : this._names.at(mapping.name)\n      };\n    }, this).forEach(aCallback, context);\n  }\n  /**\n   * Find the mapping that best matches the hypothetical \"needle\" mapping that\n   * we are searching for in the given \"haystack\" of mappings.\n   */\n\n\n  _findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {\n    // To return the position we are searching for, we must first find the\n    // mapping for the given position and then return the opposite position it\n    // points to. Because the mappings are sorted, we can use binary search to\n    // find the best mapping.\n    if (aNeedle[aLineName] <= 0) {\n      throw new TypeError(\"Line must be greater than or equal to 1, got \" + aNeedle[aLineName]);\n    }\n\n    if (aNeedle[aColumnName] < 0) {\n      throw new TypeError(\"Column must be greater than or equal to 0, got \" + aNeedle[aColumnName]);\n    }\n\n    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);\n  }\n\n  allGeneratedPositionsFor(aArgs) {\n    const line = util.getArg(aArgs, \"line\"); // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping\n    // returns the index of the closest mapping less than the needle. By\n    // setting needle.originalColumn to 0, we thus find the last mapping for\n    // the given line, provided such a mapping exists.\n\n    const needle = {\n      source: util.getArg(aArgs, \"source\"),\n      originalLine: line,\n      originalColumn: util.getArg(aArgs, \"column\", 0)\n    };\n    needle.source = this._findSourceIndex(needle.source);\n\n    if (needle.source < 0) {\n      return [];\n    }\n\n    if (needle.originalLine < 1) {\n      throw new Error(\"Line numbers must be >= 1\");\n    }\n\n    if (needle.originalColumn < 0) {\n      throw new Error(\"Column numbers must be >= 0\");\n    }\n\n    const mappings = [];\n\n    let index = this._findMapping(needle, this._originalMappings, \"originalLine\", \"originalColumn\", util.compareByOriginalPositions, binarySearch.LEAST_UPPER_BOUND);\n\n    if (index >= 0) {\n      let mapping = this._originalMappings[index];\n\n      if (aArgs.column === undefined) {\n        const originalLine = mapping.originalLine; // Iterate until either we run out of mappings, or we run into\n        // a mapping for a different line than the one we found. Since\n        // mappings are sorted, this is guaranteed to find all mappings for\n        // the line we found.\n\n        while (mapping && mapping.originalLine === originalLine) {\n          let lastColumn = mapping.lastGeneratedColumn;\n\n          if (this._computedColumnSpans && lastColumn === null) {\n            lastColumn = Infinity;\n          }\n\n          mappings.push({\n            line: util.getArg(mapping, \"generatedLine\", null),\n            column: util.getArg(mapping, \"generatedColumn\", null),\n            lastColumn\n          });\n          mapping = this._originalMappings[++index];\n        }\n      } else {\n        const originalColumn = mapping.originalColumn; // Iterate until either we run out of mappings, or we run into\n        // a mapping for a different line than the one we were searching for.\n        // Since mappings are sorted, this is guaranteed to find all mappings for\n        // the line we are searching for.\n\n        while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {\n          let lastColumn = mapping.lastGeneratedColumn;\n\n          if (this._computedColumnSpans && lastColumn === null) {\n            lastColumn = Infinity;\n          }\n\n          mappings.push({\n            line: util.getArg(mapping, \"generatedLine\", null),\n            column: util.getArg(mapping, \"generatedColumn\", null),\n            lastColumn\n          });\n          mapping = this._originalMappings[++index];\n        }\n      }\n    }\n\n    return mappings;\n  }\n\n  destroy() {\n    for (let i = 0; i < this._sections.length; i++) {\n      this._sections[i].consumer.destroy();\n    }\n  }\n\n}\n\nexports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;\n/*\n * Cheat to get around inter-twingled classes.  `factory()` can be at the end\n * where it has access to non-hoisted classes, but it gets hoisted itself.\n */\n\nfunction _factory(aSourceMap, aSourceMapURL) {\n  let sourceMap = aSourceMap;\n\n  if (typeof aSourceMap === \"string\") {\n    sourceMap = util.parseSourceMapInput(aSourceMap);\n  }\n\n  const consumer = sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);\n  return Promise.resolve(consumer);\n}\n\nfunction _factoryBSM(aSourceMap, aSourceMapURL) {\n  return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);\n}","map":{"version":3,"names":["util","require","binarySearch","ArraySet","base64VLQ","readWasm","wasm","INTERNAL","Symbol","SourceMapConsumer","constructor","aSourceMap","aSourceMapURL","Promise","resolve","_factory","initialize","opts","fromSourceMap","_factoryBSM","with","rawSourceMap","sourceMapUrl","f","consumer","destroy","_parseMappings","aStr","aSourceRoot","Error","eachMapping","aCallback","aContext","aOrder","allGeneratedPositionsFor","aArgs","prototype","_version","GENERATED_ORDER","ORIGINAL_ORDER","GREATEST_LOWER_BOUND","LEAST_UPPER_BOUND","exports","BasicSourceMapConsumer","then","that","sourceMap","parseSourceMapInput","version","getArg","sources","names","sourceRoot","sourcesContent","mappings","file","normalize","map","String","source","isAbsolute","relative","_names","fromArray","_sources","_absoluteSources","toArray","s","computeSourceURL","_mappings","_sourceMapURL","_computedColumnSpans","_mappingsPtr","_wasm","w","_findSourceIndex","aSource","relativeSource","has","indexOf","i","length","toString","slice","_getMappingsPtr","size","mappingsBufPtr","allocate_mappings","mappingsBuf","Uint8Array","memory","buffer","charCodeAt","mappingsPtr","parse_mappings","error","get_last_error","msg","context","order","withMappingCallback","mapping","at","name","call","by_generated_location","by_original_location","originalLine","originalColumn","column","m","lastColumn","lastGeneratedColumn","Infinity","push","line","generatedLine","generatedColumn","all_generated_locations_for","free_mappings","computeColumnSpans","compute_column_spans","originalPositionFor","needle","bias","original_location_for","hasContentsOfAllSources","some","sc","sourceContentFor","nullOnMissing","index","url","urlParse","fileUriAbsPath","replace","scheme","path","generatedPositionFor","generated_location_for","IndexedSourceMapConsumer","sections","__generatedMappings","__originalMappings","__generatedMappingsUnsorted","__originalMappingsUnsorted","lastOffset","all","offset","offsetLine","offsetColumn","cons","generatedOffset","_sections","_generatedMappings","_sortGeneratedMappings","_originalMappings","_sortOriginalMappings","_generatedMappingsUnsorted","_originalMappingsUnsorted","sort","compareByGeneratedPositionsDeflated","compareByOriginalPositions","j","sectionIndex","search","aNeedle","section","cmp","every","content","generatedPosition","ret","generatedMappings","originalMappings","sectionMappings","add","adjustedMapping","forEach","_findMapping","aMappings","aLineName","aColumnName","aComparator","aBias","TypeError","undefined"],"sources":["/Users/lincolnkushwah/Desktop/All/React Projects/house_joy_new/node_modules/v8-to-istanbul/node_modules/source-map/lib/source-map-consumer.js"],"sourcesContent":["/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nconst util = require(\"./util\");\nconst binarySearch = require(\"./binary-search\");\nconst ArraySet = require(\"./array-set\").ArraySet;\nconst base64VLQ = require(\"./base64-vlq\"); // eslint-disable-line no-unused-vars\nconst readWasm = require(\"../lib/read-wasm\");\nconst wasm = require(\"./wasm\");\n\nconst INTERNAL = Symbol(\"smcInternal\");\n\nclass SourceMapConsumer {\n  constructor(aSourceMap, aSourceMapURL) {\n    // If the constructor was called by super(), just return Promise<this>.\n    // Yes, this is a hack to retain the pre-existing API of the base-class\n    // constructor also being an async factory function.\n    if (aSourceMap == INTERNAL) {\n      return Promise.resolve(this);\n    }\n\n    return _factory(aSourceMap, aSourceMapURL);\n  }\n\n  static initialize(opts) {\n    readWasm.initialize(opts[\"lib/mappings.wasm\"]);\n  }\n\n  static fromSourceMap(aSourceMap, aSourceMapURL) {\n    return _factoryBSM(aSourceMap, aSourceMapURL);\n  }\n\n  /**\n   * Construct a new `SourceMapConsumer` from `rawSourceMap` and `sourceMapUrl`\n   * (see the `SourceMapConsumer` constructor for details. Then, invoke the `async\n   * function f(SourceMapConsumer) -> T` with the newly constructed consumer, wait\n   * for `f` to complete, call `destroy` on the consumer, and return `f`'s return\n   * value.\n   *\n   * You must not use the consumer after `f` completes!\n   *\n   * By using `with`, you do not have to remember to manually call `destroy` on\n   * the consumer, since it will be called automatically once `f` completes.\n   *\n   * ```js\n   * const xSquared = await SourceMapConsumer.with(\n   *   myRawSourceMap,\n   *   null,\n   *   async function (consumer) {\n   *     // Use `consumer` inside here and don't worry about remembering\n   *     // to call `destroy`.\n   *\n   *     const x = await whatever(consumer);\n   *     return x * x;\n   *   }\n   * );\n   *\n   * // You may not use that `consumer` anymore out here; it has\n   * // been destroyed. But you can use `xSquared`.\n   * console.log(xSquared);\n   * ```\n   */\n  static async with(rawSourceMap, sourceMapUrl, f) {\n    const consumer = await new SourceMapConsumer(rawSourceMap, sourceMapUrl);\n    try {\n      return await f(consumer);\n    } finally {\n      consumer.destroy();\n    }\n  }\n\n  /**\n   * Parse the mappings in a string in to a data structure which we can easily\n   * query (the ordered arrays in the `this.__generatedMappings` and\n   * `this.__originalMappings` properties).\n   */\n  _parseMappings(aStr, aSourceRoot) {\n    throw new Error(\"Subclasses must implement _parseMappings\");\n  }\n\n  /**\n   * Iterate over each mapping between an original source/line/column and a\n   * generated line/column in this source map.\n   *\n   * @param Function aCallback\n   *        The function that is called with each mapping.\n   * @param Object aContext\n   *        Optional. If specified, this object will be the value of `this` every\n   *        time that `aCallback` is called.\n   * @param aOrder\n   *        Either `SourceMapConsumer.GENERATED_ORDER` or\n   *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to\n   *        iterate over the mappings sorted by the generated file's line/column\n   *        order or the original's source/line/column order, respectively. Defaults to\n   *        `SourceMapConsumer.GENERATED_ORDER`.\n   */\n  eachMapping(aCallback, aContext, aOrder) {\n    throw new Error(\"Subclasses must implement eachMapping\");\n  }\n\n  /**\n   * Returns all generated line and column information for the original source,\n   * line, and column provided. If no column is provided, returns all mappings\n   * corresponding to a either the line we are searching for or the next\n   * closest line that has any mappings. Otherwise, returns all mappings\n   * corresponding to the given line and either the column we are searching for\n   * or the next closest column that has any offsets.\n   *\n   * The only argument is an object with the following properties:\n   *\n   *   - source: The filename of the original source.\n   *   - line: The line number in the original source.  The line number is 1-based.\n   *   - column: Optional. the column number in the original source.\n   *    The column number is 0-based.\n   *\n   * and an array of objects is returned, each with the following properties:\n   *\n   *   - line: The line number in the generated source, or null.  The\n   *    line number is 1-based.\n   *   - column: The column number in the generated source, or null.\n   *    The column number is 0-based.\n   */\n  allGeneratedPositionsFor(aArgs) {\n    throw new Error(\"Subclasses must implement allGeneratedPositionsFor\");\n  }\n\n  destroy() {\n    throw new Error(\"Subclasses must implement destroy\");\n  }\n}\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nSourceMapConsumer.prototype._version = 3;\nSourceMapConsumer.GENERATED_ORDER = 1;\nSourceMapConsumer.ORIGINAL_ORDER = 2;\n\nSourceMapConsumer.GREATEST_LOWER_BOUND = 1;\nSourceMapConsumer.LEAST_UPPER_BOUND = 2;\n\nexports.SourceMapConsumer = SourceMapConsumer;\n\n/**\n * A BasicSourceMapConsumer instance represents a parsed source map which we can\n * query for information about the original file positions by giving it a file\n * position in the generated source.\n *\n * The first parameter is the raw source map (either as a JSON string, or\n * already parsed to an object). According to the spec, source maps have the\n * following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - sources: An array of URLs to the original source files.\n *   - names: An array of identifiers which can be referenced by individual mappings.\n *   - sourceRoot: Optional. The URL root from which all sources are relative.\n *   - sourcesContent: Optional. An array of contents of the original source files.\n *   - mappings: A string of base64 VLQs which contain the actual mappings.\n *   - file: Optional. The generated file this source map is associated with.\n *\n * Here is an example source map, taken from the source map spec[0]:\n *\n *     {\n *       version : 3,\n *       file: \"out.js\",\n *       sourceRoot : \"\",\n *       sources: [\"foo.js\", \"bar.js\"],\n *       names: [\"src\", \"maps\", \"are\", \"fun\"],\n *       mappings: \"AA,AB;;ABCDE;\"\n *     }\n *\n * The second parameter, if given, is a string whose value is the URL\n * at which the source map was found.  This URL is used to compute the\n * sources array.\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#\n */\nclass BasicSourceMapConsumer extends SourceMapConsumer {\n  constructor(aSourceMap, aSourceMapURL) {\n    return super(INTERNAL).then(that => {\n      let sourceMap = aSourceMap;\n      if (typeof aSourceMap === \"string\") {\n        sourceMap = util.parseSourceMapInput(aSourceMap);\n      }\n\n      const version = util.getArg(sourceMap, \"version\");\n      let sources = util.getArg(sourceMap, \"sources\");\n      // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which\n      // requires the array) to play nice here.\n      const names = util.getArg(sourceMap, \"names\", []);\n      let sourceRoot = util.getArg(sourceMap, \"sourceRoot\", null);\n      const sourcesContent = util.getArg(sourceMap, \"sourcesContent\", null);\n      const mappings = util.getArg(sourceMap, \"mappings\");\n      const file = util.getArg(sourceMap, \"file\", null);\n\n      // Once again, Sass deviates from the spec and supplies the version as a\n      // string rather than a number, so we use loose equality checking here.\n      if (version != that._version) {\n        throw new Error(\"Unsupported version: \" + version);\n      }\n\n      if (sourceRoot) {\n        sourceRoot = util.normalize(sourceRoot);\n      }\n\n      sources = sources\n        .map(String)\n        // Some source maps produce relative source paths like \"./foo.js\" instead of\n        // \"foo.js\".  Normalize these first so that future comparisons will succeed.\n        // See bugzil.la/1090768.\n        .map(util.normalize)\n        // Always ensure that absolute sources are internally stored relative to\n        // the source root, if the source root is absolute. Not doing this would\n        // be particularly problematic when the source root is a prefix of the\n        // source (valid, but why??). See github issue #199 and bugzil.la/1188982.\n        .map(function(source) {\n          return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)\n            ? util.relative(sourceRoot, source)\n            : source;\n        });\n\n      // Pass `true` below to allow duplicate names and sources. While source maps\n      // are intended to be compressed and deduplicated, the TypeScript compiler\n      // sometimes generates source maps with duplicates in them. See Github issue\n      // #72 and bugzil.la/889492.\n      that._names = ArraySet.fromArray(names.map(String), true);\n      that._sources = ArraySet.fromArray(sources, true);\n\n      that._absoluteSources = that._sources.toArray().map(function(s) {\n        return util.computeSourceURL(sourceRoot, s, aSourceMapURL);\n      });\n\n      that.sourceRoot = sourceRoot;\n      that.sourcesContent = sourcesContent;\n      that._mappings = mappings;\n      that._sourceMapURL = aSourceMapURL;\n      that.file = file;\n\n      that._computedColumnSpans = false;\n      that._mappingsPtr = 0;\n      that._wasm = null;\n\n      return wasm().then(w => {\n        that._wasm = w;\n        return that;\n      });\n    });\n  }\n\n  /**\n   * Utility function to find the index of a source.  Returns -1 if not\n   * found.\n   */\n  _findSourceIndex(aSource) {\n    let relativeSource = aSource;\n    if (this.sourceRoot != null) {\n      relativeSource = util.relative(this.sourceRoot, relativeSource);\n    }\n\n    if (this._sources.has(relativeSource)) {\n      return this._sources.indexOf(relativeSource);\n    }\n\n    // Maybe aSource is an absolute URL as returned by |sources|.  In\n    // this case we can't simply undo the transform.\n    for (let i = 0; i < this._absoluteSources.length; ++i) {\n      if (this._absoluteSources[i] == aSource) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n\n  /**\n   * Create a BasicSourceMapConsumer from a SourceMapGenerator.\n   *\n   * @param SourceMapGenerator aSourceMap\n   *        The source map that will be consumed.\n   * @param String aSourceMapURL\n   *        The URL at which the source map can be found (optional)\n   * @returns BasicSourceMapConsumer\n   */\n  static fromSourceMap(aSourceMap, aSourceMapURL) {\n    return new BasicSourceMapConsumer(aSourceMap.toString());\n  }\n\n  get sources() {\n    return this._absoluteSources.slice();\n  }\n\n  _getMappingsPtr() {\n    if (this._mappingsPtr === 0) {\n      this._parseMappings(this._mappings, this.sourceRoot);\n    }\n\n    return this._mappingsPtr;\n  }\n\n  /**\n   * Parse the mappings in a string in to a data structure which we can easily\n   * query (the ordered arrays in the `this.__generatedMappings` and\n   * `this.__originalMappings` properties).\n   */\n  _parseMappings(aStr, aSourceRoot) {\n    const size = aStr.length;\n\n    const mappingsBufPtr = this._wasm.exports.allocate_mappings(size);\n    const mappingsBuf = new Uint8Array(this._wasm.exports.memory.buffer, mappingsBufPtr, size);\n    for (let i = 0; i < size; i++) {\n      mappingsBuf[i] = aStr.charCodeAt(i);\n    }\n\n    const mappingsPtr = this._wasm.exports.parse_mappings(mappingsBufPtr);\n\n    if (!mappingsPtr) {\n      const error = this._wasm.exports.get_last_error();\n      let msg = `Error parsing mappings (code ${error}): `;\n\n      // XXX: keep these error codes in sync with `fitzgen/source-map-mappings`.\n      switch (error) {\n        case 1:\n          msg += \"the mappings contained a negative line, column, source index, or name index\";\n          break;\n        case 2:\n          msg += \"the mappings contained a number larger than 2**32\";\n          break;\n        case 3:\n          msg += \"reached EOF while in the middle of parsing a VLQ\";\n          break;\n        case 4:\n          msg += \"invalid base 64 character while parsing a VLQ\";\n          break;\n        default:\n          msg += \"unknown error code\";\n          break;\n      }\n\n      throw new Error(msg);\n    }\n\n    this._mappingsPtr = mappingsPtr;\n  }\n\n  eachMapping(aCallback, aContext, aOrder) {\n    const context = aContext || null;\n    const order = aOrder || SourceMapConsumer.GENERATED_ORDER;\n    const sourceRoot = this.sourceRoot;\n\n    this._wasm.withMappingCallback(\n      mapping => {\n        if (mapping.source !== null) {\n          mapping.source = this._sources.at(mapping.source);\n          mapping.source = util.computeSourceURL(sourceRoot, mapping.source, this._sourceMapURL);\n\n          if (mapping.name !== null) {\n            mapping.name = this._names.at(mapping.name);\n          }\n        }\n\n        aCallback.call(context, mapping);\n      },\n      () => {\n        switch (order) {\n        case SourceMapConsumer.GENERATED_ORDER:\n          this._wasm.exports.by_generated_location(this._getMappingsPtr());\n          break;\n        case SourceMapConsumer.ORIGINAL_ORDER:\n          this._wasm.exports.by_original_location(this._getMappingsPtr());\n          break;\n        default:\n          throw new Error(\"Unknown order of iteration.\");\n        }\n      }\n    );\n  }\n\n  allGeneratedPositionsFor(aArgs) {\n    let source = util.getArg(aArgs, \"source\");\n    const originalLine = util.getArg(aArgs, \"line\");\n    const originalColumn = aArgs.column || 0;\n\n    source = this._findSourceIndex(source);\n    if (source < 0) {\n      return [];\n    }\n\n    if (originalLine < 1) {\n      throw new Error(\"Line numbers must be >= 1\");\n    }\n\n    if (originalColumn < 0) {\n      throw new Error(\"Column numbers must be >= 0\");\n    }\n\n    const mappings = [];\n\n    this._wasm.withMappingCallback(\n      m => {\n        let lastColumn = m.lastGeneratedColumn;\n        if (this._computedColumnSpans && lastColumn === null) {\n          lastColumn = Infinity;\n        }\n        mappings.push({\n          line: m.generatedLine,\n          column: m.generatedColumn,\n          lastColumn,\n        });\n      }, () => {\n        this._wasm.exports.all_generated_locations_for(\n          this._getMappingsPtr(),\n          source,\n          originalLine - 1,\n          \"column\" in aArgs,\n          originalColumn\n        );\n      }\n    );\n\n    return mappings;\n  }\n\n  destroy() {\n    if (this._mappingsPtr !== 0) {\n      this._wasm.exports.free_mappings(this._mappingsPtr);\n      this._mappingsPtr = 0;\n    }\n  }\n\n  /**\n   * Compute the last column for each generated mapping. The last column is\n   * inclusive.\n   */\n  computeColumnSpans() {\n    if (this._computedColumnSpans) {\n      return;\n    }\n\n    this._wasm.exports.compute_column_spans(this._getMappingsPtr());\n    this._computedColumnSpans = true;\n  }\n\n  /**\n   * Returns the original source, line, and column information for the generated\n   * source's line and column positions provided. The only argument is an object\n   * with the following properties:\n   *\n   *   - line: The line number in the generated source.  The line number\n   *     is 1-based.\n   *   - column: The column number in the generated source.  The column\n   *     number is 0-based.\n   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n   *     closest element that is smaller than or greater than the one we are\n   *     searching for, respectively, if the exact element cannot be found.\n   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n   *\n   * and an object is returned with the following properties:\n   *\n   *   - source: The original source file, or null.\n   *   - line: The line number in the original source, or null.  The\n   *     line number is 1-based.\n   *   - column: The column number in the original source, or null.  The\n   *     column number is 0-based.\n   *   - name: The original identifier, or null.\n   */\n  originalPositionFor(aArgs) {\n    const needle = {\n      generatedLine: util.getArg(aArgs, \"line\"),\n      generatedColumn: util.getArg(aArgs, \"column\")\n    };\n\n    if (needle.generatedLine < 1) {\n      throw new Error(\"Line numbers must be >= 1\");\n    }\n\n    if (needle.generatedColumn < 0) {\n      throw new Error(\"Column numbers must be >= 0\");\n    }\n\n    let bias = util.getArg(aArgs, \"bias\", SourceMapConsumer.GREATEST_LOWER_BOUND);\n    if (bias == null) {\n      bias = SourceMapConsumer.GREATEST_LOWER_BOUND;\n    }\n\n    let mapping;\n    this._wasm.withMappingCallback(m => mapping = m, () => {\n      this._wasm.exports.original_location_for(\n        this._getMappingsPtr(),\n        needle.generatedLine - 1,\n        needle.generatedColumn,\n        bias\n      );\n    });\n\n    if (mapping) {\n      if (mapping.generatedLine === needle.generatedLine) {\n        let source = util.getArg(mapping, \"source\", null);\n        if (source !== null) {\n          source = this._sources.at(source);\n          source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);\n        }\n\n        let name = util.getArg(mapping, \"name\", null);\n        if (name !== null) {\n          name = this._names.at(name);\n        }\n\n        return {\n          source,\n          line: util.getArg(mapping, \"originalLine\", null),\n          column: util.getArg(mapping, \"originalColumn\", null),\n          name\n        };\n      }\n    }\n\n    return {\n      source: null,\n      line: null,\n      column: null,\n      name: null\n    };\n  }\n\n  /**\n   * Return true if we have the source content for every source in the source\n   * map, false otherwise.\n   */\n  hasContentsOfAllSources() {\n    if (!this.sourcesContent) {\n      return false;\n    }\n    return this.sourcesContent.length >= this._sources.size() &&\n      !this.sourcesContent.some(function(sc) { return sc == null; });\n  }\n\n  /**\n   * Returns the original source content. The only argument is the url of the\n   * original source file. Returns null if no original source content is\n   * available.\n   */\n  sourceContentFor(aSource, nullOnMissing) {\n    if (!this.sourcesContent) {\n      return null;\n    }\n\n    const index = this._findSourceIndex(aSource);\n    if (index >= 0) {\n      return this.sourcesContent[index];\n    }\n\n    let relativeSource = aSource;\n    if (this.sourceRoot != null) {\n      relativeSource = util.relative(this.sourceRoot, relativeSource);\n    }\n\n    let url;\n    if (this.sourceRoot != null\n        && (url = util.urlParse(this.sourceRoot))) {\n      // XXX: file:// URIs and absolute paths lead to unexpected behavior for\n      // many users. We can help them out when they expect file:// URIs to\n      // behave like it would if they were running a local HTTP server. See\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.\n      const fileUriAbsPath = relativeSource.replace(/^file:\\/\\//, \"\");\n      if (url.scheme == \"file\"\n          && this._sources.has(fileUriAbsPath)) {\n        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];\n      }\n\n      if ((!url.path || url.path == \"/\")\n          && this._sources.has(\"/\" + relativeSource)) {\n        return this.sourcesContent[this._sources.indexOf(\"/\" + relativeSource)];\n      }\n    }\n\n    // This function is used recursively from\n    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we\n    // don't want to throw if we can't find the source - we just want to\n    // return null, so we provide a flag to exit gracefully.\n    if (nullOnMissing) {\n      return null;\n    }\n\n    throw new Error('\"' + relativeSource + '\" is not in the SourceMap.');\n  }\n\n  /**\n   * Returns the generated line and column information for the original source,\n   * line, and column positions provided. The only argument is an object with\n   * the following properties:\n   *\n   *   - source: The filename of the original source.\n   *   - line: The line number in the original source.  The line number\n   *     is 1-based.\n   *   - column: The column number in the original source.  The column\n   *     number is 0-based.\n   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n   *     closest element that is smaller than or greater than the one we are\n   *     searching for, respectively, if the exact element cannot be found.\n   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n   *\n   * and an object is returned with the following properties:\n   *\n   *   - line: The line number in the generated source, or null.  The\n   *     line number is 1-based.\n   *   - column: The column number in the generated source, or null.\n   *     The column number is 0-based.\n   */\n  generatedPositionFor(aArgs) {\n    let source = util.getArg(aArgs, \"source\");\n    source = this._findSourceIndex(source);\n    if (source < 0) {\n      return {\n        line: null,\n        column: null,\n        lastColumn: null\n      };\n    }\n\n    const needle = {\n      source,\n      originalLine: util.getArg(aArgs, \"line\"),\n      originalColumn: util.getArg(aArgs, \"column\")\n    };\n\n    if (needle.originalLine < 1) {\n      throw new Error(\"Line numbers must be >= 1\");\n    }\n\n    if (needle.originalColumn < 0) {\n      throw new Error(\"Column numbers must be >= 0\");\n    }\n\n    let bias = util.getArg(aArgs, \"bias\", SourceMapConsumer.GREATEST_LOWER_BOUND);\n    if (bias == null) {\n      bias = SourceMapConsumer.GREATEST_LOWER_BOUND;\n    }\n\n    let mapping;\n    this._wasm.withMappingCallback(m => mapping = m, () => {\n      this._wasm.exports.generated_location_for(\n        this._getMappingsPtr(),\n        needle.source,\n        needle.originalLine - 1,\n        needle.originalColumn,\n        bias\n      );\n    });\n\n    if (mapping) {\n      if (mapping.source === needle.source) {\n        let lastColumn = mapping.lastGeneratedColumn;\n        if (this._computedColumnSpans && lastColumn === null) {\n          lastColumn = Infinity;\n        }\n        return {\n          line: util.getArg(mapping, \"generatedLine\", null),\n          column: util.getArg(mapping, \"generatedColumn\", null),\n          lastColumn,\n        };\n      }\n    }\n\n    return {\n      line: null,\n      column: null,\n      lastColumn: null\n    };\n  }\n}\n\nBasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;\nexports.BasicSourceMapConsumer = BasicSourceMapConsumer;\n\n/**\n * An IndexedSourceMapConsumer instance represents a parsed source map which\n * we can query for information. It differs from BasicSourceMapConsumer in\n * that it takes \"indexed\" source maps (i.e. ones with a \"sections\" field) as\n * input.\n *\n * The first parameter is a raw source map (either as a JSON string, or already\n * parsed to an object). According to the spec for indexed source maps, they\n * have the following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - file: Optional. The generated file this source map is associated with.\n *   - sections: A list of section definitions.\n *\n * Each value under the \"sections\" field has two fields:\n *   - offset: The offset into the original specified at which this section\n *       begins to apply, defined as an object with a \"line\" and \"column\"\n *       field.\n *   - map: A source map definition. This source map could also be indexed,\n *       but doesn't have to be.\n *\n * Instead of the \"map\" field, it's also possible to have a \"url\" field\n * specifying a URL to retrieve a source map from, but that's currently\n * unsupported.\n *\n * Here's an example source map, taken from the source map spec[0], but\n * modified to omit a section which uses the \"url\" field.\n *\n *  {\n *    version : 3,\n *    file: \"app.js\",\n *    sections: [{\n *      offset: {line:100, column:10},\n *      map: {\n *        version : 3,\n *        file: \"section.js\",\n *        sources: [\"foo.js\", \"bar.js\"],\n *        names: [\"src\", \"maps\", \"are\", \"fun\"],\n *        mappings: \"AAAA,E;;ABCDE;\"\n *      }\n *    }],\n *  }\n *\n * The second parameter, if given, is a string whose value is the URL\n * at which the source map was found.  This URL is used to compute the\n * sources array.\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt\n */\nclass IndexedSourceMapConsumer extends SourceMapConsumer {\n  constructor(aSourceMap, aSourceMapURL) {\n    return super(INTERNAL).then(that => {\n      let sourceMap = aSourceMap;\n      if (typeof aSourceMap === \"string\") {\n        sourceMap = util.parseSourceMapInput(aSourceMap);\n      }\n\n      const version = util.getArg(sourceMap, \"version\");\n      const sections = util.getArg(sourceMap, \"sections\");\n\n      if (version != that._version) {\n        throw new Error(\"Unsupported version: \" + version);\n      }\n\n      that._sources = new ArraySet();\n      that._names = new ArraySet();\n      that.__generatedMappings = null;\n      that.__originalMappings = null;\n      that.__generatedMappingsUnsorted = null;\n      that.__originalMappingsUnsorted = null;\n\n      let lastOffset = {\n        line: -1,\n        column: 0\n      };\n      return Promise.all(sections.map(s => {\n        if (s.url) {\n          // The url field will require support for asynchronicity.\n          // See https://github.com/mozilla/source-map/issues/16\n          throw new Error(\"Support for url field in sections not implemented.\");\n        }\n        const offset = util.getArg(s, \"offset\");\n        const offsetLine = util.getArg(offset, \"line\");\n        const offsetColumn = util.getArg(offset, \"column\");\n\n        if (offsetLine < lastOffset.line ||\n            (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {\n          throw new Error(\"Section offsets must be ordered and non-overlapping.\");\n        }\n        lastOffset = offset;\n\n        const cons = new SourceMapConsumer(util.getArg(s, \"map\"), aSourceMapURL);\n        return cons.then(consumer => {\n          return {\n            generatedOffset: {\n              // The offset fields are 0-based, but we use 1-based indices when\n              // encoding/decoding from VLQ.\n              generatedLine: offsetLine + 1,\n              generatedColumn: offsetColumn + 1\n            },\n            consumer\n          };\n        });\n      })).then(s => {\n        that._sections = s;\n        return that;\n      });\n    });\n  }\n\n  // `__generatedMappings` and `__originalMappings` are arrays that hold the\n  // parsed mapping coordinates from the source map's \"mappings\" attribute. They\n  // are lazily instantiated, accessed via the `_generatedMappings` and\n  // `_originalMappings` getters respectively, and we only parse the mappings\n  // and create these arrays once queried for a source location. We jump through\n  // these hoops because there can be many thousands of mappings, and parsing\n  // them is expensive, so we only want to do it if we must.\n  //\n  // Each object in the arrays is of the form:\n  //\n  //     {\n  //       generatedLine: The line number in the generated code,\n  //       generatedColumn: The column number in the generated code,\n  //       source: The path to the original source file that generated this\n  //               chunk of code,\n  //       originalLine: The line number in the original source that\n  //                     corresponds to this chunk of generated code,\n  //       originalColumn: The column number in the original source that\n  //                       corresponds to this chunk of generated code,\n  //       name: The name of the original symbol which generated this chunk of\n  //             code.\n  //     }\n  //\n  // All properties except for `generatedLine` and `generatedColumn` can be\n  // `null`.\n  //\n  // `_generatedMappings` is ordered by the generated positions.\n  //\n  // `_originalMappings` is ordered by the original positions.\n  get _generatedMappings() {\n    if (!this.__generatedMappings) {\n      this._sortGeneratedMappings();\n    }\n\n    return this.__generatedMappings;\n  }\n\n  get _originalMappings() {\n    if (!this.__originalMappings) {\n      this._sortOriginalMappings();\n    }\n\n    return this.__originalMappings;\n  }\n\n  get _generatedMappingsUnsorted() {\n    if (!this.__generatedMappingsUnsorted) {\n      this._parseMappings(this._mappings, this.sourceRoot);\n    }\n\n    return this.__generatedMappingsUnsorted;\n  }\n\n  get _originalMappingsUnsorted() {\n    if (!this.__originalMappingsUnsorted) {\n      this._parseMappings(this._mappings, this.sourceRoot);\n    }\n\n    return this.__originalMappingsUnsorted;\n  }\n\n  _sortGeneratedMappings() {\n    const mappings = this._generatedMappingsUnsorted;\n    mappings.sort(util.compareByGeneratedPositionsDeflated);\n    this.__generatedMappings = mappings;\n  }\n\n  _sortOriginalMappings() {\n    const mappings = this._originalMappingsUnsorted;\n    mappings.sort(util.compareByOriginalPositions);\n    this.__originalMappings = mappings;\n  }\n\n  /**\n   * The list of original sources.\n   */\n  get sources() {\n    const sources = [];\n    for (let i = 0; i < this._sections.length; i++) {\n      for (let j = 0; j < this._sections[i].consumer.sources.length; j++) {\n        sources.push(this._sections[i].consumer.sources[j]);\n      }\n    }\n    return sources;\n  }\n\n  /**\n   * Returns the original source, line, and column information for the generated\n   * source's line and column positions provided. The only argument is an object\n   * with the following properties:\n   *\n   *   - line: The line number in the generated source.  The line number\n   *     is 1-based.\n   *   - column: The column number in the generated source.  The column\n   *     number is 0-based.\n   *\n   * and an object is returned with the following properties:\n   *\n   *   - source: The original source file, or null.\n   *   - line: The line number in the original source, or null.  The\n   *     line number is 1-based.\n   *   - column: The column number in the original source, or null.  The\n   *     column number is 0-based.\n   *   - name: The original identifier, or null.\n   */\n  originalPositionFor(aArgs) {\n    const needle = {\n      generatedLine: util.getArg(aArgs, \"line\"),\n      generatedColumn: util.getArg(aArgs, \"column\")\n    };\n\n    // Find the section containing the generated position we're trying to map\n    // to an original position.\n    const sectionIndex = binarySearch.search(needle, this._sections,\n      function(aNeedle, section) {\n        const cmp = aNeedle.generatedLine - section.generatedOffset.generatedLine;\n        if (cmp) {\n          return cmp;\n        }\n\n        return (aNeedle.generatedColumn -\n                section.generatedOffset.generatedColumn);\n      });\n    const section = this._sections[sectionIndex];\n\n    if (!section) {\n      return {\n        source: null,\n        line: null,\n        column: null,\n        name: null\n      };\n    }\n\n    return section.consumer.originalPositionFor({\n      line: needle.generatedLine -\n        (section.generatedOffset.generatedLine - 1),\n      column: needle.generatedColumn -\n        (section.generatedOffset.generatedLine === needle.generatedLine\n         ? section.generatedOffset.generatedColumn - 1\n         : 0),\n      bias: aArgs.bias\n    });\n  }\n\n  /**\n   * Return true if we have the source content for every source in the source\n   * map, false otherwise.\n   */\n  hasContentsOfAllSources() {\n    return this._sections.every(function(s) {\n      return s.consumer.hasContentsOfAllSources();\n    });\n  }\n\n  /**\n   * Returns the original source content. The only argument is the url of the\n   * original source file. Returns null if no original source content is\n   * available.\n   */\n  sourceContentFor(aSource, nullOnMissing) {\n    for (let i = 0; i < this._sections.length; i++) {\n      const section = this._sections[i];\n\n      const content = section.consumer.sourceContentFor(aSource, true);\n      if (content) {\n        return content;\n      }\n    }\n    if (nullOnMissing) {\n      return null;\n    }\n    throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n  }\n\n  /**\n   * Returns the generated line and column information for the original source,\n   * line, and column positions provided. The only argument is an object with\n   * the following properties:\n   *\n   *   - source: The filename of the original source.\n   *   - line: The line number in the original source.  The line number\n   *     is 1-based.\n   *   - column: The column number in the original source.  The column\n   *     number is 0-based.\n   *\n   * and an object is returned with the following properties:\n   *\n   *   - line: The line number in the generated source, or null.  The\n   *     line number is 1-based.\n   *   - column: The column number in the generated source, or null.\n   *     The column number is 0-based.\n   */\n  generatedPositionFor(aArgs) {\n    for (let i = 0; i < this._sections.length; i++) {\n      const section = this._sections[i];\n\n      // Only consider this section if the requested source is in the list of\n      // sources of the consumer.\n      if (section.consumer._findSourceIndex(util.getArg(aArgs, \"source\")) === -1) {\n        continue;\n      }\n      const generatedPosition = section.consumer.generatedPositionFor(aArgs);\n      if (generatedPosition) {\n        const ret = {\n          line: generatedPosition.line +\n            (section.generatedOffset.generatedLine - 1),\n          column: generatedPosition.column +\n            (section.generatedOffset.generatedLine === generatedPosition.line\n             ? section.generatedOffset.generatedColumn - 1\n             : 0)\n        };\n        return ret;\n      }\n    }\n\n    return {\n      line: null,\n      column: null\n    };\n  }\n\n  /**\n   * Parse the mappings in a string in to a data structure which we can easily\n   * query (the ordered arrays in the `this.__generatedMappings` and\n   * `this.__originalMappings` properties).\n   */\n  _parseMappings(aStr, aSourceRoot) {\n    const generatedMappings = this.__generatedMappingsUnsorted = [];\n    const originalMappings = this.__originalMappingsUnsorted = [];\n    for (let i = 0; i < this._sections.length; i++) {\n      const section = this._sections[i];\n\n      const sectionMappings = [];\n      section.consumer.eachMapping(m => sectionMappings.push(m));\n\n      for (let j = 0; j < sectionMappings.length; j++) {\n        const mapping = sectionMappings[j];\n\n        // TODO: test if null is correct here.  The original code used\n        // `source`, which would actually have gotten used as null because\n        // var's get hoisted.\n        // See: https://github.com/mozilla/source-map/issues/333\n        let source = util.computeSourceURL(section.consumer.sourceRoot, null, this._sourceMapURL);\n        this._sources.add(source);\n        source = this._sources.indexOf(source);\n\n        let name = null;\n        if (mapping.name) {\n          this._names.add(mapping.name);\n          name = this._names.indexOf(mapping.name);\n        }\n\n        // The mappings coming from the consumer for the section have\n        // generated positions relative to the start of the section, so we\n        // need to offset them to be relative to the start of the concatenated\n        // generated file.\n        const adjustedMapping = {\n          source,\n          generatedLine: mapping.generatedLine +\n            (section.generatedOffset.generatedLine - 1),\n          generatedColumn: mapping.generatedColumn +\n            (section.generatedOffset.generatedLine === mapping.generatedLine\n            ? section.generatedOffset.generatedColumn - 1\n            : 0),\n          originalLine: mapping.originalLine,\n          originalColumn: mapping.originalColumn,\n          name\n        };\n\n        generatedMappings.push(adjustedMapping);\n        if (typeof adjustedMapping.originalLine === \"number\") {\n          originalMappings.push(adjustedMapping);\n        }\n      }\n    }\n  }\n\n  eachMapping(aCallback, aContext, aOrder) {\n    const context = aContext || null;\n    const order = aOrder || SourceMapConsumer.GENERATED_ORDER;\n\n    let mappings;\n    switch (order) {\n    case SourceMapConsumer.GENERATED_ORDER:\n      mappings = this._generatedMappings;\n      break;\n    case SourceMapConsumer.ORIGINAL_ORDER:\n      mappings = this._originalMappings;\n      break;\n    default:\n      throw new Error(\"Unknown order of iteration.\");\n    }\n\n    const sourceRoot = this.sourceRoot;\n    mappings.map(function(mapping) {\n      let source = null;\n      if (mapping.source !== null) {\n        source = this._sources.at(mapping.source);\n        source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);\n      }\n      return {\n        source,\n        generatedLine: mapping.generatedLine,\n        generatedColumn: mapping.generatedColumn,\n        originalLine: mapping.originalLine,\n        originalColumn: mapping.originalColumn,\n        name: mapping.name === null ? null : this._names.at(mapping.name)\n      };\n    }, this).forEach(aCallback, context);\n  }\n\n  /**\n   * Find the mapping that best matches the hypothetical \"needle\" mapping that\n   * we are searching for in the given \"haystack\" of mappings.\n   */\n  _findMapping(aNeedle, aMappings, aLineName,\n              aColumnName, aComparator, aBias) {\n    // To return the position we are searching for, we must first find the\n    // mapping for the given position and then return the opposite position it\n    // points to. Because the mappings are sorted, we can use binary search to\n    // find the best mapping.\n\n    if (aNeedle[aLineName] <= 0) {\n      throw new TypeError(\"Line must be greater than or equal to 1, got \"\n                          + aNeedle[aLineName]);\n    }\n    if (aNeedle[aColumnName] < 0) {\n      throw new TypeError(\"Column must be greater than or equal to 0, got \"\n                          + aNeedle[aColumnName]);\n    }\n\n    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);\n  }\n\n  allGeneratedPositionsFor(aArgs) {\n    const line = util.getArg(aArgs, \"line\");\n\n    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping\n    // returns the index of the closest mapping less than the needle. By\n    // setting needle.originalColumn to 0, we thus find the last mapping for\n    // the given line, provided such a mapping exists.\n    const needle = {\n      source: util.getArg(aArgs, \"source\"),\n      originalLine: line,\n      originalColumn: util.getArg(aArgs, \"column\", 0)\n    };\n\n    needle.source = this._findSourceIndex(needle.source);\n    if (needle.source < 0) {\n      return [];\n    }\n\n    if (needle.originalLine < 1) {\n      throw new Error(\"Line numbers must be >= 1\");\n    }\n\n    if (needle.originalColumn < 0) {\n      throw new Error(\"Column numbers must be >= 0\");\n    }\n\n    const mappings = [];\n\n    let index = this._findMapping(needle,\n                                  this._originalMappings,\n                                  \"originalLine\",\n                                  \"originalColumn\",\n                                  util.compareByOriginalPositions,\n                                  binarySearch.LEAST_UPPER_BOUND);\n    if (index >= 0) {\n      let mapping = this._originalMappings[index];\n\n      if (aArgs.column === undefined) {\n        const originalLine = mapping.originalLine;\n\n        // Iterate until either we run out of mappings, or we run into\n        // a mapping for a different line than the one we found. Since\n        // mappings are sorted, this is guaranteed to find all mappings for\n        // the line we found.\n        while (mapping && mapping.originalLine === originalLine) {\n          let lastColumn = mapping.lastGeneratedColumn;\n          if (this._computedColumnSpans && lastColumn === null) {\n            lastColumn = Infinity;\n          }\n          mappings.push({\n            line: util.getArg(mapping, \"generatedLine\", null),\n            column: util.getArg(mapping, \"generatedColumn\", null),\n            lastColumn,\n          });\n\n          mapping = this._originalMappings[++index];\n        }\n      } else {\n        const originalColumn = mapping.originalColumn;\n\n        // Iterate until either we run out of mappings, or we run into\n        // a mapping for a different line than the one we were searching for.\n        // Since mappings are sorted, this is guaranteed to find all mappings for\n        // the line we are searching for.\n        while (mapping &&\n               mapping.originalLine === line &&\n               mapping.originalColumn == originalColumn) {\n          let lastColumn = mapping.lastGeneratedColumn;\n          if (this._computedColumnSpans && lastColumn === null) {\n            lastColumn = Infinity;\n          }\n          mappings.push({\n            line: util.getArg(mapping, \"generatedLine\", null),\n            column: util.getArg(mapping, \"generatedColumn\", null),\n            lastColumn,\n          });\n\n          mapping = this._originalMappings[++index];\n        }\n      }\n    }\n\n    return mappings;\n  }\n\n  destroy() {\n    for (let i = 0; i < this._sections.length; i++) {\n      this._sections[i].consumer.destroy();\n    }\n  }\n}\nexports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;\n\n/*\n * Cheat to get around inter-twingled classes.  `factory()` can be at the end\n * where it has access to non-hoisted classes, but it gets hoisted itself.\n */\nfunction _factory(aSourceMap, aSourceMapURL) {\n  let sourceMap = aSourceMap;\n  if (typeof aSourceMap === \"string\") {\n    sourceMap = util.parseSourceMapInput(aSourceMap);\n  }\n\n  const consumer = sourceMap.sections != null\n      ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL)\n      : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);\n  return Promise.resolve(consumer);\n}\n\nfunction _factoryBSM(aSourceMap, aSourceMapURL) {\n  return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}