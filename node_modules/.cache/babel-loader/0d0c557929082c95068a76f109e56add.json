{"ast":null,"code":"'use strict';\n\nconst {\n  signalsByName\n} = require('human-signals');\n\nconst getErrorPrefix = _ref => {\n  let {\n    timedOut,\n    timeout,\n    errorCode,\n    signal,\n    signalDescription,\n    exitCode,\n    isCanceled\n  } = _ref;\n\n  if (timedOut) {\n    return `timed out after ${timeout} milliseconds`;\n  }\n\n  if (isCanceled) {\n    return 'was canceled';\n  }\n\n  if (errorCode !== undefined) {\n    return `failed with ${errorCode}`;\n  }\n\n  if (signal !== undefined) {\n    return `was killed with ${signal} (${signalDescription})`;\n  }\n\n  if (exitCode !== undefined) {\n    return `failed with exit code ${exitCode}`;\n  }\n\n  return 'failed';\n};\n\nconst makeError = _ref2 => {\n  let {\n    stdout,\n    stderr,\n    all,\n    error,\n    signal,\n    exitCode,\n    command,\n    escapedCommand,\n    timedOut,\n    isCanceled,\n    killed,\n    parsed: {\n      options: {\n        timeout\n      }\n    }\n  } = _ref2;\n  // `signal` and `exitCode` emitted on `spawned.on('exit')` event can be `null`.\n  // We normalize them to `undefined`\n  exitCode = exitCode === null ? undefined : exitCode;\n  signal = signal === null ? undefined : signal;\n  const signalDescription = signal === undefined ? undefined : signalsByName[signal].description;\n  const errorCode = error && error.code;\n  const prefix = getErrorPrefix({\n    timedOut,\n    timeout,\n    errorCode,\n    signal,\n    signalDescription,\n    exitCode,\n    isCanceled\n  });\n  const execaMessage = `Command ${prefix}: ${command}`;\n  const isError = Object.prototype.toString.call(error) === '[object Error]';\n  const shortMessage = isError ? `${execaMessage}\\n${error.message}` : execaMessage;\n  const message = [shortMessage, stderr, stdout].filter(Boolean).join('\\n');\n\n  if (isError) {\n    error.originalMessage = error.message;\n    error.message = message;\n  } else {\n    error = new Error(message);\n  }\n\n  error.shortMessage = shortMessage;\n  error.command = command;\n  error.escapedCommand = escapedCommand;\n  error.exitCode = exitCode;\n  error.signal = signal;\n  error.signalDescription = signalDescription;\n  error.stdout = stdout;\n  error.stderr = stderr;\n\n  if (all !== undefined) {\n    error.all = all;\n  }\n\n  if ('bufferedData' in error) {\n    delete error.bufferedData;\n  }\n\n  error.failed = true;\n  error.timedOut = Boolean(timedOut);\n  error.isCanceled = isCanceled;\n  error.killed = killed && !timedOut;\n  return error;\n};\n\nmodule.exports = makeError;","map":{"version":3,"names":["signalsByName","require","getErrorPrefix","timedOut","timeout","errorCode","signal","signalDescription","exitCode","isCanceled","undefined","makeError","stdout","stderr","all","error","command","escapedCommand","killed","parsed","options","description","code","prefix","execaMessage","isError","Object","prototype","toString","call","shortMessage","message","filter","Boolean","join","originalMessage","Error","bufferedData","failed","module","exports"],"sources":["/Users/lincolnkushwah/Desktop/All/React Projects/house_joy_new/node_modules/execa/lib/error.js"],"sourcesContent":["'use strict';\nconst {signalsByName} = require('human-signals');\n\nconst getErrorPrefix = ({timedOut, timeout, errorCode, signal, signalDescription, exitCode, isCanceled}) => {\n\tif (timedOut) {\n\t\treturn `timed out after ${timeout} milliseconds`;\n\t}\n\n\tif (isCanceled) {\n\t\treturn 'was canceled';\n\t}\n\n\tif (errorCode !== undefined) {\n\t\treturn `failed with ${errorCode}`;\n\t}\n\n\tif (signal !== undefined) {\n\t\treturn `was killed with ${signal} (${signalDescription})`;\n\t}\n\n\tif (exitCode !== undefined) {\n\t\treturn `failed with exit code ${exitCode}`;\n\t}\n\n\treturn 'failed';\n};\n\nconst makeError = ({\n\tstdout,\n\tstderr,\n\tall,\n\terror,\n\tsignal,\n\texitCode,\n\tcommand,\n\tescapedCommand,\n\ttimedOut,\n\tisCanceled,\n\tkilled,\n\tparsed: {options: {timeout}}\n}) => {\n\t// `signal` and `exitCode` emitted on `spawned.on('exit')` event can be `null`.\n\t// We normalize them to `undefined`\n\texitCode = exitCode === null ? undefined : exitCode;\n\tsignal = signal === null ? undefined : signal;\n\tconst signalDescription = signal === undefined ? undefined : signalsByName[signal].description;\n\n\tconst errorCode = error && error.code;\n\n\tconst prefix = getErrorPrefix({timedOut, timeout, errorCode, signal, signalDescription, exitCode, isCanceled});\n\tconst execaMessage = `Command ${prefix}: ${command}`;\n\tconst isError = Object.prototype.toString.call(error) === '[object Error]';\n\tconst shortMessage = isError ? `${execaMessage}\\n${error.message}` : execaMessage;\n\tconst message = [shortMessage, stderr, stdout].filter(Boolean).join('\\n');\n\n\tif (isError) {\n\t\terror.originalMessage = error.message;\n\t\terror.message = message;\n\t} else {\n\t\terror = new Error(message);\n\t}\n\n\terror.shortMessage = shortMessage;\n\terror.command = command;\n\terror.escapedCommand = escapedCommand;\n\terror.exitCode = exitCode;\n\terror.signal = signal;\n\terror.signalDescription = signalDescription;\n\terror.stdout = stdout;\n\terror.stderr = stderr;\n\n\tif (all !== undefined) {\n\t\terror.all = all;\n\t}\n\n\tif ('bufferedData' in error) {\n\t\tdelete error.bufferedData;\n\t}\n\n\terror.failed = true;\n\terror.timedOut = Boolean(timedOut);\n\terror.isCanceled = isCanceled;\n\terror.killed = killed && !timedOut;\n\n\treturn error;\n};\n\nmodule.exports = makeError;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}