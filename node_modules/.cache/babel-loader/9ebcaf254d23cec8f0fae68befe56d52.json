{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.createScriptTransformer = createScriptTransformer;\nexports.createTranspilingRequire = createTranspilingRequire;\n\nfunction _crypto() {\n  const data = require('crypto');\n\n  _crypto = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction path() {\n  const data = _interopRequireWildcard(require('path'));\n\n  path = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _core() {\n  const data = require('@babel/core');\n\n  _core = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _babelPluginIstanbul() {\n  const data = _interopRequireDefault(require('babel-plugin-istanbul'));\n\n  _babelPluginIstanbul = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _convertSourceMap() {\n  const data = require('convert-source-map');\n\n  _convertSourceMap = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _fastJsonStableStringify() {\n  const data = _interopRequireDefault(require('fast-json-stable-stringify'));\n\n  _fastJsonStableStringify = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction fs() {\n  const data = _interopRequireWildcard(require('graceful-fs'));\n\n  fs = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _pirates() {\n  const data = require('pirates');\n\n  _pirates = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _slash() {\n  const data = _interopRequireDefault(require('slash'));\n\n  _slash = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _writeFileAtomic() {\n  const data = require('write-file-atomic');\n\n  _writeFileAtomic = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestHasteMap() {\n  const data = _interopRequireDefault(require('jest-haste-map'));\n\n  _jestHasteMap = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestUtil() {\n  const data = require('jest-util');\n\n  _jestUtil = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _enhanceUnexpectedTokenMessage = _interopRequireDefault(require('./enhanceUnexpectedTokenMessage'));\n\nvar _runtimeErrorsAndWarnings = require('./runtimeErrorsAndWarnings');\n\nvar _shouldInstrument = _interopRequireDefault(require('./shouldInstrument'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== 'function') return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== 'object' && typeof obj !== 'function') {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache(nodeInterop);\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (key !== 'default' && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n} // Use `require` to avoid TS rootDir\n\n\nconst {\n  version: VERSION\n} = require('../package.json'); // This data structure is used to avoid recalculating some data every time that\n// we need to transform a file. Since ScriptTransformer is instantiated for each\n// file we need to keep this object in the local scope of this module.\n\n\nconst projectCaches = new Map(); // To reset the cache for specific changesets (rather than package version).\n\nconst CACHE_VERSION = '1';\n\nasync function waitForPromiseWithCleanup(promise, cleanup) {\n  try {\n    await promise;\n  } finally {\n    cleanup();\n  }\n}\n\nclass ScriptTransformer {\n  constructor(_config, _cacheFS) {\n    _defineProperty(this, '_cache', void 0);\n\n    _defineProperty(this, '_transformCache', new Map());\n\n    _defineProperty(this, '_transformsAreLoaded', false);\n\n    this._config = _config;\n    this._cacheFS = _cacheFS;\n    const configString = (0, _fastJsonStableStringify().default)(this._config);\n    let projectCache = projectCaches.get(configString);\n\n    if (!projectCache) {\n      projectCache = {\n        configString,\n        ignorePatternsRegExp: calcIgnorePatternRegExp(this._config),\n        transformRegExp: calcTransformRegExp(this._config),\n        transformedFiles: new Map()\n      };\n      projectCaches.set(configString, projectCache);\n    }\n\n    this._cache = projectCache;\n  }\n\n  _buildCacheKeyFromFileInfo(fileData, filename, transformOptions, transformerCacheKey) {\n    if (transformerCacheKey) {\n      return (0, _crypto().createHash)('md5').update(transformerCacheKey).update(CACHE_VERSION).digest('hex');\n    }\n\n    return (0, _crypto().createHash)('md5').update(fileData).update(transformOptions.configString).update(transformOptions.instrument ? 'instrument' : '').update(filename).update(CACHE_VERSION).digest('hex');\n  }\n\n  _getCacheKey(fileData, filename, options) {\n    const configString = this._cache.configString;\n    const {\n      transformer,\n      transformerConfig = {}\n    } = this._getTransformer(filename) || {};\n    let transformerCacheKey = undefined;\n    const transformOptions = { ...options,\n      cacheFS: this._cacheFS,\n      config: this._config,\n      configString,\n      transformerConfig\n    };\n\n    if (typeof (transformer === null || transformer === void 0 ? void 0 : transformer.getCacheKey) === 'function') {\n      transformerCacheKey = transformer.getCacheKey(fileData, filename, transformOptions);\n    }\n\n    return this._buildCacheKeyFromFileInfo(fileData, filename, transformOptions, transformerCacheKey);\n  }\n\n  async _getCacheKeyAsync(fileData, filename, options) {\n    const configString = this._cache.configString;\n    const {\n      transformer,\n      transformerConfig = {}\n    } = this._getTransformer(filename) || {};\n    let transformerCacheKey = undefined;\n    const transformOptions = { ...options,\n      cacheFS: this._cacheFS,\n      config: this._config,\n      configString,\n      transformerConfig\n    };\n\n    if (transformer) {\n      const getCacheKey = transformer.getCacheKeyAsync || transformer.getCacheKey;\n\n      if (typeof getCacheKey === 'function') {\n        transformerCacheKey = await getCacheKey(fileData, filename, transformOptions);\n      }\n    }\n\n    return this._buildCacheKeyFromFileInfo(fileData, filename, transformOptions, transformerCacheKey);\n  }\n\n  _createFolderFromCacheKey(filename, cacheKey) {\n    const HasteMapClass = _jestHasteMap().default.getStatic(this._config);\n\n    const baseCacheDir = HasteMapClass.getCacheFilePath(this._config.cacheDirectory, 'jest-transform-cache-' + this._config.name, VERSION); // Create sub folders based on the cacheKey to avoid creating one\n    // directory with many files.\n\n    const cacheDir = path().join(baseCacheDir, cacheKey[0] + cacheKey[1]);\n    const cacheFilenamePrefix = path().basename(filename, path().extname(filename)).replace(/\\W/g, '');\n    const cachePath = (0, _slash().default)(path().join(cacheDir, cacheFilenamePrefix + '_' + cacheKey));\n    (0, _jestUtil().createDirectory)(cacheDir);\n    return cachePath;\n  }\n\n  _getFileCachePath(filename, content, options) {\n    const cacheKey = this._getCacheKey(content, filename, options);\n\n    return this._createFolderFromCacheKey(filename, cacheKey);\n  }\n\n  async _getFileCachePathAsync(filename, content, options) {\n    const cacheKey = await this._getCacheKeyAsync(content, filename, options);\n    return this._createFolderFromCacheKey(filename, cacheKey);\n  }\n\n  _getTransformPath(filename) {\n    const transformRegExp = this._cache.transformRegExp;\n\n    if (!transformRegExp) {\n      return undefined;\n    }\n\n    for (let i = 0; i < transformRegExp.length; i++) {\n      if (transformRegExp[i][0].test(filename)) {\n        return transformRegExp[i][1];\n      }\n    }\n\n    return undefined;\n  }\n\n  async loadTransformers() {\n    await Promise.all(this._config.transform.map(async _ref => {\n      let [, transformPath, transformerConfig] = _ref;\n      let transformer = await (0, _jestUtil().requireOrImportModule)(transformPath);\n\n      if (!transformer) {\n        throw new Error((0, _runtimeErrorsAndWarnings.makeInvalidTransformerError)(transformPath));\n      }\n\n      if (typeof transformer.createTransformer === 'function') {\n        transformer = transformer.createTransformer(transformerConfig);\n      }\n\n      if (typeof transformer.process !== 'function' && typeof transformer.processAsync !== 'function') {\n        throw new Error((0, _runtimeErrorsAndWarnings.makeInvalidTransformerError)(transformPath));\n      }\n\n      const res = {\n        transformer,\n        transformerConfig\n      };\n\n      this._transformCache.set(transformPath, res);\n    }));\n    this._transformsAreLoaded = true;\n  }\n\n  _getTransformer(filename) {\n    if (!this._transformsAreLoaded) {\n      throw new Error('Jest: Transformers have not been loaded yet - make sure to run `loadTransformers` and wait for it to complete before starting to transform files');\n    }\n\n    if (this._config.transform.length === 0) {\n      return null;\n    }\n\n    const transformPath = this._getTransformPath(filename);\n\n    if (!transformPath) {\n      return null;\n    }\n\n    const cached = this._transformCache.get(transformPath);\n\n    if (cached) {\n      return cached;\n    }\n\n    throw new Error(`Jest was unable to load the transformer defined for ${filename}. This is a bug in Jest, please open up an issue`);\n  }\n\n  _instrumentFile(filename, input, canMapToInput, options) {\n    const inputCode = typeof input === 'string' ? input : input.code;\n    const inputMap = typeof input === 'string' ? null : input.map;\n    const result = (0, _core().transformSync)(inputCode, {\n      auxiliaryCommentBefore: ' istanbul ignore next ',\n      babelrc: false,\n      caller: {\n        name: '@jest/transform',\n        supportsDynamicImport: options.supportsDynamicImport,\n        supportsExportNamespaceFrom: options.supportsExportNamespaceFrom,\n        supportsStaticESM: options.supportsStaticESM,\n        supportsTopLevelAwait: options.supportsTopLevelAwait\n      },\n      configFile: false,\n      filename,\n      plugins: [[_babelPluginIstanbul().default, {\n        compact: false,\n        // files outside `cwd` will not be instrumented\n        cwd: this._config.rootDir,\n        exclude: [],\n        extension: false,\n        inputSourceMap: inputMap,\n        useInlineSourceMaps: false\n      }]],\n      sourceMaps: canMapToInput ? 'both' : false\n    });\n\n    if (result && result.code) {\n      return result;\n    }\n\n    return input;\n  }\n\n  _buildTransformResult(filename, cacheFilePath, content, transformer, shouldCallTransform, options, processed, sourceMapPath) {\n    let transformed = {\n      code: content,\n      map: null\n    };\n\n    if (transformer && shouldCallTransform) {\n      if (typeof processed === 'string') {\n        transformed.code = processed;\n      } else if (processed != null && typeof processed.code === 'string') {\n        transformed = processed;\n      } else {\n        throw new Error((0, _runtimeErrorsAndWarnings.makeInvalidReturnValueError)());\n      }\n    }\n\n    if (!transformed.map) {\n      try {\n        //Could be a potential freeze here.\n        //See: https://github.com/facebook/jest/pull/5177#discussion_r158883570\n        const inlineSourceMap = (0, _convertSourceMap().fromSource)(transformed.code);\n\n        if (inlineSourceMap) {\n          transformed.map = inlineSourceMap.toObject();\n        }\n      } catch {\n        const transformPath = this._getTransformPath(filename);\n\n        invariant(transformPath);\n        console.warn((0, _runtimeErrorsAndWarnings.makeInvalidSourceMapWarning)(filename, transformPath));\n      }\n    } // That means that the transform has a custom instrumentation\n    // logic and will handle it based on `config.collectCoverage` option\n\n\n    const transformWillInstrument = shouldCallTransform && transformer && transformer.canInstrument; // Apply instrumentation to the code if necessary, keeping the instrumented code and new map\n\n    let map = transformed.map;\n    let code;\n\n    if (!transformWillInstrument && options.instrument) {\n      /**\n       * We can map the original source code to the instrumented code ONLY if\n       * - the process of transforming the code produced a source map e.g. ts-jest\n       * - we did not transform the source code\n       *\n       * Otherwise we cannot make any statements about how the instrumented code corresponds to the original code,\n       * and we should NOT emit any source maps\n       *\n       */\n      const shouldEmitSourceMaps = transformer != null && map != null || transformer == null;\n\n      const instrumented = this._instrumentFile(filename, transformed, shouldEmitSourceMaps, options);\n\n      code = typeof instrumented === 'string' ? instrumented : instrumented.code;\n      map = typeof instrumented === 'string' ? null : instrumented.map;\n    } else {\n      code = transformed.code;\n    }\n\n    if (map) {\n      const sourceMapContent = typeof map === 'string' ? map : JSON.stringify(map);\n      invariant(sourceMapPath, 'We should always have default sourceMapPath');\n      writeCacheFile(sourceMapPath, sourceMapContent);\n    } else {\n      sourceMapPath = null;\n    }\n\n    writeCodeCacheFile(cacheFilePath, code);\n    return {\n      code,\n      originalCode: content,\n      sourceMapPath\n    };\n  }\n\n  transformSource(filepath, content, options) {\n    const filename = (0, _jestUtil().tryRealpath)(filepath);\n    const {\n      transformer,\n      transformerConfig = {}\n    } = this._getTransformer(filename) || {};\n\n    const cacheFilePath = this._getFileCachePath(filename, content, options);\n\n    const sourceMapPath = cacheFilePath + '.map'; // Ignore cache if `config.cache` is set (--no-cache)\n\n    const code = this._config.cache ? readCodeCacheFile(cacheFilePath) : null;\n\n    if (code) {\n      // This is broken: we return the code, and a path for the source map\n      // directly from the cache. But, nothing ensures the source map actually\n      // matches that source code. They could have gotten out-of-sync in case\n      // two separate processes write concurrently to the same cache files.\n      return {\n        code,\n        originalCode: content,\n        sourceMapPath\n      };\n    }\n\n    let processed = null;\n    let shouldCallTransform = false;\n\n    if (transformer && this.shouldTransform(filename)) {\n      shouldCallTransform = true;\n      assertSyncTransformer(transformer, this._getTransformPath(filename));\n      processed = transformer.process(content, filename, { ...options,\n        cacheFS: this._cacheFS,\n        config: this._config,\n        configString: this._cache.configString,\n        transformerConfig\n      });\n    }\n\n    return this._buildTransformResult(filename, cacheFilePath, content, transformer, shouldCallTransform, options, processed, sourceMapPath);\n  }\n\n  async transformSourceAsync(filepath, content, options) {\n    const filename = (0, _jestUtil().tryRealpath)(filepath);\n    const {\n      transformer,\n      transformerConfig = {}\n    } = this._getTransformer(filename) || {};\n    const cacheFilePath = await this._getFileCachePathAsync(filename, content, options);\n    const sourceMapPath = cacheFilePath + '.map'; // Ignore cache if `config.cache` is set (--no-cache)\n\n    const code = this._config.cache ? readCodeCacheFile(cacheFilePath) : null;\n\n    if (code) {\n      // This is broken: we return the code, and a path for the source map\n      // directly from the cache. But, nothing ensures the source map actually\n      // matches that source code. They could have gotten out-of-sync in case\n      // two separate processes write concurrently to the same cache files.\n      return {\n        code,\n        originalCode: content,\n        sourceMapPath\n      };\n    }\n\n    let processed = null;\n    let shouldCallTransform = false;\n\n    if (transformer && this.shouldTransform(filename)) {\n      shouldCallTransform = true;\n      const process = transformer.processAsync || transformer.process; // This is probably dead code since `_getTransformerAsync` already asserts this\n\n      invariant(typeof process === 'function', 'A transformer must always export either a `process` or `processAsync`');\n      processed = await process(content, filename, { ...options,\n        cacheFS: this._cacheFS,\n        config: this._config,\n        configString: this._cache.configString,\n        transformerConfig\n      });\n    }\n\n    return this._buildTransformResult(filename, cacheFilePath, content, transformer, shouldCallTransform, options, processed, sourceMapPath);\n  }\n\n  async _transformAndBuildScriptAsync(filename, options, transformOptions, fileSource) {\n    const {\n      isInternalModule\n    } = options;\n    let fileContent = fileSource !== null && fileSource !== void 0 ? fileSource : this._cacheFS.get(filename);\n\n    if (!fileContent) {\n      fileContent = fs().readFileSync(filename, 'utf8');\n\n      this._cacheFS.set(filename, fileContent);\n    }\n\n    const content = stripShebang(fileContent);\n    let code = content;\n    let sourceMapPath = null;\n    const willTransform = !isInternalModule && (transformOptions.instrument || this.shouldTransform(filename));\n\n    try {\n      if (willTransform) {\n        const transformedSource = await this.transformSourceAsync(filename, content, transformOptions);\n        code = transformedSource.code;\n        sourceMapPath = transformedSource.sourceMapPath;\n      }\n\n      return {\n        code,\n        originalCode: content,\n        sourceMapPath\n      };\n    } catch (e) {\n      throw (0, _enhanceUnexpectedTokenMessage.default)(e);\n    }\n  }\n\n  _transformAndBuildScript(filename, options, transformOptions, fileSource) {\n    const {\n      isInternalModule\n    } = options;\n    let fileContent = fileSource !== null && fileSource !== void 0 ? fileSource : this._cacheFS.get(filename);\n\n    if (!fileContent) {\n      fileContent = fs().readFileSync(filename, 'utf8');\n\n      this._cacheFS.set(filename, fileContent);\n    }\n\n    const content = stripShebang(fileContent);\n    let code = content;\n    let sourceMapPath = null;\n    const willTransform = !isInternalModule && (transformOptions.instrument || this.shouldTransform(filename));\n\n    try {\n      if (willTransform) {\n        const transformedSource = this.transformSource(filename, content, transformOptions);\n        code = transformedSource.code;\n        sourceMapPath = transformedSource.sourceMapPath;\n      }\n\n      return {\n        code,\n        originalCode: content,\n        sourceMapPath\n      };\n    } catch (e) {\n      throw (0, _enhanceUnexpectedTokenMessage.default)(e);\n    }\n  }\n\n  async transformAsync(filename, options, fileSource) {\n    const instrument = options.coverageProvider === 'babel' && (0, _shouldInstrument.default)(filename, options, this._config);\n    const scriptCacheKey = getScriptCacheKey(filename, instrument);\n\n    let result = this._cache.transformedFiles.get(scriptCacheKey);\n\n    if (result) {\n      return result;\n    }\n\n    result = await this._transformAndBuildScriptAsync(filename, options, { ...options,\n      instrument\n    }, fileSource);\n\n    if (scriptCacheKey) {\n      this._cache.transformedFiles.set(scriptCacheKey, result);\n    }\n\n    return result;\n  }\n\n  transform(filename, options, fileSource) {\n    const instrument = options.coverageProvider === 'babel' && (0, _shouldInstrument.default)(filename, options, this._config);\n    const scriptCacheKey = getScriptCacheKey(filename, instrument);\n\n    let result = this._cache.transformedFiles.get(scriptCacheKey);\n\n    if (result) {\n      return result;\n    }\n\n    result = this._transformAndBuildScript(filename, options, { ...options,\n      instrument\n    }, fileSource);\n\n    if (scriptCacheKey) {\n      this._cache.transformedFiles.set(scriptCacheKey, result);\n    }\n\n    return result;\n  }\n\n  transformJson(filename, options, fileSource) {\n    const {\n      isInternalModule\n    } = options;\n    const willTransform = !isInternalModule && this.shouldTransform(filename);\n\n    if (willTransform) {\n      const {\n        code: transformedJsonSource\n      } = this.transformSource(filename, fileSource, { ...options,\n        instrument: false\n      });\n      return transformedJsonSource;\n    }\n\n    return fileSource;\n  }\n\n  async requireAndTranspileModule(moduleName, callback) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n      applyInteropRequireDefault: true,\n      instrument: false,\n      supportsDynamicImport: false,\n      supportsExportNamespaceFrom: false,\n      supportsStaticESM: false,\n      supportsTopLevelAwait: false\n    };\n    let transforming = false;\n    const {\n      applyInteropRequireDefault,\n      ...transformOptions\n    } = options;\n    const revertHook = (0, _pirates().addHook)((code, filename) => {\n      try {\n        transforming = true;\n        return this.transformSource(filename, code, transformOptions).code || code;\n      } finally {\n        transforming = false;\n      }\n    }, {\n      exts: this._config.moduleFileExtensions.map(ext => `.${ext}`),\n      ignoreNodeModules: false,\n      matcher: filename => {\n        if (transforming) {\n          // Don't transform any dependency required by the transformer itself\n          return false;\n        }\n\n        return this.shouldTransform(filename);\n      }\n    });\n\n    try {\n      const module = await (0, _jestUtil().requireOrImportModule)(moduleName, applyInteropRequireDefault);\n\n      if (!callback) {\n        revertHook();\n        return module;\n      }\n\n      const cbResult = callback(module);\n\n      if ((0, _jestUtil().isPromise)(cbResult)) {\n        return waitForPromiseWithCleanup(cbResult, revertHook).then(() => module);\n      }\n\n      return module;\n    } finally {\n      revertHook();\n    }\n  }\n\n  shouldTransform(filename) {\n    const ignoreRegexp = this._cache.ignorePatternsRegExp;\n    const isIgnored = ignoreRegexp ? ignoreRegexp.test(filename) : false;\n    return this._config.transform.length !== 0 && !isIgnored;\n  }\n\n} // TODO: do we need to define the generics twice?\n\n\nasync function createTranspilingRequire(config) {\n  const transformer = await createScriptTransformer(config);\n  return async function requireAndTranspileModule(resolverPath) {\n    let applyInteropRequireDefault = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const transpiledModule = await transformer.requireAndTranspileModule(resolverPath, () => {}, {\n      applyInteropRequireDefault,\n      instrument: false,\n      supportsDynamicImport: false,\n      // this might be true, depending on node version.\n      supportsExportNamespaceFrom: false,\n      supportsStaticESM: false,\n      supportsTopLevelAwait: false\n    });\n    return transpiledModule;\n  };\n}\n\nconst removeFile = path => {\n  try {\n    fs().unlinkSync(path);\n  } catch {}\n};\n\nconst stripShebang = content => {\n  // If the file data starts with a shebang remove it. Leaves the empty line\n  // to keep stack trace line numbers correct.\n  if (content.startsWith('#!')) {\n    return content.replace(/^#!.*/, '');\n  } else {\n    return content;\n  }\n};\n/**\n * This is like `writeCacheFile` but with an additional sanity checksum. We\n * cannot use the same technique for source maps because we expose source map\n * cache file paths directly to callsites, with the expectation they can read\n * it right away. This is not a great system, because source map cache file\n * could get corrupted, out-of-sync, etc.\n */\n\n\nfunction writeCodeCacheFile(cachePath, code) {\n  const checksum = (0, _crypto().createHash)('md5').update(code).digest('hex');\n  writeCacheFile(cachePath, checksum + '\\n' + code);\n}\n/**\n * Read counterpart of `writeCodeCacheFile`. We verify that the content of the\n * file matches the checksum, in case some kind of corruption happened. This\n * could happen if an older version of `jest-runtime` writes non-atomically to\n * the same cache, for example.\n */\n\n\nfunction readCodeCacheFile(cachePath) {\n  const content = readCacheFile(cachePath);\n\n  if (content == null) {\n    return null;\n  }\n\n  const code = content.substring(33);\n  const checksum = (0, _crypto().createHash)('md5').update(code).digest('hex');\n\n  if (checksum === content.substring(0, 32)) {\n    return code;\n  }\n\n  return null;\n}\n/**\n * Writing to the cache atomically relies on 'rename' being atomic on most\n * file systems. Doing atomic write reduces the risk of corruption by avoiding\n * two processes to write to the same file at the same time. It also reduces\n * the risk of reading a file that's being overwritten at the same time.\n */\n\n\nconst writeCacheFile = (cachePath, fileData) => {\n  try {\n    (0, _writeFileAtomic().sync)(cachePath, fileData, {\n      encoding: 'utf8',\n      fsync: false\n    });\n  } catch (e) {\n    if (cacheWriteErrorSafeToIgnore(e, cachePath)) {\n      return;\n    }\n\n    e.message = 'jest: failed to cache transform results in: ' + cachePath + '\\nFailure message: ' + e.message;\n    removeFile(cachePath);\n    throw e;\n  }\n};\n/**\n * On Windows, renames are not atomic, leading to EPERM exceptions when two\n * processes attempt to rename to the same target file at the same time.\n * If the target file exists we can be reasonably sure another process has\n * legitimately won a cache write race and ignore the error.\n */\n\n\nconst cacheWriteErrorSafeToIgnore = (e, cachePath) => process.platform === 'win32' && e.code === 'EPERM' && fs().existsSync(cachePath);\n\nconst readCacheFile = cachePath => {\n  if (!fs().existsSync(cachePath)) {\n    return null;\n  }\n\n  let fileData;\n\n  try {\n    fileData = fs().readFileSync(cachePath, 'utf8');\n  } catch (e) {\n    e.message = 'jest: failed to read cache file: ' + cachePath + '\\nFailure message: ' + e.message;\n    removeFile(cachePath);\n    throw e;\n  }\n\n  if (fileData == null) {\n    // We must have somehow created the file but failed to write to it,\n    // let's delete it and retry.\n    removeFile(cachePath);\n  }\n\n  return fileData;\n};\n\nconst getScriptCacheKey = (filename, instrument) => {\n  const mtime = fs().statSync(filename).mtime;\n  return filename + '_' + mtime.getTime() + (instrument ? '_instrumented' : '');\n};\n\nconst calcIgnorePatternRegExp = config => {\n  if (!config.transformIgnorePatterns || config.transformIgnorePatterns.length === 0) {\n    return undefined;\n  }\n\n  return new RegExp(config.transformIgnorePatterns.join('|'));\n};\n\nconst calcTransformRegExp = config => {\n  if (!config.transform.length) {\n    return undefined;\n  }\n\n  const transformRegexp = [];\n\n  for (let i = 0; i < config.transform.length; i++) {\n    transformRegexp.push([new RegExp(config.transform[i][0]), config.transform[i][1], config.transform[i][2]]);\n  }\n\n  return transformRegexp;\n};\n\nfunction invariant(condition, message) {\n  if (!condition) {\n    throw new Error(message);\n  }\n}\n\nfunction assertSyncTransformer(transformer, name) {\n  invariant(name);\n  invariant(typeof transformer.process === 'function', (0, _runtimeErrorsAndWarnings.makeInvalidSyncTransformerError)(name));\n}\n\nasync function createScriptTransformer(config) {\n  let cacheFS = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Map();\n  const transformer = new ScriptTransformer(config, cacheFS);\n  await transformer.loadTransformers();\n  return transformer;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","createScriptTransformer","createTranspilingRequire","_crypto","data","require","path","_interopRequireWildcard","_core","_babelPluginIstanbul","_interopRequireDefault","_convertSourceMap","_fastJsonStableStringify","fs","_pirates","_slash","_writeFileAtomic","_jestHasteMap","_jestUtil","_enhanceUnexpectedTokenMessage","_runtimeErrorsAndWarnings","_shouldInstrument","obj","__esModule","default","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","cache","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","_defineProperty","enumerable","configurable","writable","version","VERSION","projectCaches","Map","CACHE_VERSION","waitForPromiseWithCleanup","promise","cleanup","ScriptTransformer","constructor","_config","_cacheFS","configString","projectCache","ignorePatternsRegExp","calcIgnorePatternRegExp","transformRegExp","calcTransformRegExp","transformedFiles","_cache","_buildCacheKeyFromFileInfo","fileData","filename","transformOptions","transformerCacheKey","createHash","update","digest","instrument","_getCacheKey","options","transformer","transformerConfig","_getTransformer","undefined","cacheFS","config","getCacheKey","_getCacheKeyAsync","getCacheKeyAsync","_createFolderFromCacheKey","cacheKey","HasteMapClass","getStatic","baseCacheDir","getCacheFilePath","cacheDirectory","name","cacheDir","join","cacheFilenamePrefix","basename","extname","replace","cachePath","createDirectory","_getFileCachePath","content","_getFileCachePathAsync","_getTransformPath","i","length","test","loadTransformers","Promise","all","transform","map","transformPath","requireOrImportModule","Error","makeInvalidTransformerError","createTransformer","process","processAsync","res","_transformCache","_transformsAreLoaded","cached","_instrumentFile","input","canMapToInput","inputCode","code","inputMap","result","transformSync","auxiliaryCommentBefore","babelrc","caller","supportsDynamicImport","supportsExportNamespaceFrom","supportsStaticESM","supportsTopLevelAwait","configFile","plugins","compact","cwd","rootDir","exclude","extension","inputSourceMap","useInlineSourceMaps","sourceMaps","_buildTransformResult","cacheFilePath","shouldCallTransform","processed","sourceMapPath","transformed","makeInvalidReturnValueError","inlineSourceMap","fromSource","toObject","invariant","console","warn","makeInvalidSourceMapWarning","transformWillInstrument","canInstrument","shouldEmitSourceMaps","instrumented","sourceMapContent","JSON","stringify","writeCacheFile","writeCodeCacheFile","originalCode","transformSource","filepath","tryRealpath","readCodeCacheFile","shouldTransform","assertSyncTransformer","transformSourceAsync","_transformAndBuildScriptAsync","fileSource","isInternalModule","fileContent","readFileSync","stripShebang","willTransform","transformedSource","e","_transformAndBuildScript","transformAsync","coverageProvider","scriptCacheKey","getScriptCacheKey","transformJson","transformedJsonSource","requireAndTranspileModule","moduleName","callback","applyInteropRequireDefault","transforming","revertHook","addHook","exts","moduleFileExtensions","ext","ignoreNodeModules","matcher","module","cbResult","isPromise","then","ignoreRegexp","isIgnored","resolverPath","transpiledModule","removeFile","unlinkSync","startsWith","checksum","readCacheFile","substring","sync","encoding","fsync","cacheWriteErrorSafeToIgnore","message","platform","existsSync","mtime","statSync","getTime","transformIgnorePatterns","RegExp","transformRegexp","push","condition","makeInvalidSyncTransformerError"],"sources":["/Users/lincolnkushwah/Desktop/All/React Projects/house_joy_new/node_modules/@jest/transform/build/ScriptTransformer.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.createScriptTransformer = createScriptTransformer;\nexports.createTranspilingRequire = createTranspilingRequire;\n\nfunction _crypto() {\n  const data = require('crypto');\n\n  _crypto = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction path() {\n  const data = _interopRequireWildcard(require('path'));\n\n  path = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _core() {\n  const data = require('@babel/core');\n\n  _core = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _babelPluginIstanbul() {\n  const data = _interopRequireDefault(require('babel-plugin-istanbul'));\n\n  _babelPluginIstanbul = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _convertSourceMap() {\n  const data = require('convert-source-map');\n\n  _convertSourceMap = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _fastJsonStableStringify() {\n  const data = _interopRequireDefault(require('fast-json-stable-stringify'));\n\n  _fastJsonStableStringify = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction fs() {\n  const data = _interopRequireWildcard(require('graceful-fs'));\n\n  fs = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _pirates() {\n  const data = require('pirates');\n\n  _pirates = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _slash() {\n  const data = _interopRequireDefault(require('slash'));\n\n  _slash = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _writeFileAtomic() {\n  const data = require('write-file-atomic');\n\n  _writeFileAtomic = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestHasteMap() {\n  const data = _interopRequireDefault(require('jest-haste-map'));\n\n  _jestHasteMap = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestUtil() {\n  const data = require('jest-util');\n\n  _jestUtil = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _enhanceUnexpectedTokenMessage = _interopRequireDefault(\n  require('./enhanceUnexpectedTokenMessage')\n);\n\nvar _runtimeErrorsAndWarnings = require('./runtimeErrorsAndWarnings');\n\nvar _shouldInstrument = _interopRequireDefault(require('./shouldInstrument'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== 'function') return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {\n    return {default: obj};\n  }\n  var cache = _getRequireWildcardCache(nodeInterop);\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor =\n    Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (key !== 'default' && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor\n        ? Object.getOwnPropertyDescriptor(obj, key)\n        : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\n// Use `require` to avoid TS rootDir\nconst {version: VERSION} = require('../package.json');\n\n// This data structure is used to avoid recalculating some data every time that\n// we need to transform a file. Since ScriptTransformer is instantiated for each\n// file we need to keep this object in the local scope of this module.\nconst projectCaches = new Map(); // To reset the cache for specific changesets (rather than package version).\n\nconst CACHE_VERSION = '1';\n\nasync function waitForPromiseWithCleanup(promise, cleanup) {\n  try {\n    await promise;\n  } finally {\n    cleanup();\n  }\n}\n\nclass ScriptTransformer {\n  constructor(_config, _cacheFS) {\n    _defineProperty(this, '_cache', void 0);\n\n    _defineProperty(this, '_transformCache', new Map());\n\n    _defineProperty(this, '_transformsAreLoaded', false);\n\n    this._config = _config;\n    this._cacheFS = _cacheFS;\n    const configString = (0, _fastJsonStableStringify().default)(this._config);\n    let projectCache = projectCaches.get(configString);\n\n    if (!projectCache) {\n      projectCache = {\n        configString,\n        ignorePatternsRegExp: calcIgnorePatternRegExp(this._config),\n        transformRegExp: calcTransformRegExp(this._config),\n        transformedFiles: new Map()\n      };\n      projectCaches.set(configString, projectCache);\n    }\n\n    this._cache = projectCache;\n  }\n\n  _buildCacheKeyFromFileInfo(\n    fileData,\n    filename,\n    transformOptions,\n    transformerCacheKey\n  ) {\n    if (transformerCacheKey) {\n      return (0, _crypto().createHash)('md5')\n        .update(transformerCacheKey)\n        .update(CACHE_VERSION)\n        .digest('hex');\n    }\n\n    return (0, _crypto().createHash)('md5')\n      .update(fileData)\n      .update(transformOptions.configString)\n      .update(transformOptions.instrument ? 'instrument' : '')\n      .update(filename)\n      .update(CACHE_VERSION)\n      .digest('hex');\n  }\n\n  _getCacheKey(fileData, filename, options) {\n    const configString = this._cache.configString;\n    const {transformer, transformerConfig = {}} =\n      this._getTransformer(filename) || {};\n    let transformerCacheKey = undefined;\n    const transformOptions = {\n      ...options,\n      cacheFS: this._cacheFS,\n      config: this._config,\n      configString,\n      transformerConfig\n    };\n\n    if (\n      typeof (transformer === null || transformer === void 0\n        ? void 0\n        : transformer.getCacheKey) === 'function'\n    ) {\n      transformerCacheKey = transformer.getCacheKey(\n        fileData,\n        filename,\n        transformOptions\n      );\n    }\n\n    return this._buildCacheKeyFromFileInfo(\n      fileData,\n      filename,\n      transformOptions,\n      transformerCacheKey\n    );\n  }\n\n  async _getCacheKeyAsync(fileData, filename, options) {\n    const configString = this._cache.configString;\n    const {transformer, transformerConfig = {}} =\n      this._getTransformer(filename) || {};\n    let transformerCacheKey = undefined;\n    const transformOptions = {\n      ...options,\n      cacheFS: this._cacheFS,\n      config: this._config,\n      configString,\n      transformerConfig\n    };\n\n    if (transformer) {\n      const getCacheKey =\n        transformer.getCacheKeyAsync || transformer.getCacheKey;\n\n      if (typeof getCacheKey === 'function') {\n        transformerCacheKey = await getCacheKey(\n          fileData,\n          filename,\n          transformOptions\n        );\n      }\n    }\n\n    return this._buildCacheKeyFromFileInfo(\n      fileData,\n      filename,\n      transformOptions,\n      transformerCacheKey\n    );\n  }\n\n  _createFolderFromCacheKey(filename, cacheKey) {\n    const HasteMapClass = _jestHasteMap().default.getStatic(this._config);\n\n    const baseCacheDir = HasteMapClass.getCacheFilePath(\n      this._config.cacheDirectory,\n      'jest-transform-cache-' + this._config.name,\n      VERSION\n    ); // Create sub folders based on the cacheKey to avoid creating one\n    // directory with many files.\n\n    const cacheDir = path().join(baseCacheDir, cacheKey[0] + cacheKey[1]);\n    const cacheFilenamePrefix = path()\n      .basename(filename, path().extname(filename))\n      .replace(/\\W/g, '');\n    const cachePath = (0, _slash().default)(\n      path().join(cacheDir, cacheFilenamePrefix + '_' + cacheKey)\n    );\n    (0, _jestUtil().createDirectory)(cacheDir);\n    return cachePath;\n  }\n\n  _getFileCachePath(filename, content, options) {\n    const cacheKey = this._getCacheKey(content, filename, options);\n\n    return this._createFolderFromCacheKey(filename, cacheKey);\n  }\n\n  async _getFileCachePathAsync(filename, content, options) {\n    const cacheKey = await this._getCacheKeyAsync(content, filename, options);\n    return this._createFolderFromCacheKey(filename, cacheKey);\n  }\n\n  _getTransformPath(filename) {\n    const transformRegExp = this._cache.transformRegExp;\n\n    if (!transformRegExp) {\n      return undefined;\n    }\n\n    for (let i = 0; i < transformRegExp.length; i++) {\n      if (transformRegExp[i][0].test(filename)) {\n        return transformRegExp[i][1];\n      }\n    }\n\n    return undefined;\n  }\n\n  async loadTransformers() {\n    await Promise.all(\n      this._config.transform.map(\n        async ([, transformPath, transformerConfig]) => {\n          let transformer = await (0, _jestUtil().requireOrImportModule)(\n            transformPath\n          );\n\n          if (!transformer) {\n            throw new Error(\n              (0, _runtimeErrorsAndWarnings.makeInvalidTransformerError)(\n                transformPath\n              )\n            );\n          }\n\n          if (typeof transformer.createTransformer === 'function') {\n            transformer = transformer.createTransformer(transformerConfig);\n          }\n\n          if (\n            typeof transformer.process !== 'function' &&\n            typeof transformer.processAsync !== 'function'\n          ) {\n            throw new Error(\n              (0, _runtimeErrorsAndWarnings.makeInvalidTransformerError)(\n                transformPath\n              )\n            );\n          }\n\n          const res = {\n            transformer,\n            transformerConfig\n          };\n\n          this._transformCache.set(transformPath, res);\n        }\n      )\n    );\n    this._transformsAreLoaded = true;\n  }\n\n  _getTransformer(filename) {\n    if (!this._transformsAreLoaded) {\n      throw new Error(\n        'Jest: Transformers have not been loaded yet - make sure to run `loadTransformers` and wait for it to complete before starting to transform files'\n      );\n    }\n\n    if (this._config.transform.length === 0) {\n      return null;\n    }\n\n    const transformPath = this._getTransformPath(filename);\n\n    if (!transformPath) {\n      return null;\n    }\n\n    const cached = this._transformCache.get(transformPath);\n\n    if (cached) {\n      return cached;\n    }\n\n    throw new Error(\n      `Jest was unable to load the transformer defined for ${filename}. This is a bug in Jest, please open up an issue`\n    );\n  }\n\n  _instrumentFile(filename, input, canMapToInput, options) {\n    const inputCode = typeof input === 'string' ? input : input.code;\n    const inputMap = typeof input === 'string' ? null : input.map;\n    const result = (0, _core().transformSync)(inputCode, {\n      auxiliaryCommentBefore: ' istanbul ignore next ',\n      babelrc: false,\n      caller: {\n        name: '@jest/transform',\n        supportsDynamicImport: options.supportsDynamicImport,\n        supportsExportNamespaceFrom: options.supportsExportNamespaceFrom,\n        supportsStaticESM: options.supportsStaticESM,\n        supportsTopLevelAwait: options.supportsTopLevelAwait\n      },\n      configFile: false,\n      filename,\n      plugins: [\n        [\n          _babelPluginIstanbul().default,\n          {\n            compact: false,\n            // files outside `cwd` will not be instrumented\n            cwd: this._config.rootDir,\n            exclude: [],\n            extension: false,\n            inputSourceMap: inputMap,\n            useInlineSourceMaps: false\n          }\n        ]\n      ],\n      sourceMaps: canMapToInput ? 'both' : false\n    });\n\n    if (result && result.code) {\n      return result;\n    }\n\n    return input;\n  }\n\n  _buildTransformResult(\n    filename,\n    cacheFilePath,\n    content,\n    transformer,\n    shouldCallTransform,\n    options,\n    processed,\n    sourceMapPath\n  ) {\n    let transformed = {\n      code: content,\n      map: null\n    };\n\n    if (transformer && shouldCallTransform) {\n      if (typeof processed === 'string') {\n        transformed.code = processed;\n      } else if (processed != null && typeof processed.code === 'string') {\n        transformed = processed;\n      } else {\n        throw new Error(\n          (0, _runtimeErrorsAndWarnings.makeInvalidReturnValueError)()\n        );\n      }\n    }\n\n    if (!transformed.map) {\n      try {\n        //Could be a potential freeze here.\n        //See: https://github.com/facebook/jest/pull/5177#discussion_r158883570\n        const inlineSourceMap = (0, _convertSourceMap().fromSource)(\n          transformed.code\n        );\n\n        if (inlineSourceMap) {\n          transformed.map = inlineSourceMap.toObject();\n        }\n      } catch {\n        const transformPath = this._getTransformPath(filename);\n\n        invariant(transformPath);\n        console.warn(\n          (0, _runtimeErrorsAndWarnings.makeInvalidSourceMapWarning)(\n            filename,\n            transformPath\n          )\n        );\n      }\n    } // That means that the transform has a custom instrumentation\n    // logic and will handle it based on `config.collectCoverage` option\n\n    const transformWillInstrument =\n      shouldCallTransform && transformer && transformer.canInstrument; // Apply instrumentation to the code if necessary, keeping the instrumented code and new map\n\n    let map = transformed.map;\n    let code;\n\n    if (!transformWillInstrument && options.instrument) {\n      /**\n       * We can map the original source code to the instrumented code ONLY if\n       * - the process of transforming the code produced a source map e.g. ts-jest\n       * - we did not transform the source code\n       *\n       * Otherwise we cannot make any statements about how the instrumented code corresponds to the original code,\n       * and we should NOT emit any source maps\n       *\n       */\n      const shouldEmitSourceMaps =\n        (transformer != null && map != null) || transformer == null;\n\n      const instrumented = this._instrumentFile(\n        filename,\n        transformed,\n        shouldEmitSourceMaps,\n        options\n      );\n\n      code =\n        typeof instrumented === 'string' ? instrumented : instrumented.code;\n      map = typeof instrumented === 'string' ? null : instrumented.map;\n    } else {\n      code = transformed.code;\n    }\n\n    if (map) {\n      const sourceMapContent =\n        typeof map === 'string' ? map : JSON.stringify(map);\n      invariant(sourceMapPath, 'We should always have default sourceMapPath');\n      writeCacheFile(sourceMapPath, sourceMapContent);\n    } else {\n      sourceMapPath = null;\n    }\n\n    writeCodeCacheFile(cacheFilePath, code);\n    return {\n      code,\n      originalCode: content,\n      sourceMapPath\n    };\n  }\n\n  transformSource(filepath, content, options) {\n    const filename = (0, _jestUtil().tryRealpath)(filepath);\n    const {transformer, transformerConfig = {}} =\n      this._getTransformer(filename) || {};\n\n    const cacheFilePath = this._getFileCachePath(filename, content, options);\n\n    const sourceMapPath = cacheFilePath + '.map'; // Ignore cache if `config.cache` is set (--no-cache)\n\n    const code = this._config.cache ? readCodeCacheFile(cacheFilePath) : null;\n\n    if (code) {\n      // This is broken: we return the code, and a path for the source map\n      // directly from the cache. But, nothing ensures the source map actually\n      // matches that source code. They could have gotten out-of-sync in case\n      // two separate processes write concurrently to the same cache files.\n      return {\n        code,\n        originalCode: content,\n        sourceMapPath\n      };\n    }\n\n    let processed = null;\n    let shouldCallTransform = false;\n\n    if (transformer && this.shouldTransform(filename)) {\n      shouldCallTransform = true;\n      assertSyncTransformer(transformer, this._getTransformPath(filename));\n      processed = transformer.process(content, filename, {\n        ...options,\n        cacheFS: this._cacheFS,\n        config: this._config,\n        configString: this._cache.configString,\n        transformerConfig\n      });\n    }\n\n    return this._buildTransformResult(\n      filename,\n      cacheFilePath,\n      content,\n      transformer,\n      shouldCallTransform,\n      options,\n      processed,\n      sourceMapPath\n    );\n  }\n\n  async transformSourceAsync(filepath, content, options) {\n    const filename = (0, _jestUtil().tryRealpath)(filepath);\n    const {transformer, transformerConfig = {}} =\n      this._getTransformer(filename) || {};\n    const cacheFilePath = await this._getFileCachePathAsync(\n      filename,\n      content,\n      options\n    );\n    const sourceMapPath = cacheFilePath + '.map'; // Ignore cache if `config.cache` is set (--no-cache)\n\n    const code = this._config.cache ? readCodeCacheFile(cacheFilePath) : null;\n\n    if (code) {\n      // This is broken: we return the code, and a path for the source map\n      // directly from the cache. But, nothing ensures the source map actually\n      // matches that source code. They could have gotten out-of-sync in case\n      // two separate processes write concurrently to the same cache files.\n      return {\n        code,\n        originalCode: content,\n        sourceMapPath\n      };\n    }\n\n    let processed = null;\n    let shouldCallTransform = false;\n\n    if (transformer && this.shouldTransform(filename)) {\n      shouldCallTransform = true;\n      const process = transformer.processAsync || transformer.process; // This is probably dead code since `_getTransformerAsync` already asserts this\n\n      invariant(\n        typeof process === 'function',\n        'A transformer must always export either a `process` or `processAsync`'\n      );\n      processed = await process(content, filename, {\n        ...options,\n        cacheFS: this._cacheFS,\n        config: this._config,\n        configString: this._cache.configString,\n        transformerConfig\n      });\n    }\n\n    return this._buildTransformResult(\n      filename,\n      cacheFilePath,\n      content,\n      transformer,\n      shouldCallTransform,\n      options,\n      processed,\n      sourceMapPath\n    );\n  }\n\n  async _transformAndBuildScriptAsync(\n    filename,\n    options,\n    transformOptions,\n    fileSource\n  ) {\n    const {isInternalModule} = options;\n    let fileContent =\n      fileSource !== null && fileSource !== void 0\n        ? fileSource\n        : this._cacheFS.get(filename);\n\n    if (!fileContent) {\n      fileContent = fs().readFileSync(filename, 'utf8');\n\n      this._cacheFS.set(filename, fileContent);\n    }\n\n    const content = stripShebang(fileContent);\n    let code = content;\n    let sourceMapPath = null;\n    const willTransform =\n      !isInternalModule &&\n      (transformOptions.instrument || this.shouldTransform(filename));\n\n    try {\n      if (willTransform) {\n        const transformedSource = await this.transformSourceAsync(\n          filename,\n          content,\n          transformOptions\n        );\n        code = transformedSource.code;\n        sourceMapPath = transformedSource.sourceMapPath;\n      }\n\n      return {\n        code,\n        originalCode: content,\n        sourceMapPath\n      };\n    } catch (e) {\n      throw (0, _enhanceUnexpectedTokenMessage.default)(e);\n    }\n  }\n\n  _transformAndBuildScript(filename, options, transformOptions, fileSource) {\n    const {isInternalModule} = options;\n    let fileContent =\n      fileSource !== null && fileSource !== void 0\n        ? fileSource\n        : this._cacheFS.get(filename);\n\n    if (!fileContent) {\n      fileContent = fs().readFileSync(filename, 'utf8');\n\n      this._cacheFS.set(filename, fileContent);\n    }\n\n    const content = stripShebang(fileContent);\n    let code = content;\n    let sourceMapPath = null;\n    const willTransform =\n      !isInternalModule &&\n      (transformOptions.instrument || this.shouldTransform(filename));\n\n    try {\n      if (willTransform) {\n        const transformedSource = this.transformSource(\n          filename,\n          content,\n          transformOptions\n        );\n        code = transformedSource.code;\n        sourceMapPath = transformedSource.sourceMapPath;\n      }\n\n      return {\n        code,\n        originalCode: content,\n        sourceMapPath\n      };\n    } catch (e) {\n      throw (0, _enhanceUnexpectedTokenMessage.default)(e);\n    }\n  }\n\n  async transformAsync(filename, options, fileSource) {\n    const instrument =\n      options.coverageProvider === 'babel' &&\n      (0, _shouldInstrument.default)(filename, options, this._config);\n    const scriptCacheKey = getScriptCacheKey(filename, instrument);\n\n    let result = this._cache.transformedFiles.get(scriptCacheKey);\n\n    if (result) {\n      return result;\n    }\n\n    result = await this._transformAndBuildScriptAsync(\n      filename,\n      options,\n      {...options, instrument},\n      fileSource\n    );\n\n    if (scriptCacheKey) {\n      this._cache.transformedFiles.set(scriptCacheKey, result);\n    }\n\n    return result;\n  }\n\n  transform(filename, options, fileSource) {\n    const instrument =\n      options.coverageProvider === 'babel' &&\n      (0, _shouldInstrument.default)(filename, options, this._config);\n    const scriptCacheKey = getScriptCacheKey(filename, instrument);\n\n    let result = this._cache.transformedFiles.get(scriptCacheKey);\n\n    if (result) {\n      return result;\n    }\n\n    result = this._transformAndBuildScript(\n      filename,\n      options,\n      {...options, instrument},\n      fileSource\n    );\n\n    if (scriptCacheKey) {\n      this._cache.transformedFiles.set(scriptCacheKey, result);\n    }\n\n    return result;\n  }\n\n  transformJson(filename, options, fileSource) {\n    const {isInternalModule} = options;\n    const willTransform = !isInternalModule && this.shouldTransform(filename);\n\n    if (willTransform) {\n      const {code: transformedJsonSource} = this.transformSource(\n        filename,\n        fileSource,\n        {...options, instrument: false}\n      );\n      return transformedJsonSource;\n    }\n\n    return fileSource;\n  }\n\n  async requireAndTranspileModule(\n    moduleName,\n    callback,\n    options = {\n      applyInteropRequireDefault: true,\n      instrument: false,\n      supportsDynamicImport: false,\n      supportsExportNamespaceFrom: false,\n      supportsStaticESM: false,\n      supportsTopLevelAwait: false\n    }\n  ) {\n    let transforming = false;\n    const {applyInteropRequireDefault, ...transformOptions} = options;\n    const revertHook = (0, _pirates().addHook)(\n      (code, filename) => {\n        try {\n          transforming = true;\n          return (\n            this.transformSource(filename, code, transformOptions).code || code\n          );\n        } finally {\n          transforming = false;\n        }\n      },\n      {\n        exts: this._config.moduleFileExtensions.map(ext => `.${ext}`),\n        ignoreNodeModules: false,\n        matcher: filename => {\n          if (transforming) {\n            // Don't transform any dependency required by the transformer itself\n            return false;\n          }\n\n          return this.shouldTransform(filename);\n        }\n      }\n    );\n\n    try {\n      const module = await (0, _jestUtil().requireOrImportModule)(\n        moduleName,\n        applyInteropRequireDefault\n      );\n\n      if (!callback) {\n        revertHook();\n        return module;\n      }\n\n      const cbResult = callback(module);\n\n      if ((0, _jestUtil().isPromise)(cbResult)) {\n        return waitForPromiseWithCleanup(cbResult, revertHook).then(\n          () => module\n        );\n      }\n\n      return module;\n    } finally {\n      revertHook();\n    }\n  }\n\n  shouldTransform(filename) {\n    const ignoreRegexp = this._cache.ignorePatternsRegExp;\n    const isIgnored = ignoreRegexp ? ignoreRegexp.test(filename) : false;\n    return this._config.transform.length !== 0 && !isIgnored;\n  }\n} // TODO: do we need to define the generics twice?\n\nasync function createTranspilingRequire(config) {\n  const transformer = await createScriptTransformer(config);\n  return async function requireAndTranspileModule(\n    resolverPath,\n    applyInteropRequireDefault = false\n  ) {\n    const transpiledModule = await transformer.requireAndTranspileModule(\n      resolverPath,\n      () => {},\n      {\n        applyInteropRequireDefault,\n        instrument: false,\n        supportsDynamicImport: false,\n        // this might be true, depending on node version.\n        supportsExportNamespaceFrom: false,\n        supportsStaticESM: false,\n        supportsTopLevelAwait: false\n      }\n    );\n    return transpiledModule;\n  };\n}\n\nconst removeFile = path => {\n  try {\n    fs().unlinkSync(path);\n  } catch {}\n};\n\nconst stripShebang = content => {\n  // If the file data starts with a shebang remove it. Leaves the empty line\n  // to keep stack trace line numbers correct.\n  if (content.startsWith('#!')) {\n    return content.replace(/^#!.*/, '');\n  } else {\n    return content;\n  }\n};\n/**\n * This is like `writeCacheFile` but with an additional sanity checksum. We\n * cannot use the same technique for source maps because we expose source map\n * cache file paths directly to callsites, with the expectation they can read\n * it right away. This is not a great system, because source map cache file\n * could get corrupted, out-of-sync, etc.\n */\n\nfunction writeCodeCacheFile(cachePath, code) {\n  const checksum = (0, _crypto().createHash)('md5').update(code).digest('hex');\n  writeCacheFile(cachePath, checksum + '\\n' + code);\n}\n/**\n * Read counterpart of `writeCodeCacheFile`. We verify that the content of the\n * file matches the checksum, in case some kind of corruption happened. This\n * could happen if an older version of `jest-runtime` writes non-atomically to\n * the same cache, for example.\n */\n\nfunction readCodeCacheFile(cachePath) {\n  const content = readCacheFile(cachePath);\n\n  if (content == null) {\n    return null;\n  }\n\n  const code = content.substring(33);\n  const checksum = (0, _crypto().createHash)('md5').update(code).digest('hex');\n\n  if (checksum === content.substring(0, 32)) {\n    return code;\n  }\n\n  return null;\n}\n/**\n * Writing to the cache atomically relies on 'rename' being atomic on most\n * file systems. Doing atomic write reduces the risk of corruption by avoiding\n * two processes to write to the same file at the same time. It also reduces\n * the risk of reading a file that's being overwritten at the same time.\n */\n\nconst writeCacheFile = (cachePath, fileData) => {\n  try {\n    (0, _writeFileAtomic().sync)(cachePath, fileData, {\n      encoding: 'utf8',\n      fsync: false\n    });\n  } catch (e) {\n    if (cacheWriteErrorSafeToIgnore(e, cachePath)) {\n      return;\n    }\n\n    e.message =\n      'jest: failed to cache transform results in: ' +\n      cachePath +\n      '\\nFailure message: ' +\n      e.message;\n    removeFile(cachePath);\n    throw e;\n  }\n};\n/**\n * On Windows, renames are not atomic, leading to EPERM exceptions when two\n * processes attempt to rename to the same target file at the same time.\n * If the target file exists we can be reasonably sure another process has\n * legitimately won a cache write race and ignore the error.\n */\n\nconst cacheWriteErrorSafeToIgnore = (e, cachePath) =>\n  process.platform === 'win32' &&\n  e.code === 'EPERM' &&\n  fs().existsSync(cachePath);\n\nconst readCacheFile = cachePath => {\n  if (!fs().existsSync(cachePath)) {\n    return null;\n  }\n\n  let fileData;\n\n  try {\n    fileData = fs().readFileSync(cachePath, 'utf8');\n  } catch (e) {\n    e.message =\n      'jest: failed to read cache file: ' +\n      cachePath +\n      '\\nFailure message: ' +\n      e.message;\n    removeFile(cachePath);\n    throw e;\n  }\n\n  if (fileData == null) {\n    // We must have somehow created the file but failed to write to it,\n    // let's delete it and retry.\n    removeFile(cachePath);\n  }\n\n  return fileData;\n};\n\nconst getScriptCacheKey = (filename, instrument) => {\n  const mtime = fs().statSync(filename).mtime;\n  return filename + '_' + mtime.getTime() + (instrument ? '_instrumented' : '');\n};\n\nconst calcIgnorePatternRegExp = config => {\n  if (\n    !config.transformIgnorePatterns ||\n    config.transformIgnorePatterns.length === 0\n  ) {\n    return undefined;\n  }\n\n  return new RegExp(config.transformIgnorePatterns.join('|'));\n};\n\nconst calcTransformRegExp = config => {\n  if (!config.transform.length) {\n    return undefined;\n  }\n\n  const transformRegexp = [];\n\n  for (let i = 0; i < config.transform.length; i++) {\n    transformRegexp.push([\n      new RegExp(config.transform[i][0]),\n      config.transform[i][1],\n      config.transform[i][2]\n    ]);\n  }\n\n  return transformRegexp;\n};\n\nfunction invariant(condition, message) {\n  if (!condition) {\n    throw new Error(message);\n  }\n}\n\nfunction assertSyncTransformer(transformer, name) {\n  invariant(name);\n  invariant(\n    typeof transformer.process === 'function',\n    (0, _runtimeErrorsAndWarnings.makeInvalidSyncTransformerError)(name)\n  );\n}\n\nasync function createScriptTransformer(config, cacheFS = new Map()) {\n  const transformer = new ScriptTransformer(config, cacheFS);\n  await transformer.loadTransformers();\n  return transformer;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}