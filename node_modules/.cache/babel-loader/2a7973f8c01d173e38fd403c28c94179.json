{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\n\nfunction os() {\n  const data = _interopRequireWildcard(require('os'));\n\n  os = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction path() {\n  const data = _interopRequireWildcard(require('path'));\n\n  path = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _micromatch() {\n  const data = _interopRequireDefault(require('micromatch'));\n\n  _micromatch = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestConfig() {\n  const data = require('jest-config');\n\n  _jestConfig = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestRegexUtil() {\n  const data = require('jest-regex-util');\n\n  _jestRegexUtil = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestResolveDependencies() {\n  const data = require('jest-resolve-dependencies');\n\n  _jestResolveDependencies = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestSnapshot() {\n  const data = require('jest-snapshot');\n\n  _jestSnapshot = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestUtil() {\n  const data = require('jest-util');\n\n  _jestUtil = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== 'function') return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== 'object' && typeof obj !== 'function') {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache(nodeInterop);\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (key !== 'default' && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nconst regexToMatcher = testRegex => {\n  const regexes = testRegex.map(testRegex => new RegExp(testRegex));\n  return path => regexes.some(regex => {\n    const result = regex.test(path); // prevent stateful regexes from breaking, just in case\n\n    regex.lastIndex = 0;\n    return result;\n  });\n};\n\nconst toTests = (context, tests) => tests.map(path => ({\n  context,\n  duration: undefined,\n  path\n}));\n\nconst hasSCM = changedFilesInfo => {\n  const {\n    repos\n  } = changedFilesInfo; // no SCM (git/hg/...) is found in any of the roots.\n\n  const noSCM = Object.values(repos).every(scm => scm.size === 0);\n  return !noSCM;\n};\n\nclass SearchSource {\n  constructor(context) {\n    _defineProperty(this, '_context', void 0);\n\n    _defineProperty(this, '_dependencyResolver', void 0);\n\n    _defineProperty(this, '_testPathCases', []);\n\n    const {\n      config\n    } = context;\n    this._context = context;\n    this._dependencyResolver = null;\n    const rootPattern = new RegExp(config.roots.map(dir => (0, _jestRegexUtil().escapePathForRegex)(dir + path().sep)).join('|'));\n\n    this._testPathCases.push({\n      isMatch: path => rootPattern.test(path),\n      stat: 'roots'\n    });\n\n    if (config.testMatch.length) {\n      this._testPathCases.push({\n        isMatch: (0, _jestUtil().globsToMatcher)(config.testMatch),\n        stat: 'testMatch'\n      });\n    }\n\n    if (config.testPathIgnorePatterns.length) {\n      const testIgnorePatternsRegex = new RegExp(config.testPathIgnorePatterns.join('|'));\n\n      this._testPathCases.push({\n        isMatch: path => !testIgnorePatternsRegex.test(path),\n        stat: 'testPathIgnorePatterns'\n      });\n    }\n\n    if (config.testRegex.length) {\n      this._testPathCases.push({\n        isMatch: regexToMatcher(config.testRegex),\n        stat: 'testRegex'\n      });\n    }\n  }\n\n  async _getOrBuildDependencyResolver() {\n    if (!this._dependencyResolver) {\n      this._dependencyResolver = new (_jestResolveDependencies().DependencyResolver)(this._context.resolver, this._context.hasteFS, await (0, _jestSnapshot().buildSnapshotResolver)(this._context.config));\n    }\n\n    return this._dependencyResolver;\n  }\n\n  _filterTestPathsWithStats(allPaths, testPathPattern) {\n    const data = {\n      stats: {\n        roots: 0,\n        testMatch: 0,\n        testPathIgnorePatterns: 0,\n        testRegex: 0\n      },\n      tests: [],\n      total: allPaths.length\n    };\n    const testCases = Array.from(this._testPathCases); // clone\n\n    if (testPathPattern) {\n      const regex = (0, _jestUtil().testPathPatternToRegExp)(testPathPattern);\n      testCases.push({\n        isMatch: path => regex.test(path),\n        stat: 'testPathPattern'\n      });\n      data.stats.testPathPattern = 0;\n    }\n\n    data.tests = allPaths.filter(test => {\n      let filterResult = true;\n\n      for (const {\n        isMatch,\n        stat\n      } of testCases) {\n        if (isMatch(test.path)) {\n          data.stats[stat]++;\n        } else {\n          filterResult = false;\n        }\n      }\n\n      return filterResult;\n    });\n    return data;\n  }\n\n  _getAllTestPaths(testPathPattern) {\n    return this._filterTestPathsWithStats(toTests(this._context, this._context.hasteFS.getAllFiles()), testPathPattern);\n  }\n\n  isTestFilePath(path) {\n    return this._testPathCases.every(testCase => testCase.isMatch(path));\n  }\n\n  findMatchingTests(testPathPattern) {\n    return this._getAllTestPaths(testPathPattern);\n  }\n\n  async findRelatedTests(allPaths, collectCoverage) {\n    const dependencyResolver = await this._getOrBuildDependencyResolver();\n\n    if (!collectCoverage) {\n      return {\n        tests: toTests(this._context, dependencyResolver.resolveInverse(allPaths, this.isTestFilePath.bind(this), {\n          skipNodeResolution: this._context.config.skipNodeResolution\n        }))\n      };\n    }\n\n    const testModulesMap = dependencyResolver.resolveInverseModuleMap(allPaths, this.isTestFilePath.bind(this), {\n      skipNodeResolution: this._context.config.skipNodeResolution\n    });\n    const allPathsAbsolute = Array.from(allPaths).map(p => path().resolve(p));\n    const collectCoverageFrom = new Set();\n    testModulesMap.forEach(testModule => {\n      if (!testModule.dependencies) {\n        return;\n      }\n\n      testModule.dependencies.forEach(p => {\n        if (!allPathsAbsolute.includes(p)) {\n          return;\n        }\n\n        const filename = (0, _jestConfig().replaceRootDirInPath)(this._context.config.rootDir, p);\n        collectCoverageFrom.add(path().isAbsolute(filename) ? path().relative(this._context.config.rootDir, filename) : filename);\n      });\n    });\n    return {\n      collectCoverageFrom,\n      tests: toTests(this._context, testModulesMap.map(testModule => testModule.file))\n    };\n  }\n\n  findTestsByPaths(paths) {\n    return {\n      tests: toTests(this._context, paths.map(p => path().resolve(this._context.config.cwd, p)).filter(this.isTestFilePath.bind(this)))\n    };\n  }\n\n  async findRelatedTestsFromPattern(paths, collectCoverage) {\n    if (Array.isArray(paths) && paths.length) {\n      const resolvedPaths = paths.map(p => path().resolve(this._context.config.cwd, p));\n      return this.findRelatedTests(new Set(resolvedPaths), collectCoverage);\n    }\n\n    return {\n      tests: []\n    };\n  }\n\n  async findTestRelatedToChangedFiles(changedFilesInfo, collectCoverage) {\n    if (!hasSCM(changedFilesInfo)) {\n      return {\n        noSCM: true,\n        tests: []\n      };\n    }\n\n    const {\n      changedFiles\n    } = changedFilesInfo;\n    return this.findRelatedTests(changedFiles, collectCoverage);\n  }\n\n  async _getTestPaths(globalConfig, changedFiles) {\n    if (globalConfig.onlyChanged) {\n      if (!changedFiles) {\n        throw new Error('Changed files must be set when running with -o.');\n      }\n\n      return this.findTestRelatedToChangedFiles(changedFiles, globalConfig.collectCoverage);\n    }\n\n    let paths = globalConfig.nonFlagArgs;\n\n    if (globalConfig.findRelatedTests && 'win32' === os().platform()) {\n      paths = this.filterPathsWin32(paths);\n    }\n\n    if (globalConfig.runTestsByPath && paths && paths.length) {\n      return this.findTestsByPaths(paths);\n    } else if (globalConfig.findRelatedTests && paths && paths.length) {\n      return this.findRelatedTestsFromPattern(paths, globalConfig.collectCoverage);\n    } else if (globalConfig.testPathPattern != null) {\n      return this.findMatchingTests(globalConfig.testPathPattern);\n    } else {\n      return {\n        tests: []\n      };\n    }\n  }\n\n  filterPathsWin32(paths) {\n    const allFiles = this._context.hasteFS.getAllFiles();\n\n    const options = {\n      nocase: true,\n      windows: false\n    };\n\n    function normalizePosix(filePath) {\n      return filePath.replace(/\\\\/g, '/');\n    }\n\n    paths = paths.map(p => {\n      // micromatch works with forward slashes: https://github.com/micromatch/micromatch#backslashes\n      const normalizedPath = normalizePosix(path().resolve(this._context.config.cwd, p));\n      const match = (0, _micromatch().default)(allFiles.map(normalizePosix), normalizedPath, options);\n      return match[0];\n    }).filter(Boolean).map(p => path().resolve(p));\n    return paths;\n  }\n\n  async getTestPaths(globalConfig, changedFiles, filter) {\n    const searchResult = await this._getTestPaths(globalConfig, changedFiles);\n    const filterPath = globalConfig.filter;\n\n    if (filter) {\n      const tests = searchResult.tests;\n      const filterResult = await filter(tests.map(test => test.path));\n\n      if (!Array.isArray(filterResult.filtered)) {\n        throw new Error(`Filter ${filterPath} did not return a valid test list`);\n      }\n\n      const filteredSet = new Set(filterResult.filtered.map(result => result.test));\n      return { ...searchResult,\n        tests: tests.filter(test => filteredSet.has(test.path))\n      };\n    }\n\n    return searchResult;\n  }\n\n  async findRelatedSourcesFromTestsInChangedFiles(changedFilesInfo) {\n    if (!hasSCM(changedFilesInfo)) {\n      return [];\n    }\n\n    const {\n      changedFiles\n    } = changedFilesInfo;\n    const dependencyResolver = await this._getOrBuildDependencyResolver();\n    const relatedSourcesSet = new Set();\n    changedFiles.forEach(filePath => {\n      if (this.isTestFilePath(filePath)) {\n        const sourcePaths = dependencyResolver.resolve(filePath, {\n          skipNodeResolution: this._context.config.skipNodeResolution\n        });\n        sourcePaths.forEach(sourcePath => relatedSourcesSet.add(sourcePath));\n      }\n    });\n    return Array.from(relatedSourcesSet);\n  }\n\n}\n\nexports.default = SearchSource;","map":{"version":3,"names":["Object","defineProperty","exports","value","default","os","data","_interopRequireWildcard","require","path","_micromatch","_interopRequireDefault","_jestConfig","_jestRegexUtil","_jestResolveDependencies","_jestSnapshot","_jestUtil","obj","__esModule","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","cache","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","_defineProperty","enumerable","configurable","writable","regexToMatcher","testRegex","regexes","map","RegExp","some","regex","result","test","lastIndex","toTests","context","tests","duration","undefined","hasSCM","changedFilesInfo","repos","noSCM","values","every","scm","size","SearchSource","constructor","config","_context","_dependencyResolver","rootPattern","roots","dir","escapePathForRegex","sep","join","_testPathCases","push","isMatch","stat","testMatch","length","globsToMatcher","testPathIgnorePatterns","testIgnorePatternsRegex","_getOrBuildDependencyResolver","DependencyResolver","resolver","hasteFS","buildSnapshotResolver","_filterTestPathsWithStats","allPaths","testPathPattern","stats","total","testCases","Array","from","testPathPatternToRegExp","filter","filterResult","_getAllTestPaths","getAllFiles","isTestFilePath","testCase","findMatchingTests","findRelatedTests","collectCoverage","dependencyResolver","resolveInverse","bind","skipNodeResolution","testModulesMap","resolveInverseModuleMap","allPathsAbsolute","p","resolve","collectCoverageFrom","Set","forEach","testModule","dependencies","includes","filename","replaceRootDirInPath","rootDir","add","isAbsolute","relative","file","findTestsByPaths","paths","cwd","findRelatedTestsFromPattern","isArray","resolvedPaths","findTestRelatedToChangedFiles","changedFiles","_getTestPaths","globalConfig","onlyChanged","Error","nonFlagArgs","platform","filterPathsWin32","runTestsByPath","allFiles","options","nocase","windows","normalizePosix","filePath","replace","normalizedPath","match","Boolean","getTestPaths","searchResult","filterPath","filtered","filteredSet","findRelatedSourcesFromTestsInChangedFiles","relatedSourcesSet","sourcePaths","sourcePath"],"sources":["/Users/lincolnkushwah/Desktop/All/React Projects/house_joy_new/node_modules/@jest/core/build/SearchSource.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\n\nfunction os() {\n  const data = _interopRequireWildcard(require('os'));\n\n  os = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction path() {\n  const data = _interopRequireWildcard(require('path'));\n\n  path = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _micromatch() {\n  const data = _interopRequireDefault(require('micromatch'));\n\n  _micromatch = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestConfig() {\n  const data = require('jest-config');\n\n  _jestConfig = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestRegexUtil() {\n  const data = require('jest-regex-util');\n\n  _jestRegexUtil = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestResolveDependencies() {\n  const data = require('jest-resolve-dependencies');\n\n  _jestResolveDependencies = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestSnapshot() {\n  const data = require('jest-snapshot');\n\n  _jestSnapshot = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestUtil() {\n  const data = require('jest-util');\n\n  _jestUtil = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== 'function') return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {\n    return {default: obj};\n  }\n  var cache = _getRequireWildcardCache(nodeInterop);\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor =\n    Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (key !== 'default' && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor\n        ? Object.getOwnPropertyDescriptor(obj, key)\n        : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\nconst regexToMatcher = testRegex => {\n  const regexes = testRegex.map(testRegex => new RegExp(testRegex));\n  return path =>\n    regexes.some(regex => {\n      const result = regex.test(path); // prevent stateful regexes from breaking, just in case\n\n      regex.lastIndex = 0;\n      return result;\n    });\n};\n\nconst toTests = (context, tests) =>\n  tests.map(path => ({\n    context,\n    duration: undefined,\n    path\n  }));\n\nconst hasSCM = changedFilesInfo => {\n  const {repos} = changedFilesInfo; // no SCM (git/hg/...) is found in any of the roots.\n\n  const noSCM = Object.values(repos).every(scm => scm.size === 0);\n  return !noSCM;\n};\n\nclass SearchSource {\n  constructor(context) {\n    _defineProperty(this, '_context', void 0);\n\n    _defineProperty(this, '_dependencyResolver', void 0);\n\n    _defineProperty(this, '_testPathCases', []);\n\n    const {config} = context;\n    this._context = context;\n    this._dependencyResolver = null;\n    const rootPattern = new RegExp(\n      config.roots\n        .map(dir => (0, _jestRegexUtil().escapePathForRegex)(dir + path().sep))\n        .join('|')\n    );\n\n    this._testPathCases.push({\n      isMatch: path => rootPattern.test(path),\n      stat: 'roots'\n    });\n\n    if (config.testMatch.length) {\n      this._testPathCases.push({\n        isMatch: (0, _jestUtil().globsToMatcher)(config.testMatch),\n        stat: 'testMatch'\n      });\n    }\n\n    if (config.testPathIgnorePatterns.length) {\n      const testIgnorePatternsRegex = new RegExp(\n        config.testPathIgnorePatterns.join('|')\n      );\n\n      this._testPathCases.push({\n        isMatch: path => !testIgnorePatternsRegex.test(path),\n        stat: 'testPathIgnorePatterns'\n      });\n    }\n\n    if (config.testRegex.length) {\n      this._testPathCases.push({\n        isMatch: regexToMatcher(config.testRegex),\n        stat: 'testRegex'\n      });\n    }\n  }\n\n  async _getOrBuildDependencyResolver() {\n    if (!this._dependencyResolver) {\n      this._dependencyResolver =\n        new (_jestResolveDependencies().DependencyResolver)(\n          this._context.resolver,\n          this._context.hasteFS,\n          await (0, _jestSnapshot().buildSnapshotResolver)(this._context.config)\n        );\n    }\n\n    return this._dependencyResolver;\n  }\n\n  _filterTestPathsWithStats(allPaths, testPathPattern) {\n    const data = {\n      stats: {\n        roots: 0,\n        testMatch: 0,\n        testPathIgnorePatterns: 0,\n        testRegex: 0\n      },\n      tests: [],\n      total: allPaths.length\n    };\n    const testCases = Array.from(this._testPathCases); // clone\n\n    if (testPathPattern) {\n      const regex = (0, _jestUtil().testPathPatternToRegExp)(testPathPattern);\n      testCases.push({\n        isMatch: path => regex.test(path),\n        stat: 'testPathPattern'\n      });\n      data.stats.testPathPattern = 0;\n    }\n\n    data.tests = allPaths.filter(test => {\n      let filterResult = true;\n\n      for (const {isMatch, stat} of testCases) {\n        if (isMatch(test.path)) {\n          data.stats[stat]++;\n        } else {\n          filterResult = false;\n        }\n      }\n\n      return filterResult;\n    });\n    return data;\n  }\n\n  _getAllTestPaths(testPathPattern) {\n    return this._filterTestPathsWithStats(\n      toTests(this._context, this._context.hasteFS.getAllFiles()),\n      testPathPattern\n    );\n  }\n\n  isTestFilePath(path) {\n    return this._testPathCases.every(testCase => testCase.isMatch(path));\n  }\n\n  findMatchingTests(testPathPattern) {\n    return this._getAllTestPaths(testPathPattern);\n  }\n\n  async findRelatedTests(allPaths, collectCoverage) {\n    const dependencyResolver = await this._getOrBuildDependencyResolver();\n\n    if (!collectCoverage) {\n      return {\n        tests: toTests(\n          this._context,\n          dependencyResolver.resolveInverse(\n            allPaths,\n            this.isTestFilePath.bind(this),\n            {\n              skipNodeResolution: this._context.config.skipNodeResolution\n            }\n          )\n        )\n      };\n    }\n\n    const testModulesMap = dependencyResolver.resolveInverseModuleMap(\n      allPaths,\n      this.isTestFilePath.bind(this),\n      {\n        skipNodeResolution: this._context.config.skipNodeResolution\n      }\n    );\n    const allPathsAbsolute = Array.from(allPaths).map(p => path().resolve(p));\n    const collectCoverageFrom = new Set();\n    testModulesMap.forEach(testModule => {\n      if (!testModule.dependencies) {\n        return;\n      }\n\n      testModule.dependencies.forEach(p => {\n        if (!allPathsAbsolute.includes(p)) {\n          return;\n        }\n\n        const filename = (0, _jestConfig().replaceRootDirInPath)(\n          this._context.config.rootDir,\n          p\n        );\n        collectCoverageFrom.add(\n          path().isAbsolute(filename)\n            ? path().relative(this._context.config.rootDir, filename)\n            : filename\n        );\n      });\n    });\n    return {\n      collectCoverageFrom,\n      tests: toTests(\n        this._context,\n        testModulesMap.map(testModule => testModule.file)\n      )\n    };\n  }\n\n  findTestsByPaths(paths) {\n    return {\n      tests: toTests(\n        this._context,\n        paths\n          .map(p => path().resolve(this._context.config.cwd, p))\n          .filter(this.isTestFilePath.bind(this))\n      )\n    };\n  }\n\n  async findRelatedTestsFromPattern(paths, collectCoverage) {\n    if (Array.isArray(paths) && paths.length) {\n      const resolvedPaths = paths.map(p =>\n        path().resolve(this._context.config.cwd, p)\n      );\n      return this.findRelatedTests(new Set(resolvedPaths), collectCoverage);\n    }\n\n    return {\n      tests: []\n    };\n  }\n\n  async findTestRelatedToChangedFiles(changedFilesInfo, collectCoverage) {\n    if (!hasSCM(changedFilesInfo)) {\n      return {\n        noSCM: true,\n        tests: []\n      };\n    }\n\n    const {changedFiles} = changedFilesInfo;\n    return this.findRelatedTests(changedFiles, collectCoverage);\n  }\n\n  async _getTestPaths(globalConfig, changedFiles) {\n    if (globalConfig.onlyChanged) {\n      if (!changedFiles) {\n        throw new Error('Changed files must be set when running with -o.');\n      }\n\n      return this.findTestRelatedToChangedFiles(\n        changedFiles,\n        globalConfig.collectCoverage\n      );\n    }\n\n    let paths = globalConfig.nonFlagArgs;\n\n    if (globalConfig.findRelatedTests && 'win32' === os().platform()) {\n      paths = this.filterPathsWin32(paths);\n    }\n\n    if (globalConfig.runTestsByPath && paths && paths.length) {\n      return this.findTestsByPaths(paths);\n    } else if (globalConfig.findRelatedTests && paths && paths.length) {\n      return this.findRelatedTestsFromPattern(\n        paths,\n        globalConfig.collectCoverage\n      );\n    } else if (globalConfig.testPathPattern != null) {\n      return this.findMatchingTests(globalConfig.testPathPattern);\n    } else {\n      return {\n        tests: []\n      };\n    }\n  }\n\n  filterPathsWin32(paths) {\n    const allFiles = this._context.hasteFS.getAllFiles();\n\n    const options = {\n      nocase: true,\n      windows: false\n    };\n\n    function normalizePosix(filePath) {\n      return filePath.replace(/\\\\/g, '/');\n    }\n\n    paths = paths\n      .map(p => {\n        // micromatch works with forward slashes: https://github.com/micromatch/micromatch#backslashes\n        const normalizedPath = normalizePosix(\n          path().resolve(this._context.config.cwd, p)\n        );\n        const match = (0, _micromatch().default)(\n          allFiles.map(normalizePosix),\n          normalizedPath,\n          options\n        );\n        return match[0];\n      })\n      .filter(Boolean)\n      .map(p => path().resolve(p));\n    return paths;\n  }\n\n  async getTestPaths(globalConfig, changedFiles, filter) {\n    const searchResult = await this._getTestPaths(globalConfig, changedFiles);\n    const filterPath = globalConfig.filter;\n\n    if (filter) {\n      const tests = searchResult.tests;\n      const filterResult = await filter(tests.map(test => test.path));\n\n      if (!Array.isArray(filterResult.filtered)) {\n        throw new Error(\n          `Filter ${filterPath} did not return a valid test list`\n        );\n      }\n\n      const filteredSet = new Set(\n        filterResult.filtered.map(result => result.test)\n      );\n      return {\n        ...searchResult,\n        tests: tests.filter(test => filteredSet.has(test.path))\n      };\n    }\n\n    return searchResult;\n  }\n\n  async findRelatedSourcesFromTestsInChangedFiles(changedFilesInfo) {\n    if (!hasSCM(changedFilesInfo)) {\n      return [];\n    }\n\n    const {changedFiles} = changedFilesInfo;\n    const dependencyResolver = await this._getOrBuildDependencyResolver();\n    const relatedSourcesSet = new Set();\n    changedFiles.forEach(filePath => {\n      if (this.isTestFilePath(filePath)) {\n        const sourcePaths = dependencyResolver.resolve(filePath, {\n          skipNodeResolution: this._context.config.skipNodeResolution\n        });\n        sourcePaths.forEach(sourcePath => relatedSourcesSet.add(sourcePath));\n      }\n    });\n    return Array.from(relatedSourcesSet);\n  }\n}\n\nexports.default = SearchSource;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}