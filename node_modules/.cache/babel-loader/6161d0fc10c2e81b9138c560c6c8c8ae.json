{"ast":null,"code":"/* Copyright 2015-present Facebook, Inc.\n * Licensed under the Apache License, Version 2.0 */\nvar EE = require('events').EventEmitter;\n\nvar util = require('util');\n\nvar os = require('os');\n\nvar assert = require('assert');\n\nvar Int64 = require('node-int64'); // BSER uses the local endianness to reduce byte swapping overheads\n// (the protocol is expressly local IPC only).  We need to tell node\n// to use the native endianness when reading various native values.\n\n\nvar isBigEndian = os.endianness() == 'BE'; // Find the next power-of-2 >= size\n\nfunction nextPow2(size) {\n  return Math.pow(2, Math.ceil(Math.log(size) / Math.LN2));\n} // Expandable buffer that we can provide a size hint for\n\n\nfunction Accumulator(initsize) {\n  this.buf = Buffer.alloc(nextPow2(initsize || 8192));\n  this.readOffset = 0;\n  this.writeOffset = 0;\n} // For testing\n\n\nexports.Accumulator = Accumulator; // How much we can write into this buffer without allocating\n\nAccumulator.prototype.writeAvail = function () {\n  return this.buf.length - this.writeOffset;\n}; // How much we can read\n\n\nAccumulator.prototype.readAvail = function () {\n  return this.writeOffset - this.readOffset;\n}; // Ensure that we have enough space for size bytes\n\n\nAccumulator.prototype.reserve = function (size) {\n  if (size < this.writeAvail()) {\n    return;\n  } // If we can make room by shunting down, do so\n\n\n  if (this.readOffset > 0) {\n    this.buf.copy(this.buf, 0, this.readOffset, this.writeOffset);\n    this.writeOffset -= this.readOffset;\n    this.readOffset = 0;\n  } // If we made enough room, no need to allocate more\n\n\n  if (size < this.writeAvail()) {\n    return;\n  } // Allocate a replacement and copy it in\n\n\n  var buf = Buffer.alloc(nextPow2(this.buf.length + size - this.writeAvail()));\n  this.buf.copy(buf);\n  this.buf = buf;\n}; // Append buffer or string.  Will resize as needed\n\n\nAccumulator.prototype.append = function (buf) {\n  if (Buffer.isBuffer(buf)) {\n    this.reserve(buf.length);\n    buf.copy(this.buf, this.writeOffset, 0, buf.length);\n    this.writeOffset += buf.length;\n  } else {\n    var size = Buffer.byteLength(buf);\n    this.reserve(size);\n    this.buf.write(buf, this.writeOffset);\n    this.writeOffset += size;\n  }\n};\n\nAccumulator.prototype.assertReadableSize = function (size) {\n  if (this.readAvail() < size) {\n    throw new Error(\"wanted to read \" + size + \" bytes but only have \" + this.readAvail());\n  }\n};\n\nAccumulator.prototype.peekString = function (size) {\n  this.assertReadableSize(size);\n  return this.buf.toString('utf-8', this.readOffset, this.readOffset + size);\n};\n\nAccumulator.prototype.readString = function (size) {\n  var str = this.peekString(size);\n  this.readOffset += size;\n  return str;\n};\n\nAccumulator.prototype.peekInt = function (size) {\n  this.assertReadableSize(size);\n\n  switch (size) {\n    case 1:\n      return this.buf.readInt8(this.readOffset, size);\n\n    case 2:\n      return isBigEndian ? this.buf.readInt16BE(this.readOffset, size) : this.buf.readInt16LE(this.readOffset, size);\n\n    case 4:\n      return isBigEndian ? this.buf.readInt32BE(this.readOffset, size) : this.buf.readInt32LE(this.readOffset, size);\n\n    case 8:\n      var big = this.buf.slice(this.readOffset, this.readOffset + 8);\n\n      if (isBigEndian) {\n        // On a big endian system we can simply pass the buffer directly\n        return new Int64(big);\n      } // Otherwise we need to byteswap\n\n\n      return new Int64(byteswap64(big));\n\n    default:\n      throw new Error(\"invalid integer size \" + size);\n  }\n};\n\nAccumulator.prototype.readInt = function (bytes) {\n  var ival = this.peekInt(bytes);\n\n  if (ival instanceof Int64 && isFinite(ival.valueOf())) {\n    ival = ival.valueOf();\n  }\n\n  this.readOffset += bytes;\n  return ival;\n};\n\nAccumulator.prototype.peekDouble = function () {\n  this.assertReadableSize(8);\n  return isBigEndian ? this.buf.readDoubleBE(this.readOffset) : this.buf.readDoubleLE(this.readOffset);\n};\n\nAccumulator.prototype.readDouble = function () {\n  var dval = this.peekDouble();\n  this.readOffset += 8;\n  return dval;\n};\n\nAccumulator.prototype.readAdvance = function (size) {\n  if (size > 0) {\n    this.assertReadableSize(size);\n  } else if (size < 0 && this.readOffset + size < 0) {\n    throw new Error(\"advance with negative offset \" + size + \" would seek off the start of the buffer\");\n  }\n\n  this.readOffset += size;\n};\n\nAccumulator.prototype.writeByte = function (value) {\n  this.reserve(1);\n  this.buf.writeInt8(value, this.writeOffset);\n  ++this.writeOffset;\n};\n\nAccumulator.prototype.writeInt = function (value, size) {\n  this.reserve(size);\n\n  switch (size) {\n    case 1:\n      this.buf.writeInt8(value, this.writeOffset);\n      break;\n\n    case 2:\n      if (isBigEndian) {\n        this.buf.writeInt16BE(value, this.writeOffset);\n      } else {\n        this.buf.writeInt16LE(value, this.writeOffset);\n      }\n\n      break;\n\n    case 4:\n      if (isBigEndian) {\n        this.buf.writeInt32BE(value, this.writeOffset);\n      } else {\n        this.buf.writeInt32LE(value, this.writeOffset);\n      }\n\n      break;\n\n    default:\n      throw new Error(\"unsupported integer size \" + size);\n  }\n\n  this.writeOffset += size;\n};\n\nAccumulator.prototype.writeDouble = function (value) {\n  this.reserve(8);\n\n  if (isBigEndian) {\n    this.buf.writeDoubleBE(value, this.writeOffset);\n  } else {\n    this.buf.writeDoubleLE(value, this.writeOffset);\n  }\n\n  this.writeOffset += 8;\n};\n\nvar BSER_ARRAY = 0x00;\nvar BSER_OBJECT = 0x01;\nvar BSER_STRING = 0x02;\nvar BSER_INT8 = 0x03;\nvar BSER_INT16 = 0x04;\nvar BSER_INT32 = 0x05;\nvar BSER_INT64 = 0x06;\nvar BSER_REAL = 0x07;\nvar BSER_TRUE = 0x08;\nvar BSER_FALSE = 0x09;\nvar BSER_NULL = 0x0a;\nvar BSER_TEMPLATE = 0x0b;\nvar BSER_SKIP = 0x0c;\nvar ST_NEED_PDU = 0; // Need to read and decode PDU length\n\nvar ST_FILL_PDU = 1; // Know the length, need to read whole content\n\nvar MAX_INT8 = 127;\nvar MAX_INT16 = 32767;\nvar MAX_INT32 = 2147483647;\n\nfunction BunserBuf() {\n  EE.call(this);\n  this.buf = new Accumulator();\n  this.state = ST_NEED_PDU;\n}\n\nutil.inherits(BunserBuf, EE);\nexports.BunserBuf = BunserBuf;\n\nBunserBuf.prototype.append = function (buf, synchronous) {\n  if (synchronous) {\n    this.buf.append(buf);\n    return this.process(synchronous);\n  }\n\n  try {\n    this.buf.append(buf);\n  } catch (err) {\n    this.emit('error', err);\n    return;\n  } // Arrange to decode later.  This allows the consuming\n  // application to make progress with other work in the\n  // case that we have a lot of subscription updates coming\n  // in from a large tree.\n\n\n  this.processLater();\n};\n\nBunserBuf.prototype.processLater = function () {\n  var self = this;\n  process.nextTick(function () {\n    try {\n      self.process(false);\n    } catch (err) {\n      self.emit('error', err);\n    }\n  });\n}; // Do something with the buffer to advance our state.\n// If we're running synchronously we'll return either\n// the value we've decoded or undefined if we don't\n// yet have enought data.\n// If we're running asynchronously, we'll emit the value\n// when it becomes ready and schedule another invocation\n// of process on the next tick if we still have data we\n// can process.\n\n\nBunserBuf.prototype.process = function (synchronous) {\n  if (this.state == ST_NEED_PDU) {\n    if (this.buf.readAvail() < 2) {\n      return;\n    } // Validate BSER header\n\n\n    this.expectCode(0);\n    this.expectCode(1);\n    this.pduLen = this.decodeInt(true\n    /* relaxed */\n    );\n\n    if (this.pduLen === false) {\n      // Need more data, walk backwards\n      this.buf.readAdvance(-2);\n      return;\n    } // Ensure that we have a big enough buffer to read the rest of the PDU\n\n\n    this.buf.reserve(this.pduLen);\n    this.state = ST_FILL_PDU;\n  }\n\n  if (this.state == ST_FILL_PDU) {\n    if (this.buf.readAvail() < this.pduLen) {\n      // Need more data\n      return;\n    } // We have enough to decode it\n\n\n    var val = this.decodeAny();\n\n    if (synchronous) {\n      return val;\n    }\n\n    this.emit('value', val);\n    this.state = ST_NEED_PDU;\n  }\n\n  if (!synchronous && this.buf.readAvail() > 0) {\n    this.processLater();\n  }\n};\n\nBunserBuf.prototype.raise = function (reason) {\n  throw new Error(reason + \", in Buffer of length \" + this.buf.buf.length + \" (\" + this.buf.readAvail() + \" readable) at offset \" + this.buf.readOffset + \" buffer: \" + JSON.stringify(this.buf.buf.slice(this.buf.readOffset, this.buf.readOffset + 32).toJSON()));\n};\n\nBunserBuf.prototype.expectCode = function (expected) {\n  var code = this.buf.readInt(1);\n\n  if (code != expected) {\n    this.raise(\"expected bser opcode \" + expected + \" but got \" + code);\n  }\n};\n\nBunserBuf.prototype.decodeAny = function () {\n  var code = this.buf.peekInt(1);\n\n  switch (code) {\n    case BSER_INT8:\n    case BSER_INT16:\n    case BSER_INT32:\n    case BSER_INT64:\n      return this.decodeInt();\n\n    case BSER_REAL:\n      this.buf.readAdvance(1);\n      return this.buf.readDouble();\n\n    case BSER_TRUE:\n      this.buf.readAdvance(1);\n      return true;\n\n    case BSER_FALSE:\n      this.buf.readAdvance(1);\n      return false;\n\n    case BSER_NULL:\n      this.buf.readAdvance(1);\n      return null;\n\n    case BSER_STRING:\n      return this.decodeString();\n\n    case BSER_ARRAY:\n      return this.decodeArray();\n\n    case BSER_OBJECT:\n      return this.decodeObject();\n\n    case BSER_TEMPLATE:\n      return this.decodeTemplate();\n\n    default:\n      this.raise(\"unhandled bser opcode \" + code);\n  }\n};\n\nBunserBuf.prototype.decodeArray = function () {\n  this.expectCode(BSER_ARRAY);\n  var nitems = this.decodeInt();\n  var arr = [];\n\n  for (var i = 0; i < nitems; ++i) {\n    arr.push(this.decodeAny());\n  }\n\n  return arr;\n};\n\nBunserBuf.prototype.decodeObject = function () {\n  this.expectCode(BSER_OBJECT);\n  var nitems = this.decodeInt();\n  var res = {};\n\n  for (var i = 0; i < nitems; ++i) {\n    var key = this.decodeString();\n    var val = this.decodeAny();\n    res[key] = val;\n  }\n\n  return res;\n};\n\nBunserBuf.prototype.decodeTemplate = function () {\n  this.expectCode(BSER_TEMPLATE);\n  var keys = this.decodeArray();\n  var nitems = this.decodeInt();\n  var arr = [];\n\n  for (var i = 0; i < nitems; ++i) {\n    var obj = {};\n\n    for (var keyidx = 0; keyidx < keys.length; ++keyidx) {\n      if (this.buf.peekInt(1) == BSER_SKIP) {\n        this.buf.readAdvance(1);\n        continue;\n      }\n\n      var val = this.decodeAny();\n      obj[keys[keyidx]] = val;\n    }\n\n    arr.push(obj);\n  }\n\n  return arr;\n};\n\nBunserBuf.prototype.decodeString = function () {\n  this.expectCode(BSER_STRING);\n  var len = this.decodeInt();\n  return this.buf.readString(len);\n}; // This is unusual compared to the other decode functions in that\n// we may not have enough data available to satisfy the read, and\n// we don't want to throw.  This is only true when we're reading\n// the PDU length from the PDU header; we'll set relaxSizeAsserts\n// in that case.\n\n\nBunserBuf.prototype.decodeInt = function (relaxSizeAsserts) {\n  if (relaxSizeAsserts && this.buf.readAvail() < 1) {\n    return false;\n  } else {\n    this.buf.assertReadableSize(1);\n  }\n\n  var code = this.buf.peekInt(1);\n  var size = 0;\n\n  switch (code) {\n    case BSER_INT8:\n      size = 1;\n      break;\n\n    case BSER_INT16:\n      size = 2;\n      break;\n\n    case BSER_INT32:\n      size = 4;\n      break;\n\n    case BSER_INT64:\n      size = 8;\n      break;\n\n    default:\n      this.raise(\"invalid bser int encoding \" + code);\n  }\n\n  if (relaxSizeAsserts && this.buf.readAvail() < 1 + size) {\n    return false;\n  }\n\n  this.buf.readAdvance(1);\n  return this.buf.readInt(size);\n}; // synchronously BSER decode a string and return the value\n\n\nfunction loadFromBuffer(input) {\n  var buf = new BunserBuf();\n  var result = buf.append(input, true);\n\n  if (buf.buf.readAvail()) {\n    throw Error('excess data found after input buffer, use BunserBuf instead');\n  }\n\n  if (typeof result === 'undefined') {\n    throw Error('no bser found in string and no error raised!?');\n  }\n\n  return result;\n}\n\nexports.loadFromBuffer = loadFromBuffer; // Byteswap an arbitrary buffer, flipping from one endian\n// to the other, returning a new buffer with the resultant data\n\nfunction byteswap64(buf) {\n  var swap = Buffer.alloc(buf.length);\n\n  for (var i = 0; i < buf.length; i++) {\n    swap[i] = buf[buf.length - 1 - i];\n  }\n\n  return swap;\n}\n\nfunction dump_int64(buf, val) {\n  // Get the raw bytes.  The Int64 buffer is big endian\n  var be = val.toBuffer();\n\n  if (isBigEndian) {\n    // We're a big endian system, so the buffer is exactly how we\n    // want it to be\n    buf.writeByte(BSER_INT64);\n    buf.append(be);\n    return;\n  } // We need to byte swap to get the correct representation\n\n\n  var le = byteswap64(be);\n  buf.writeByte(BSER_INT64);\n  buf.append(le);\n}\n\nfunction dump_int(buf, val) {\n  var abs = Math.abs(val);\n\n  if (abs <= MAX_INT8) {\n    buf.writeByte(BSER_INT8);\n    buf.writeInt(val, 1);\n  } else if (abs <= MAX_INT16) {\n    buf.writeByte(BSER_INT16);\n    buf.writeInt(val, 2);\n  } else if (abs <= MAX_INT32) {\n    buf.writeByte(BSER_INT32);\n    buf.writeInt(val, 4);\n  } else {\n    dump_int64(buf, new Int64(val));\n  }\n}\n\nfunction dump_any(buf, val) {\n  switch (typeof val) {\n    case 'number':\n      // check if it is an integer or a float\n      if (isFinite(val) && Math.floor(val) === val) {\n        dump_int(buf, val);\n      } else {\n        buf.writeByte(BSER_REAL);\n        buf.writeDouble(val);\n      }\n\n      return;\n\n    case 'string':\n      buf.writeByte(BSER_STRING);\n      dump_int(buf, Buffer.byteLength(val));\n      buf.append(val);\n      return;\n\n    case 'boolean':\n      buf.writeByte(val ? BSER_TRUE : BSER_FALSE);\n      return;\n\n    case 'object':\n      if (val === null) {\n        buf.writeByte(BSER_NULL);\n        return;\n      }\n\n      if (val instanceof Int64) {\n        dump_int64(buf, val);\n        return;\n      }\n\n      if (Array.isArray(val)) {\n        buf.writeByte(BSER_ARRAY);\n        dump_int(buf, val.length);\n\n        for (var i = 0; i < val.length; ++i) {\n          dump_any(buf, val[i]);\n        }\n\n        return;\n      }\n\n      buf.writeByte(BSER_OBJECT);\n      var keys = Object.keys(val); // First pass to compute number of defined keys\n\n      var num_keys = keys.length;\n\n      for (var i = 0; i < keys.length; ++i) {\n        var key = keys[i];\n        var v = val[key];\n\n        if (typeof v == 'undefined') {\n          num_keys--;\n        }\n      }\n\n      dump_int(buf, num_keys);\n\n      for (var i = 0; i < keys.length; ++i) {\n        var key = keys[i];\n        var v = val[key];\n\n        if (typeof v == 'undefined') {\n          // Don't include it\n          continue;\n        }\n\n        dump_any(buf, key);\n\n        try {\n          dump_any(buf, v);\n        } catch (e) {\n          throw new Error(e.message + ' (while serializing object property with name `' + key + \"')\");\n        }\n      }\n\n      return;\n\n    default:\n      throw new Error('cannot serialize type ' + typeof val + ' to BSER');\n  }\n} // BSER encode value and return a buffer of the contents\n\n\nfunction dumpToBuffer(val) {\n  var buf = new Accumulator(); // Build out the header\n\n  buf.writeByte(0);\n  buf.writeByte(1); // Reserve room for an int32 to hold our PDU length\n\n  buf.writeByte(BSER_INT32);\n  buf.writeInt(0, 4); // We'll come back and fill this in at the end\n\n  dump_any(buf, val); // Compute PDU length\n\n  var off = buf.writeOffset;\n  var len = off - 7\n  /* the header length */\n  ;\n  buf.writeOffset = 3; // The length value to fill in\n\n  buf.writeInt(len, 4); // write the length in the space we reserved\n\n  buf.writeOffset = off;\n  return buf.buf.slice(0, off);\n}\n\nexports.dumpToBuffer = dumpToBuffer;","map":{"version":3,"names":["EE","require","EventEmitter","util","os","assert","Int64","isBigEndian","endianness","nextPow2","size","Math","pow","ceil","log","LN2","Accumulator","initsize","buf","Buffer","alloc","readOffset","writeOffset","exports","prototype","writeAvail","length","readAvail","reserve","copy","append","isBuffer","byteLength","write","assertReadableSize","Error","peekString","toString","readString","str","peekInt","readInt8","readInt16BE","readInt16LE","readInt32BE","readInt32LE","big","slice","byteswap64","readInt","bytes","ival","isFinite","valueOf","peekDouble","readDoubleBE","readDoubleLE","readDouble","dval","readAdvance","writeByte","value","writeInt8","writeInt","writeInt16BE","writeInt16LE","writeInt32BE","writeInt32LE","writeDouble","writeDoubleBE","writeDoubleLE","BSER_ARRAY","BSER_OBJECT","BSER_STRING","BSER_INT8","BSER_INT16","BSER_INT32","BSER_INT64","BSER_REAL","BSER_TRUE","BSER_FALSE","BSER_NULL","BSER_TEMPLATE","BSER_SKIP","ST_NEED_PDU","ST_FILL_PDU","MAX_INT8","MAX_INT16","MAX_INT32","BunserBuf","call","state","inherits","synchronous","process","err","emit","processLater","self","nextTick","expectCode","pduLen","decodeInt","val","decodeAny","raise","reason","JSON","stringify","toJSON","expected","code","decodeString","decodeArray","decodeObject","decodeTemplate","nitems","arr","i","push","res","key","keys","obj","keyidx","len","relaxSizeAsserts","loadFromBuffer","input","result","swap","dump_int64","be","toBuffer","le","dump_int","abs","dump_any","floor","Array","isArray","Object","num_keys","v","e","message","dumpToBuffer","off"],"sources":["/Users/lincolnkushwah/Desktop/All/React Projects/house_joy_new/node_modules/bser/index.js"],"sourcesContent":["/* Copyright 2015-present Facebook, Inc.\n * Licensed under the Apache License, Version 2.0 */\n\nvar EE = require('events').EventEmitter;\nvar util = require('util');\nvar os = require('os');\nvar assert = require('assert');\nvar Int64 = require('node-int64');\n\n// BSER uses the local endianness to reduce byte swapping overheads\n// (the protocol is expressly local IPC only).  We need to tell node\n// to use the native endianness when reading various native values.\nvar isBigEndian = os.endianness() == 'BE';\n\n// Find the next power-of-2 >= size\nfunction nextPow2(size) {\n  return Math.pow(2, Math.ceil(Math.log(size) / Math.LN2));\n}\n\n// Expandable buffer that we can provide a size hint for\nfunction Accumulator(initsize) {\n  this.buf = Buffer.alloc(nextPow2(initsize || 8192));\n  this.readOffset = 0;\n  this.writeOffset = 0;\n}\n// For testing\nexports.Accumulator = Accumulator\n\n// How much we can write into this buffer without allocating\nAccumulator.prototype.writeAvail = function() {\n  return this.buf.length - this.writeOffset;\n}\n\n// How much we can read\nAccumulator.prototype.readAvail = function() {\n  return this.writeOffset - this.readOffset;\n}\n\n// Ensure that we have enough space for size bytes\nAccumulator.prototype.reserve = function(size) {\n  if (size < this.writeAvail()) {\n    return;\n  }\n\n  // If we can make room by shunting down, do so\n  if (this.readOffset > 0) {\n    this.buf.copy(this.buf, 0, this.readOffset, this.writeOffset);\n    this.writeOffset -= this.readOffset;\n    this.readOffset = 0;\n  }\n\n  // If we made enough room, no need to allocate more\n  if (size < this.writeAvail()) {\n    return;\n  }\n\n  // Allocate a replacement and copy it in\n  var buf = Buffer.alloc(nextPow2(this.buf.length + size - this.writeAvail()));\n  this.buf.copy(buf);\n  this.buf = buf;\n}\n\n// Append buffer or string.  Will resize as needed\nAccumulator.prototype.append = function(buf) {\n  if (Buffer.isBuffer(buf)) {\n    this.reserve(buf.length);\n    buf.copy(this.buf, this.writeOffset, 0, buf.length);\n    this.writeOffset += buf.length;\n  } else {\n    var size = Buffer.byteLength(buf);\n    this.reserve(size);\n    this.buf.write(buf, this.writeOffset);\n    this.writeOffset += size;\n  }\n}\n\nAccumulator.prototype.assertReadableSize = function(size) {\n  if (this.readAvail() < size) {\n    throw new Error(\"wanted to read \" + size +\n        \" bytes but only have \" + this.readAvail());\n  }\n}\n\nAccumulator.prototype.peekString = function(size) {\n  this.assertReadableSize(size);\n  return this.buf.toString('utf-8', this.readOffset, this.readOffset + size);\n}\n\nAccumulator.prototype.readString = function(size) {\n  var str = this.peekString(size);\n  this.readOffset += size;\n  return str;\n}\n\nAccumulator.prototype.peekInt = function(size) {\n  this.assertReadableSize(size);\n  switch (size) {\n    case 1:\n      return this.buf.readInt8(this.readOffset, size);\n    case 2:\n      return isBigEndian ?\n        this.buf.readInt16BE(this.readOffset, size) :\n        this.buf.readInt16LE(this.readOffset, size);\n    case 4:\n      return isBigEndian ?\n        this.buf.readInt32BE(this.readOffset, size) :\n        this.buf.readInt32LE(this.readOffset, size);\n    case 8:\n        var big = this.buf.slice(this.readOffset, this.readOffset + 8);\n        if (isBigEndian) {\n          // On a big endian system we can simply pass the buffer directly\n          return new Int64(big);\n        }\n        // Otherwise we need to byteswap\n        return new Int64(byteswap64(big));\n    default:\n      throw new Error(\"invalid integer size \" + size);\n  }\n}\n\nAccumulator.prototype.readInt = function(bytes) {\n  var ival = this.peekInt(bytes);\n  if (ival instanceof Int64 && isFinite(ival.valueOf())) {\n    ival = ival.valueOf();\n  }\n  this.readOffset += bytes;\n  return ival;\n}\n\nAccumulator.prototype.peekDouble = function() {\n  this.assertReadableSize(8);\n  return isBigEndian ?\n    this.buf.readDoubleBE(this.readOffset) :\n    this.buf.readDoubleLE(this.readOffset);\n}\n\nAccumulator.prototype.readDouble = function() {\n  var dval = this.peekDouble();\n  this.readOffset += 8;\n  return dval;\n}\n\nAccumulator.prototype.readAdvance = function(size) {\n  if (size > 0) {\n    this.assertReadableSize(size);\n  } else if (size < 0 && this.readOffset + size < 0) {\n    throw new Error(\"advance with negative offset \" + size +\n        \" would seek off the start of the buffer\");\n  }\n  this.readOffset += size;\n}\n\nAccumulator.prototype.writeByte = function(value) {\n  this.reserve(1);\n  this.buf.writeInt8(value, this.writeOffset);\n  ++this.writeOffset;\n}\n\nAccumulator.prototype.writeInt = function(value, size) {\n  this.reserve(size);\n  switch (size) {\n    case 1:\n      this.buf.writeInt8(value, this.writeOffset);\n      break;\n    case 2:\n      if (isBigEndian) {\n        this.buf.writeInt16BE(value, this.writeOffset);\n      } else {\n        this.buf.writeInt16LE(value, this.writeOffset);\n      }\n      break;\n    case 4:\n      if (isBigEndian) {\n        this.buf.writeInt32BE(value, this.writeOffset);\n      } else {\n        this.buf.writeInt32LE(value, this.writeOffset);\n      }\n      break;\n    default:\n      throw new Error(\"unsupported integer size \" + size);\n  }\n  this.writeOffset += size;\n}\n\nAccumulator.prototype.writeDouble = function(value) {\n  this.reserve(8);\n  if (isBigEndian) {\n    this.buf.writeDoubleBE(value, this.writeOffset);\n  } else {\n    this.buf.writeDoubleLE(value, this.writeOffset);\n  }\n  this.writeOffset += 8;\n}\n\nvar BSER_ARRAY     = 0x00;\nvar BSER_OBJECT    = 0x01;\nvar BSER_STRING    = 0x02;\nvar BSER_INT8      = 0x03;\nvar BSER_INT16     = 0x04;\nvar BSER_INT32     = 0x05;\nvar BSER_INT64     = 0x06;\nvar BSER_REAL      = 0x07;\nvar BSER_TRUE      = 0x08;\nvar BSER_FALSE     = 0x09;\nvar BSER_NULL      = 0x0a;\nvar BSER_TEMPLATE  = 0x0b;\nvar BSER_SKIP      = 0x0c;\n\nvar ST_NEED_PDU = 0; // Need to read and decode PDU length\nvar ST_FILL_PDU = 1; // Know the length, need to read whole content\n\nvar MAX_INT8 = 127;\nvar MAX_INT16 = 32767;\nvar MAX_INT32 = 2147483647;\n\nfunction BunserBuf() {\n  EE.call(this);\n  this.buf = new Accumulator();\n  this.state = ST_NEED_PDU;\n}\nutil.inherits(BunserBuf, EE);\nexports.BunserBuf = BunserBuf;\n\nBunserBuf.prototype.append = function(buf, synchronous) {\n  if (synchronous) {\n    this.buf.append(buf);\n    return this.process(synchronous);\n  }\n\n  try {\n    this.buf.append(buf);\n  } catch (err) {\n    this.emit('error', err);\n    return;\n  }\n  // Arrange to decode later.  This allows the consuming\n  // application to make progress with other work in the\n  // case that we have a lot of subscription updates coming\n  // in from a large tree.\n  this.processLater();\n}\n\nBunserBuf.prototype.processLater = function() {\n  var self = this;\n  process.nextTick(function() {\n    try {\n      self.process(false);\n    } catch (err) {\n      self.emit('error', err);\n    }\n  });\n}\n\n// Do something with the buffer to advance our state.\n// If we're running synchronously we'll return either\n// the value we've decoded or undefined if we don't\n// yet have enought data.\n// If we're running asynchronously, we'll emit the value\n// when it becomes ready and schedule another invocation\n// of process on the next tick if we still have data we\n// can process.\nBunserBuf.prototype.process = function(synchronous) {\n  if (this.state == ST_NEED_PDU) {\n    if (this.buf.readAvail() < 2) {\n      return;\n    }\n    // Validate BSER header\n    this.expectCode(0);\n    this.expectCode(1);\n    this.pduLen = this.decodeInt(true /* relaxed */);\n    if (this.pduLen === false) {\n      // Need more data, walk backwards\n      this.buf.readAdvance(-2);\n      return;\n    }\n    // Ensure that we have a big enough buffer to read the rest of the PDU\n    this.buf.reserve(this.pduLen);\n    this.state = ST_FILL_PDU;\n  }\n\n  if (this.state == ST_FILL_PDU) {\n    if (this.buf.readAvail() < this.pduLen) {\n      // Need more data\n      return;\n    }\n\n    // We have enough to decode it\n    var val = this.decodeAny();\n    if (synchronous) {\n      return val;\n    }\n    this.emit('value', val);\n    this.state = ST_NEED_PDU;\n  }\n\n  if (!synchronous && this.buf.readAvail() > 0) {\n    this.processLater();\n  }\n}\n\nBunserBuf.prototype.raise = function(reason) {\n  throw new Error(reason + \", in Buffer of length \" +\n      this.buf.buf.length + \" (\" + this.buf.readAvail() +\n      \" readable) at offset \" + this.buf.readOffset + \" buffer: \" +\n      JSON.stringify(this.buf.buf.slice(\n          this.buf.readOffset, this.buf.readOffset + 32).toJSON()));\n}\n\nBunserBuf.prototype.expectCode = function(expected) {\n  var code = this.buf.readInt(1);\n  if (code != expected) {\n    this.raise(\"expected bser opcode \" + expected + \" but got \" + code);\n  }\n}\n\nBunserBuf.prototype.decodeAny = function() {\n  var code = this.buf.peekInt(1);\n  switch (code) {\n    case BSER_INT8:\n    case BSER_INT16:\n    case BSER_INT32:\n    case BSER_INT64:\n      return this.decodeInt();\n    case BSER_REAL:\n      this.buf.readAdvance(1);\n      return this.buf.readDouble();\n    case BSER_TRUE:\n      this.buf.readAdvance(1);\n      return true;\n    case BSER_FALSE:\n      this.buf.readAdvance(1);\n      return false;\n    case BSER_NULL:\n      this.buf.readAdvance(1);\n      return null;\n    case BSER_STRING:\n      return this.decodeString();\n    case BSER_ARRAY:\n      return this.decodeArray();\n    case BSER_OBJECT:\n      return this.decodeObject();\n    case BSER_TEMPLATE:\n      return this.decodeTemplate();\n    default:\n      this.raise(\"unhandled bser opcode \" + code);\n  }\n}\n\nBunserBuf.prototype.decodeArray = function() {\n  this.expectCode(BSER_ARRAY);\n  var nitems = this.decodeInt();\n  var arr = [];\n  for (var i = 0; i < nitems; ++i) {\n    arr.push(this.decodeAny());\n  }\n  return arr;\n}\n\nBunserBuf.prototype.decodeObject = function() {\n  this.expectCode(BSER_OBJECT);\n  var nitems = this.decodeInt();\n  var res = {};\n  for (var i = 0; i < nitems; ++i) {\n    var key = this.decodeString();\n    var val = this.decodeAny();\n    res[key] = val;\n  }\n  return res;\n}\n\nBunserBuf.prototype.decodeTemplate = function() {\n  this.expectCode(BSER_TEMPLATE);\n  var keys = this.decodeArray();\n  var nitems = this.decodeInt();\n  var arr = [];\n  for (var i = 0; i < nitems; ++i) {\n    var obj = {};\n    for (var keyidx = 0; keyidx < keys.length; ++keyidx) {\n      if (this.buf.peekInt(1) == BSER_SKIP) {\n        this.buf.readAdvance(1);\n        continue;\n      }\n      var val = this.decodeAny();\n      obj[keys[keyidx]] = val;\n    }\n    arr.push(obj);\n  }\n  return arr;\n}\n\nBunserBuf.prototype.decodeString = function() {\n  this.expectCode(BSER_STRING);\n  var len = this.decodeInt();\n  return this.buf.readString(len);\n}\n\n// This is unusual compared to the other decode functions in that\n// we may not have enough data available to satisfy the read, and\n// we don't want to throw.  This is only true when we're reading\n// the PDU length from the PDU header; we'll set relaxSizeAsserts\n// in that case.\nBunserBuf.prototype.decodeInt = function(relaxSizeAsserts) {\n  if (relaxSizeAsserts && (this.buf.readAvail() < 1)) {\n    return false;\n  } else {\n    this.buf.assertReadableSize(1);\n  }\n  var code = this.buf.peekInt(1);\n  var size = 0;\n  switch (code) {\n    case BSER_INT8:\n      size = 1;\n      break;\n    case BSER_INT16:\n      size = 2;\n      break;\n    case BSER_INT32:\n      size = 4;\n      break;\n    case BSER_INT64:\n      size = 8;\n      break;\n    default:\n      this.raise(\"invalid bser int encoding \" + code);\n  }\n\n  if (relaxSizeAsserts && (this.buf.readAvail() < 1 + size)) {\n    return false;\n  }\n  this.buf.readAdvance(1);\n  return this.buf.readInt(size);\n}\n\n// synchronously BSER decode a string and return the value\nfunction loadFromBuffer(input) {\n  var buf = new BunserBuf();\n  var result = buf.append(input, true);\n  if (buf.buf.readAvail()) {\n    throw Error(\n        'excess data found after input buffer, use BunserBuf instead');\n  }\n  if (typeof result === 'undefined') {\n    throw Error(\n        'no bser found in string and no error raised!?');\n  }\n  return result;\n}\nexports.loadFromBuffer = loadFromBuffer\n\n// Byteswap an arbitrary buffer, flipping from one endian\n// to the other, returning a new buffer with the resultant data\nfunction byteswap64(buf) {\n  var swap = Buffer.alloc(buf.length);\n  for (var i = 0; i < buf.length; i++) {\n    swap[i] = buf[buf.length -1 - i];\n  }\n  return swap;\n}\n\nfunction dump_int64(buf, val) {\n  // Get the raw bytes.  The Int64 buffer is big endian\n  var be = val.toBuffer();\n\n  if (isBigEndian) {\n    // We're a big endian system, so the buffer is exactly how we\n    // want it to be\n    buf.writeByte(BSER_INT64);\n    buf.append(be);\n    return;\n  }\n  // We need to byte swap to get the correct representation\n  var le = byteswap64(be);\n  buf.writeByte(BSER_INT64);\n  buf.append(le);\n}\n\nfunction dump_int(buf, val) {\n  var abs = Math.abs(val);\n  if (abs <= MAX_INT8) {\n    buf.writeByte(BSER_INT8);\n    buf.writeInt(val, 1);\n  } else if (abs <= MAX_INT16) {\n    buf.writeByte(BSER_INT16);\n    buf.writeInt(val, 2);\n  } else if (abs <= MAX_INT32) {\n    buf.writeByte(BSER_INT32);\n    buf.writeInt(val, 4);\n  } else {\n    dump_int64(buf, new Int64(val));\n  }\n}\n\nfunction dump_any(buf, val) {\n  switch (typeof(val)) {\n    case 'number':\n      // check if it is an integer or a float\n      if (isFinite(val) && Math.floor(val) === val) {\n        dump_int(buf, val);\n      } else {\n        buf.writeByte(BSER_REAL);\n        buf.writeDouble(val);\n      }\n      return;\n    case 'string':\n      buf.writeByte(BSER_STRING);\n      dump_int(buf, Buffer.byteLength(val));\n      buf.append(val);\n      return;\n    case 'boolean':\n      buf.writeByte(val ? BSER_TRUE : BSER_FALSE);\n      return;\n    case 'object':\n      if (val === null) {\n        buf.writeByte(BSER_NULL);\n        return;\n      }\n      if (val instanceof Int64) {\n        dump_int64(buf, val);\n        return;\n      }\n      if (Array.isArray(val)) {\n        buf.writeByte(BSER_ARRAY);\n        dump_int(buf, val.length);\n        for (var i = 0; i < val.length; ++i) {\n          dump_any(buf, val[i]);\n        }\n        return;\n      }\n      buf.writeByte(BSER_OBJECT);\n      var keys = Object.keys(val);\n\n      // First pass to compute number of defined keys\n      var num_keys = keys.length;\n      for (var i = 0; i < keys.length; ++i) {\n        var key = keys[i];\n        var v = val[key];\n        if (typeof(v) == 'undefined') {\n          num_keys--;\n        }\n      }\n      dump_int(buf, num_keys);\n      for (var i = 0; i < keys.length; ++i) {\n        var key = keys[i];\n        var v = val[key];\n        if (typeof(v) == 'undefined') {\n          // Don't include it\n          continue;\n        }\n        dump_any(buf, key);\n        try {\n          dump_any(buf, v);\n        } catch (e) {\n          throw new Error(\n            e.message + ' (while serializing object property with name `' +\n              key + \"')\");\n        }\n      }\n      return;\n\n    default:\n      throw new Error('cannot serialize type ' + typeof(val) + ' to BSER');\n  }\n}\n\n// BSER encode value and return a buffer of the contents\nfunction dumpToBuffer(val) {\n  var buf = new Accumulator();\n  // Build out the header\n  buf.writeByte(0);\n  buf.writeByte(1);\n  // Reserve room for an int32 to hold our PDU length\n  buf.writeByte(BSER_INT32);\n  buf.writeInt(0, 4); // We'll come back and fill this in at the end\n\n  dump_any(buf, val);\n\n  // Compute PDU length\n  var off = buf.writeOffset;\n  var len = off - 7 /* the header length */;\n  buf.writeOffset = 3; // The length value to fill in\n  buf.writeInt(len, 4); // write the length in the space we reserved\n  buf.writeOffset = off;\n\n  return buf.buf.slice(0, off);\n}\nexports.dumpToBuffer = dumpToBuffer\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}