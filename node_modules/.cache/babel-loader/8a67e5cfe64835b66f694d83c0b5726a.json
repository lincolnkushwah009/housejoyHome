{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\n\nfunction path() {\n  const data = _interopRequireWildcard(require('path'));\n\n  path = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _v8Coverage() {\n  const data = require('@bcoe/v8-coverage');\n\n  _v8Coverage = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _chalk() {\n  const data = _interopRequireDefault(require('chalk'));\n\n  _chalk = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _glob() {\n  const data = _interopRequireDefault(require('glob'));\n\n  _glob = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction fs() {\n  const data = _interopRequireWildcard(require('graceful-fs'));\n\n  fs = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _istanbulLibCoverage() {\n  const data = _interopRequireDefault(require('istanbul-lib-coverage'));\n\n  _istanbulLibCoverage = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _istanbulLibReport() {\n  const data = _interopRequireDefault(require('istanbul-lib-report'));\n\n  _istanbulLibReport = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _istanbulLibSourceMaps() {\n  const data = _interopRequireDefault(require('istanbul-lib-source-maps'));\n\n  _istanbulLibSourceMaps = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _istanbulReports() {\n  const data = _interopRequireDefault(require('istanbul-reports'));\n\n  _istanbulReports = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _v8ToIstanbul() {\n  const data = _interopRequireDefault(require('v8-to-istanbul'));\n\n  _v8ToIstanbul = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestUtil() {\n  const data = require('jest-util');\n\n  _jestUtil = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestWorker() {\n  const data = require('jest-worker');\n\n  _jestWorker = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _BaseReporter = _interopRequireDefault(require('./BaseReporter'));\n\nvar _getWatermarks = _interopRequireDefault(require('./getWatermarks'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== 'function') return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== 'object' && typeof obj !== 'function') {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache(nodeInterop);\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (key !== 'default' && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nconst FAIL_COLOR = _chalk().default.bold.red;\n\nconst RUNNING_TEST_COLOR = _chalk().default.bold.dim;\n\nclass CoverageReporter extends _BaseReporter.default {\n  constructor(globalConfig, options) {\n    super();\n\n    _defineProperty(this, '_coverageMap', void 0);\n\n    _defineProperty(this, '_globalConfig', void 0);\n\n    _defineProperty(this, '_sourceMapStore', void 0);\n\n    _defineProperty(this, '_options', void 0);\n\n    _defineProperty(this, '_v8CoverageResults', void 0);\n\n    this._coverageMap = _istanbulLibCoverage().default.createCoverageMap({});\n    this._globalConfig = globalConfig;\n    this._sourceMapStore = _istanbulLibSourceMaps().default.createSourceMapStore();\n    this._v8CoverageResults = [];\n    this._options = options || {};\n  }\n\n  onTestResult(_test, testResult) {\n    if (testResult.v8Coverage) {\n      this._v8CoverageResults.push(testResult.v8Coverage);\n\n      return;\n    }\n\n    if (testResult.coverage) {\n      this._coverageMap.merge(testResult.coverage);\n    }\n  }\n\n  async onRunComplete(contexts, aggregatedResults) {\n    await this._addUntestedFiles(contexts);\n    const {\n      map,\n      reportContext\n    } = await this._getCoverageResult();\n\n    try {\n      const coverageReporters = this._globalConfig.coverageReporters || [];\n\n      if (!this._globalConfig.useStderr && coverageReporters.length < 1) {\n        coverageReporters.push('text-summary');\n      }\n\n      coverageReporters.forEach(reporter => {\n        let additionalOptions = {};\n\n        if (Array.isArray(reporter)) {\n          [reporter, additionalOptions] = reporter;\n        }\n\n        _istanbulReports().default.create(reporter, {\n          maxCols: process.stdout.columns || Infinity,\n          ...additionalOptions\n        }).execute(reportContext);\n      });\n      aggregatedResults.coverageMap = map;\n    } catch (e) {\n      console.error(_chalk().default.red(`\n        Failed to write coverage reports:\n        ERROR: ${e.toString()}\n        STACK: ${e.stack}\n      `));\n    }\n\n    this._checkThreshold(map);\n  }\n\n  async _addUntestedFiles(contexts) {\n    const files = [];\n    contexts.forEach(context => {\n      const config = context.config;\n\n      if (this._globalConfig.collectCoverageFrom && this._globalConfig.collectCoverageFrom.length) {\n        context.hasteFS.matchFilesWithGlob(this._globalConfig.collectCoverageFrom, config.rootDir).forEach(filePath => files.push({\n          config,\n          path: filePath\n        }));\n      }\n    });\n\n    if (!files.length) {\n      return;\n    }\n\n    if (_jestUtil().isInteractive) {\n      process.stderr.write(RUNNING_TEST_COLOR('Running coverage on untested files...'));\n    }\n\n    let worker;\n\n    if (this._globalConfig.maxWorkers <= 1) {\n      worker = require('./CoverageWorker');\n    } else {\n      worker = new (_jestWorker().Worker)(require.resolve('./CoverageWorker'), {\n        exposedMethods: ['worker'],\n        maxRetries: 2,\n        numWorkers: this._globalConfig.maxWorkers\n      });\n    }\n\n    const instrumentation = files.map(async fileObj => {\n      const filename = fileObj.path;\n      const config = fileObj.config;\n\n      const hasCoverageData = this._v8CoverageResults.some(v8Res => v8Res.some(innerRes => innerRes.result.url === filename));\n\n      if (!hasCoverageData && !this._coverageMap.data[filename] && 'worker' in worker) {\n        try {\n          const result = await worker.worker({\n            config,\n            globalConfig: this._globalConfig,\n            options: { ...this._options,\n              changedFiles: this._options.changedFiles && Array.from(this._options.changedFiles),\n              sourcesRelatedToTestsInChangedFiles: this._options.sourcesRelatedToTestsInChangedFiles && Array.from(this._options.sourcesRelatedToTestsInChangedFiles)\n            },\n            path: filename\n          });\n\n          if (result) {\n            if (result.kind === 'V8Coverage') {\n              this._v8CoverageResults.push([{\n                codeTransformResult: undefined,\n                result: result.result\n              }]);\n            } else {\n              this._coverageMap.addFileCoverage(result.coverage);\n            }\n          }\n        } catch (error) {\n          console.error(_chalk().default.red([`Failed to collect coverage from ${filename}`, `ERROR: ${error.message}`, `STACK: ${error.stack}`].join('\\n')));\n        }\n      }\n    });\n\n    try {\n      await Promise.all(instrumentation);\n    } catch {// Do nothing; errors were reported earlier to the console.\n    }\n\n    if (_jestUtil().isInteractive) {\n      (0, _jestUtil().clearLine)(process.stderr);\n    }\n\n    if (worker && 'end' in worker && typeof worker.end === 'function') {\n      await worker.end();\n    }\n  }\n\n  _checkThreshold(map) {\n    const {\n      coverageThreshold\n    } = this._globalConfig;\n\n    if (coverageThreshold) {\n      function check(name, thresholds, actuals) {\n        return ['statements', 'branches', 'lines', 'functions'].reduce((errors, key) => {\n          const actual = actuals[key].pct;\n          const actualUncovered = actuals[key].total - actuals[key].covered;\n          const threshold = thresholds[key];\n\n          if (threshold !== undefined) {\n            if (threshold < 0) {\n              if (threshold * -1 < actualUncovered) {\n                errors.push(`Jest: Uncovered count for ${key} (${actualUncovered}) ` + `exceeds ${name} threshold (${-1 * threshold})`);\n              }\n            } else if (actual < threshold) {\n              errors.push(`Jest: \"${name}\" coverage threshold for ${key} (${threshold}%) not met: ${actual}%`);\n            }\n          }\n\n          return errors;\n        }, []);\n      }\n\n      const THRESHOLD_GROUP_TYPES = {\n        GLOB: 'glob',\n        GLOBAL: 'global',\n        PATH: 'path'\n      };\n      const coveredFiles = map.files();\n      const thresholdGroups = Object.keys(coverageThreshold);\n      const groupTypeByThresholdGroup = {};\n      const filesByGlob = {};\n      const coveredFilesSortedIntoThresholdGroup = coveredFiles.reduce((files, file) => {\n        const pathOrGlobMatches = thresholdGroups.reduce((agg, thresholdGroup) => {\n          const absoluteThresholdGroup = path().resolve(thresholdGroup); // The threshold group might be a path:\n\n          if (file.indexOf(absoluteThresholdGroup) === 0) {\n            groupTypeByThresholdGroup[thresholdGroup] = THRESHOLD_GROUP_TYPES.PATH;\n            return agg.concat([[file, thresholdGroup]]);\n          } // If the threshold group is not a path it might be a glob:\n          // Note: glob.sync is slow. By memoizing the files matching each glob\n          // (rather than recalculating it for each covered file) we save a tonne\n          // of execution time.\n\n\n          if (filesByGlob[absoluteThresholdGroup] === undefined) {\n            filesByGlob[absoluteThresholdGroup] = _glob().default.sync(absoluteThresholdGroup).map(filePath => path().resolve(filePath));\n          }\n\n          if (filesByGlob[absoluteThresholdGroup].indexOf(file) > -1) {\n            groupTypeByThresholdGroup[thresholdGroup] = THRESHOLD_GROUP_TYPES.GLOB;\n            return agg.concat([[file, thresholdGroup]]);\n          }\n\n          return agg;\n        }, []);\n\n        if (pathOrGlobMatches.length > 0) {\n          return files.concat(pathOrGlobMatches);\n        } // Neither a glob or a path? Toss it in global if there's a global threshold:\n\n\n        if (thresholdGroups.indexOf(THRESHOLD_GROUP_TYPES.GLOBAL) > -1) {\n          groupTypeByThresholdGroup[THRESHOLD_GROUP_TYPES.GLOBAL] = THRESHOLD_GROUP_TYPES.GLOBAL;\n          return files.concat([[file, THRESHOLD_GROUP_TYPES.GLOBAL]]);\n        } // A covered file that doesn't have a threshold:\n\n\n        return files.concat([[file, undefined]]);\n      }, []);\n\n      const getFilesInThresholdGroup = thresholdGroup => coveredFilesSortedIntoThresholdGroup.filter(fileAndGroup => fileAndGroup[1] === thresholdGroup).map(fileAndGroup => fileAndGroup[0]);\n\n      function combineCoverage(filePaths) {\n        return filePaths.map(filePath => map.fileCoverageFor(filePath)).reduce((combinedCoverage, nextFileCoverage) => {\n          if (combinedCoverage === undefined || combinedCoverage === null) {\n            return nextFileCoverage.toSummary();\n          }\n\n          return combinedCoverage.merge(nextFileCoverage.toSummary());\n        }, undefined);\n      }\n\n      let errors = [];\n      thresholdGroups.forEach(thresholdGroup => {\n        switch (groupTypeByThresholdGroup[thresholdGroup]) {\n          case THRESHOLD_GROUP_TYPES.GLOBAL:\n            {\n              const coverage = combineCoverage(getFilesInThresholdGroup(THRESHOLD_GROUP_TYPES.GLOBAL));\n\n              if (coverage) {\n                errors = errors.concat(check(thresholdGroup, coverageThreshold[thresholdGroup], coverage));\n              }\n\n              break;\n            }\n\n          case THRESHOLD_GROUP_TYPES.PATH:\n            {\n              const coverage = combineCoverage(getFilesInThresholdGroup(thresholdGroup));\n\n              if (coverage) {\n                errors = errors.concat(check(thresholdGroup, coverageThreshold[thresholdGroup], coverage));\n              }\n\n              break;\n            }\n\n          case THRESHOLD_GROUP_TYPES.GLOB:\n            getFilesInThresholdGroup(thresholdGroup).forEach(fileMatchingGlob => {\n              errors = errors.concat(check(fileMatchingGlob, coverageThreshold[thresholdGroup], map.fileCoverageFor(fileMatchingGlob).toSummary()));\n            });\n            break;\n\n          default:\n            // If the file specified by path is not found, error is returned.\n            if (thresholdGroup !== THRESHOLD_GROUP_TYPES.GLOBAL) {\n              errors = errors.concat(`Jest: Coverage data for ${thresholdGroup} was not found.`);\n            }\n\n          // Sometimes all files in the coverage data are matched by\n          // PATH and GLOB threshold groups in which case, don't error when\n          // the global threshold group doesn't match any files.\n        }\n      });\n      errors = errors.filter(err => err !== undefined && err !== null && err.length > 0);\n\n      if (errors.length > 0) {\n        this.log(`${FAIL_COLOR(errors.join('\\n'))}`);\n\n        this._setError(new Error(errors.join('\\n')));\n      }\n    }\n  }\n\n  async _getCoverageResult() {\n    if (this._globalConfig.coverageProvider === 'v8') {\n      const mergedCoverages = (0, _v8Coverage().mergeProcessCovs)(this._v8CoverageResults.map(cov => ({\n        result: cov.map(r => r.result)\n      })));\n      const fileTransforms = new Map();\n\n      this._v8CoverageResults.forEach(res => res.forEach(r => {\n        if (r.codeTransformResult && !fileTransforms.has(r.result.url)) {\n          fileTransforms.set(r.result.url, r.codeTransformResult);\n        }\n      }));\n\n      const transformedCoverage = await Promise.all(mergedCoverages.result.map(async res => {\n        var _fileTransform$wrappe;\n\n        const fileTransform = fileTransforms.get(res.url);\n        let sourcemapContent = undefined;\n\n        if (fileTransform !== null && fileTransform !== void 0 && fileTransform.sourceMapPath && fs().existsSync(fileTransform.sourceMapPath)) {\n          sourcemapContent = JSON.parse(fs().readFileSync(fileTransform.sourceMapPath, 'utf8'));\n        }\n\n        const converter = (0, _v8ToIstanbul().default)(res.url, (_fileTransform$wrappe = fileTransform === null || fileTransform === void 0 ? void 0 : fileTransform.wrapperLength) !== null && _fileTransform$wrappe !== void 0 ? _fileTransform$wrappe : 0, fileTransform && sourcemapContent ? {\n          originalSource: fileTransform.originalCode,\n          source: fileTransform.code,\n          sourceMap: {\n            sourcemap: {\n              file: res.url,\n              ...sourcemapContent\n            }\n          }\n        } : {\n          source: fs().readFileSync(res.url, 'utf8')\n        });\n        await converter.load();\n        converter.applyCoverage(res.functions);\n        const istanbulData = converter.toIstanbul();\n        converter.destroy();\n        return istanbulData;\n      }));\n\n      const map = _istanbulLibCoverage().default.createCoverageMap({});\n\n      transformedCoverage.forEach(res => map.merge(res));\n\n      const reportContext = _istanbulLibReport().default.createContext({\n        coverageMap: map,\n        dir: this._globalConfig.coverageDirectory,\n        watermarks: (0, _getWatermarks.default)(this._globalConfig)\n      });\n\n      return {\n        map,\n        reportContext\n      };\n    }\n\n    const map = await this._sourceMapStore.transformCoverage(this._coverageMap);\n\n    const reportContext = _istanbulLibReport().default.createContext({\n      coverageMap: map,\n      dir: this._globalConfig.coverageDirectory,\n      sourceFinder: this._sourceMapStore.sourceFinder,\n      watermarks: (0, _getWatermarks.default)(this._globalConfig)\n    });\n\n    return {\n      map,\n      reportContext\n    };\n  }\n\n}\n\nexports.default = CoverageReporter;\n\n_defineProperty(CoverageReporter, 'filename', __filename);","map":{"version":3,"names":["Object","defineProperty","exports","value","default","path","data","_interopRequireWildcard","require","_v8Coverage","_chalk","_interopRequireDefault","_glob","fs","_istanbulLibCoverage","_istanbulLibReport","_istanbulLibSourceMaps","_istanbulReports","_v8ToIstanbul","_jestUtil","_jestWorker","_BaseReporter","_getWatermarks","obj","__esModule","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","cache","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","_defineProperty","enumerable","configurable","writable","FAIL_COLOR","bold","red","RUNNING_TEST_COLOR","dim","CoverageReporter","constructor","globalConfig","options","_coverageMap","createCoverageMap","_globalConfig","_sourceMapStore","createSourceMapStore","_v8CoverageResults","_options","onTestResult","_test","testResult","v8Coverage","push","coverage","merge","onRunComplete","contexts","aggregatedResults","_addUntestedFiles","map","reportContext","_getCoverageResult","coverageReporters","useStderr","length","forEach","reporter","additionalOptions","Array","isArray","create","maxCols","process","stdout","columns","Infinity","execute","coverageMap","e","console","error","toString","stack","_checkThreshold","files","context","config","collectCoverageFrom","hasteFS","matchFilesWithGlob","rootDir","filePath","isInteractive","stderr","write","worker","maxWorkers","Worker","resolve","exposedMethods","maxRetries","numWorkers","instrumentation","fileObj","filename","hasCoverageData","some","v8Res","innerRes","result","url","changedFiles","from","sourcesRelatedToTestsInChangedFiles","kind","codeTransformResult","undefined","addFileCoverage","message","join","Promise","all","clearLine","end","coverageThreshold","check","name","thresholds","actuals","reduce","errors","actual","pct","actualUncovered","total","covered","threshold","THRESHOLD_GROUP_TYPES","GLOB","GLOBAL","PATH","coveredFiles","thresholdGroups","keys","groupTypeByThresholdGroup","filesByGlob","coveredFilesSortedIntoThresholdGroup","file","pathOrGlobMatches","agg","thresholdGroup","absoluteThresholdGroup","indexOf","concat","sync","getFilesInThresholdGroup","filter","fileAndGroup","combineCoverage","filePaths","fileCoverageFor","combinedCoverage","nextFileCoverage","toSummary","fileMatchingGlob","err","log","_setError","Error","coverageProvider","mergedCoverages","mergeProcessCovs","cov","r","fileTransforms","Map","res","transformedCoverage","_fileTransform$wrappe","fileTransform","sourcemapContent","sourceMapPath","existsSync","JSON","parse","readFileSync","converter","wrapperLength","originalSource","originalCode","source","code","sourceMap","sourcemap","load","applyCoverage","functions","istanbulData","toIstanbul","destroy","createContext","dir","coverageDirectory","watermarks","transformCoverage","sourceFinder","__filename"],"sources":["/Users/lincolnkushwah/Desktop/All/React Projects/house_joy_new/node_modules/@jest/reporters/build/CoverageReporter.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\n\nfunction path() {\n  const data = _interopRequireWildcard(require('path'));\n\n  path = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _v8Coverage() {\n  const data = require('@bcoe/v8-coverage');\n\n  _v8Coverage = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _chalk() {\n  const data = _interopRequireDefault(require('chalk'));\n\n  _chalk = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _glob() {\n  const data = _interopRequireDefault(require('glob'));\n\n  _glob = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction fs() {\n  const data = _interopRequireWildcard(require('graceful-fs'));\n\n  fs = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _istanbulLibCoverage() {\n  const data = _interopRequireDefault(require('istanbul-lib-coverage'));\n\n  _istanbulLibCoverage = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _istanbulLibReport() {\n  const data = _interopRequireDefault(require('istanbul-lib-report'));\n\n  _istanbulLibReport = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _istanbulLibSourceMaps() {\n  const data = _interopRequireDefault(require('istanbul-lib-source-maps'));\n\n  _istanbulLibSourceMaps = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _istanbulReports() {\n  const data = _interopRequireDefault(require('istanbul-reports'));\n\n  _istanbulReports = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _v8ToIstanbul() {\n  const data = _interopRequireDefault(require('v8-to-istanbul'));\n\n  _v8ToIstanbul = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestUtil() {\n  const data = require('jest-util');\n\n  _jestUtil = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestWorker() {\n  const data = require('jest-worker');\n\n  _jestWorker = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _BaseReporter = _interopRequireDefault(require('./BaseReporter'));\n\nvar _getWatermarks = _interopRequireDefault(require('./getWatermarks'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== 'function') return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {\n    return {default: obj};\n  }\n  var cache = _getRequireWildcardCache(nodeInterop);\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor =\n    Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (key !== 'default' && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor\n        ? Object.getOwnPropertyDescriptor(obj, key)\n        : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\nconst FAIL_COLOR = _chalk().default.bold.red;\n\nconst RUNNING_TEST_COLOR = _chalk().default.bold.dim;\n\nclass CoverageReporter extends _BaseReporter.default {\n  constructor(globalConfig, options) {\n    super();\n\n    _defineProperty(this, '_coverageMap', void 0);\n\n    _defineProperty(this, '_globalConfig', void 0);\n\n    _defineProperty(this, '_sourceMapStore', void 0);\n\n    _defineProperty(this, '_options', void 0);\n\n    _defineProperty(this, '_v8CoverageResults', void 0);\n\n    this._coverageMap = _istanbulLibCoverage().default.createCoverageMap({});\n    this._globalConfig = globalConfig;\n    this._sourceMapStore =\n      _istanbulLibSourceMaps().default.createSourceMapStore();\n    this._v8CoverageResults = [];\n    this._options = options || {};\n  }\n\n  onTestResult(_test, testResult) {\n    if (testResult.v8Coverage) {\n      this._v8CoverageResults.push(testResult.v8Coverage);\n\n      return;\n    }\n\n    if (testResult.coverage) {\n      this._coverageMap.merge(testResult.coverage);\n    }\n  }\n\n  async onRunComplete(contexts, aggregatedResults) {\n    await this._addUntestedFiles(contexts);\n    const {map, reportContext} = await this._getCoverageResult();\n\n    try {\n      const coverageReporters = this._globalConfig.coverageReporters || [];\n\n      if (!this._globalConfig.useStderr && coverageReporters.length < 1) {\n        coverageReporters.push('text-summary');\n      }\n\n      coverageReporters.forEach(reporter => {\n        let additionalOptions = {};\n\n        if (Array.isArray(reporter)) {\n          [reporter, additionalOptions] = reporter;\n        }\n\n        _istanbulReports()\n          .default.create(reporter, {\n            maxCols: process.stdout.columns || Infinity,\n            ...additionalOptions\n          })\n          .execute(reportContext);\n      });\n      aggregatedResults.coverageMap = map;\n    } catch (e) {\n      console.error(\n        _chalk().default.red(`\n        Failed to write coverage reports:\n        ERROR: ${e.toString()}\n        STACK: ${e.stack}\n      `)\n      );\n    }\n\n    this._checkThreshold(map);\n  }\n\n  async _addUntestedFiles(contexts) {\n    const files = [];\n    contexts.forEach(context => {\n      const config = context.config;\n\n      if (\n        this._globalConfig.collectCoverageFrom &&\n        this._globalConfig.collectCoverageFrom.length\n      ) {\n        context.hasteFS\n          .matchFilesWithGlob(\n            this._globalConfig.collectCoverageFrom,\n            config.rootDir\n          )\n          .forEach(filePath =>\n            files.push({\n              config,\n              path: filePath\n            })\n          );\n      }\n    });\n\n    if (!files.length) {\n      return;\n    }\n\n    if (_jestUtil().isInteractive) {\n      process.stderr.write(\n        RUNNING_TEST_COLOR('Running coverage on untested files...')\n      );\n    }\n\n    let worker;\n\n    if (this._globalConfig.maxWorkers <= 1) {\n      worker = require('./CoverageWorker');\n    } else {\n      worker = new (_jestWorker().Worker)(require.resolve('./CoverageWorker'), {\n        exposedMethods: ['worker'],\n        maxRetries: 2,\n        numWorkers: this._globalConfig.maxWorkers\n      });\n    }\n\n    const instrumentation = files.map(async fileObj => {\n      const filename = fileObj.path;\n      const config = fileObj.config;\n\n      const hasCoverageData = this._v8CoverageResults.some(v8Res =>\n        v8Res.some(innerRes => innerRes.result.url === filename)\n      );\n\n      if (\n        !hasCoverageData &&\n        !this._coverageMap.data[filename] &&\n        'worker' in worker\n      ) {\n        try {\n          const result = await worker.worker({\n            config,\n            globalConfig: this._globalConfig,\n            options: {\n              ...this._options,\n              changedFiles:\n                this._options.changedFiles &&\n                Array.from(this._options.changedFiles),\n              sourcesRelatedToTestsInChangedFiles:\n                this._options.sourcesRelatedToTestsInChangedFiles &&\n                Array.from(this._options.sourcesRelatedToTestsInChangedFiles)\n            },\n            path: filename\n          });\n\n          if (result) {\n            if (result.kind === 'V8Coverage') {\n              this._v8CoverageResults.push([\n                {\n                  codeTransformResult: undefined,\n                  result: result.result\n                }\n              ]);\n            } else {\n              this._coverageMap.addFileCoverage(result.coverage);\n            }\n          }\n        } catch (error) {\n          console.error(\n            _chalk().default.red(\n              [\n                `Failed to collect coverage from ${filename}`,\n                `ERROR: ${error.message}`,\n                `STACK: ${error.stack}`\n              ].join('\\n')\n            )\n          );\n        }\n      }\n    });\n\n    try {\n      await Promise.all(instrumentation);\n    } catch {\n      // Do nothing; errors were reported earlier to the console.\n    }\n\n    if (_jestUtil().isInteractive) {\n      (0, _jestUtil().clearLine)(process.stderr);\n    }\n\n    if (worker && 'end' in worker && typeof worker.end === 'function') {\n      await worker.end();\n    }\n  }\n\n  _checkThreshold(map) {\n    const {coverageThreshold} = this._globalConfig;\n\n    if (coverageThreshold) {\n      function check(name, thresholds, actuals) {\n        return ['statements', 'branches', 'lines', 'functions'].reduce(\n          (errors, key) => {\n            const actual = actuals[key].pct;\n            const actualUncovered = actuals[key].total - actuals[key].covered;\n            const threshold = thresholds[key];\n\n            if (threshold !== undefined) {\n              if (threshold < 0) {\n                if (threshold * -1 < actualUncovered) {\n                  errors.push(\n                    `Jest: Uncovered count for ${key} (${actualUncovered}) ` +\n                      `exceeds ${name} threshold (${-1 * threshold})`\n                  );\n                }\n              } else if (actual < threshold) {\n                errors.push(\n                  `Jest: \"${name}\" coverage threshold for ${key} (${threshold}%) not met: ${actual}%`\n                );\n              }\n            }\n\n            return errors;\n          },\n          []\n        );\n      }\n\n      const THRESHOLD_GROUP_TYPES = {\n        GLOB: 'glob',\n        GLOBAL: 'global',\n        PATH: 'path'\n      };\n      const coveredFiles = map.files();\n      const thresholdGroups = Object.keys(coverageThreshold);\n      const groupTypeByThresholdGroup = {};\n      const filesByGlob = {};\n      const coveredFilesSortedIntoThresholdGroup = coveredFiles.reduce(\n        (files, file) => {\n          const pathOrGlobMatches = thresholdGroups.reduce(\n            (agg, thresholdGroup) => {\n              const absoluteThresholdGroup = path().resolve(thresholdGroup); // The threshold group might be a path:\n\n              if (file.indexOf(absoluteThresholdGroup) === 0) {\n                groupTypeByThresholdGroup[thresholdGroup] =\n                  THRESHOLD_GROUP_TYPES.PATH;\n                return agg.concat([[file, thresholdGroup]]);\n              } // If the threshold group is not a path it might be a glob:\n              // Note: glob.sync is slow. By memoizing the files matching each glob\n              // (rather than recalculating it for each covered file) we save a tonne\n              // of execution time.\n\n              if (filesByGlob[absoluteThresholdGroup] === undefined) {\n                filesByGlob[absoluteThresholdGroup] = _glob()\n                  .default.sync(absoluteThresholdGroup)\n                  .map(filePath => path().resolve(filePath));\n              }\n\n              if (filesByGlob[absoluteThresholdGroup].indexOf(file) > -1) {\n                groupTypeByThresholdGroup[thresholdGroup] =\n                  THRESHOLD_GROUP_TYPES.GLOB;\n                return agg.concat([[file, thresholdGroup]]);\n              }\n\n              return agg;\n            },\n            []\n          );\n\n          if (pathOrGlobMatches.length > 0) {\n            return files.concat(pathOrGlobMatches);\n          } // Neither a glob or a path? Toss it in global if there's a global threshold:\n\n          if (thresholdGroups.indexOf(THRESHOLD_GROUP_TYPES.GLOBAL) > -1) {\n            groupTypeByThresholdGroup[THRESHOLD_GROUP_TYPES.GLOBAL] =\n              THRESHOLD_GROUP_TYPES.GLOBAL;\n            return files.concat([[file, THRESHOLD_GROUP_TYPES.GLOBAL]]);\n          } // A covered file that doesn't have a threshold:\n\n          return files.concat([[file, undefined]]);\n        },\n        []\n      );\n\n      const getFilesInThresholdGroup = thresholdGroup =>\n        coveredFilesSortedIntoThresholdGroup\n          .filter(fileAndGroup => fileAndGroup[1] === thresholdGroup)\n          .map(fileAndGroup => fileAndGroup[0]);\n\n      function combineCoverage(filePaths) {\n        return filePaths\n          .map(filePath => map.fileCoverageFor(filePath))\n          .reduce((combinedCoverage, nextFileCoverage) => {\n            if (combinedCoverage === undefined || combinedCoverage === null) {\n              return nextFileCoverage.toSummary();\n            }\n\n            return combinedCoverage.merge(nextFileCoverage.toSummary());\n          }, undefined);\n      }\n\n      let errors = [];\n      thresholdGroups.forEach(thresholdGroup => {\n        switch (groupTypeByThresholdGroup[thresholdGroup]) {\n          case THRESHOLD_GROUP_TYPES.GLOBAL: {\n            const coverage = combineCoverage(\n              getFilesInThresholdGroup(THRESHOLD_GROUP_TYPES.GLOBAL)\n            );\n\n            if (coverage) {\n              errors = errors.concat(\n                check(\n                  thresholdGroup,\n                  coverageThreshold[thresholdGroup],\n                  coverage\n                )\n              );\n            }\n\n            break;\n          }\n\n          case THRESHOLD_GROUP_TYPES.PATH: {\n            const coverage = combineCoverage(\n              getFilesInThresholdGroup(thresholdGroup)\n            );\n\n            if (coverage) {\n              errors = errors.concat(\n                check(\n                  thresholdGroup,\n                  coverageThreshold[thresholdGroup],\n                  coverage\n                )\n              );\n            }\n\n            break;\n          }\n\n          case THRESHOLD_GROUP_TYPES.GLOB:\n            getFilesInThresholdGroup(thresholdGroup).forEach(\n              fileMatchingGlob => {\n                errors = errors.concat(\n                  check(\n                    fileMatchingGlob,\n                    coverageThreshold[thresholdGroup],\n                    map.fileCoverageFor(fileMatchingGlob).toSummary()\n                  )\n                );\n              }\n            );\n            break;\n\n          default:\n            // If the file specified by path is not found, error is returned.\n            if (thresholdGroup !== THRESHOLD_GROUP_TYPES.GLOBAL) {\n              errors = errors.concat(\n                `Jest: Coverage data for ${thresholdGroup} was not found.`\n              );\n            }\n\n          // Sometimes all files in the coverage data are matched by\n          // PATH and GLOB threshold groups in which case, don't error when\n          // the global threshold group doesn't match any files.\n        }\n      });\n      errors = errors.filter(\n        err => err !== undefined && err !== null && err.length > 0\n      );\n\n      if (errors.length > 0) {\n        this.log(`${FAIL_COLOR(errors.join('\\n'))}`);\n\n        this._setError(new Error(errors.join('\\n')));\n      }\n    }\n  }\n\n  async _getCoverageResult() {\n    if (this._globalConfig.coverageProvider === 'v8') {\n      const mergedCoverages = (0, _v8Coverage().mergeProcessCovs)(\n        this._v8CoverageResults.map(cov => ({\n          result: cov.map(r => r.result)\n        }))\n      );\n      const fileTransforms = new Map();\n\n      this._v8CoverageResults.forEach(res =>\n        res.forEach(r => {\n          if (r.codeTransformResult && !fileTransforms.has(r.result.url)) {\n            fileTransforms.set(r.result.url, r.codeTransformResult);\n          }\n        })\n      );\n\n      const transformedCoverage = await Promise.all(\n        mergedCoverages.result.map(async res => {\n          var _fileTransform$wrappe;\n\n          const fileTransform = fileTransforms.get(res.url);\n          let sourcemapContent = undefined;\n\n          if (\n            fileTransform !== null &&\n            fileTransform !== void 0 &&\n            fileTransform.sourceMapPath &&\n            fs().existsSync(fileTransform.sourceMapPath)\n          ) {\n            sourcemapContent = JSON.parse(\n              fs().readFileSync(fileTransform.sourceMapPath, 'utf8')\n            );\n          }\n\n          const converter = (0, _v8ToIstanbul().default)(\n            res.url,\n            (_fileTransform$wrappe =\n              fileTransform === null || fileTransform === void 0\n                ? void 0\n                : fileTransform.wrapperLength) !== null &&\n              _fileTransform$wrappe !== void 0\n              ? _fileTransform$wrappe\n              : 0,\n            fileTransform && sourcemapContent\n              ? {\n                  originalSource: fileTransform.originalCode,\n                  source: fileTransform.code,\n                  sourceMap: {\n                    sourcemap: {\n                      file: res.url,\n                      ...sourcemapContent\n                    }\n                  }\n                }\n              : {\n                  source: fs().readFileSync(res.url, 'utf8')\n                }\n          );\n          await converter.load();\n          converter.applyCoverage(res.functions);\n          const istanbulData = converter.toIstanbul();\n          converter.destroy();\n          return istanbulData;\n        })\n      );\n\n      const map = _istanbulLibCoverage().default.createCoverageMap({});\n\n      transformedCoverage.forEach(res => map.merge(res));\n\n      const reportContext = _istanbulLibReport().default.createContext({\n        coverageMap: map,\n        dir: this._globalConfig.coverageDirectory,\n        watermarks: (0, _getWatermarks.default)(this._globalConfig)\n      });\n\n      return {\n        map,\n        reportContext\n      };\n    }\n\n    const map = await this._sourceMapStore.transformCoverage(this._coverageMap);\n\n    const reportContext = _istanbulLibReport().default.createContext({\n      coverageMap: map,\n      dir: this._globalConfig.coverageDirectory,\n      sourceFinder: this._sourceMapStore.sourceFinder,\n      watermarks: (0, _getWatermarks.default)(this._globalConfig)\n    });\n\n    return {\n      map,\n      reportContext\n    };\n  }\n}\n\nexports.default = CoverageReporter;\n\n_defineProperty(CoverageReporter, 'filename', __filename);\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}