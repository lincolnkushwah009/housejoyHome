{"ast":null,"code":"/**\n * ...something resembling a binary search, to find the lowest line within the range.\n * And then you could break as soon as the line is longer than the range...\n */\nmodule.exports.sliceRange = function (lines, startCol, endCol) {\n  let inclusive = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  let start = 0;\n  let end = lines.length - 1;\n  /**\n   * I consider this a temporary solution until I find an alternaive way to fix the \"off by one issue\"\n   */\n\n  const extStartCol = inclusive ? startCol - 1 : startCol;\n\n  while (start < end) {\n    const mid = start + end >> 1;\n\n    if (lines[mid].startCol <= startCol && lines[mid].endCol > extStartCol) {\n      start = mid;\n      end = start;\n    } else if (lines[mid].startCol > startCol) {\n      end = mid - 1;\n    } else {\n      start = mid + 1;\n    }\n  }\n\n  if (start === end) {\n    while (end < lines.length && extStartCol < lines[end].endCol && endCol >= lines[end].startCol) {\n      ++end;\n    }\n\n    return lines.slice(start, end);\n  } else {\n    return [];\n  }\n};","map":{"version":3,"names":["module","exports","sliceRange","lines","startCol","endCol","inclusive","start","end","length","extStartCol","mid","slice"],"sources":["/Users/lincolnkushwah/Desktop/All/React Projects/house_joy_new/node_modules/v8-to-istanbul/lib/range.js"],"sourcesContent":["/**\n * ...something resembling a binary search, to find the lowest line within the range.\n * And then you could break as soon as the line is longer than the range...\n */\nmodule.exports.sliceRange = (lines, startCol, endCol, inclusive = false) => {\n  let start = 0\n  let end = lines.length - 1\n\n  /**\n   * I consider this a temporary solution until I find an alternaive way to fix the \"off by one issue\"\n   */\n  const extStartCol = inclusive ? startCol - 1 : startCol\n\n  while (start < end) {\n    const mid = (start + end) >> 1\n    if (lines[mid].startCol <= startCol && lines[mid].endCol > extStartCol) {\n      start = mid\n      end = start\n    } else if (lines[mid].startCol > startCol) {\n      end = mid - 1\n    } else {\n      start = mid + 1\n    }\n  }\n  if (start === end) {\n    while (end < lines.length && extStartCol < lines[end].endCol && endCol >= lines[end].startCol) {\n      ++end\n    }\n    return lines.slice(start, end)\n  } else {\n    return []\n  }\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACAA,MAAM,CAACC,OAAP,CAAeC,UAAf,GAA4B,UAACC,KAAD,EAAQC,QAAR,EAAkBC,MAAlB,EAAgD;EAAA,IAAtBC,SAAsB,uEAAV,KAAU;EAC1E,IAAIC,KAAK,GAAG,CAAZ;EACA,IAAIC,GAAG,GAAGL,KAAK,CAACM,MAAN,GAAe,CAAzB;EAEA;AACF;AACA;;EACE,MAAMC,WAAW,GAAGJ,SAAS,GAAGF,QAAQ,GAAG,CAAd,GAAkBA,QAA/C;;EAEA,OAAOG,KAAK,GAAGC,GAAf,EAAoB;IAClB,MAAMG,GAAG,GAAIJ,KAAK,GAAGC,GAAT,IAAiB,CAA7B;;IACA,IAAIL,KAAK,CAACQ,GAAD,CAAL,CAAWP,QAAX,IAAuBA,QAAvB,IAAmCD,KAAK,CAACQ,GAAD,CAAL,CAAWN,MAAX,GAAoBK,WAA3D,EAAwE;MACtEH,KAAK,GAAGI,GAAR;MACAH,GAAG,GAAGD,KAAN;IACD,CAHD,MAGO,IAAIJ,KAAK,CAACQ,GAAD,CAAL,CAAWP,QAAX,GAAsBA,QAA1B,EAAoC;MACzCI,GAAG,GAAGG,GAAG,GAAG,CAAZ;IACD,CAFM,MAEA;MACLJ,KAAK,GAAGI,GAAG,GAAG,CAAd;IACD;EACF;;EACD,IAAIJ,KAAK,KAAKC,GAAd,EAAmB;IACjB,OAAOA,GAAG,GAAGL,KAAK,CAACM,MAAZ,IAAsBC,WAAW,GAAGP,KAAK,CAACK,GAAD,CAAL,CAAWH,MAA/C,IAAyDA,MAAM,IAAIF,KAAK,CAACK,GAAD,CAAL,CAAWJ,QAArF,EAA+F;MAC7F,EAAEI,GAAF;IACD;;IACD,OAAOL,KAAK,CAACS,KAAN,CAAYL,KAAZ,EAAmBC,GAAnB,CAAP;EACD,CALD,MAKO;IACL,OAAO,EAAP;EACD;AACF,CA5BD"},"metadata":{},"sourceType":"script"}