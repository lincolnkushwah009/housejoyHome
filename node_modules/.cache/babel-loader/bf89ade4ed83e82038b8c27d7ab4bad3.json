{"ast":null,"code":"'use strict';\n\nfunction path() {\n  const data = _interopRequireWildcard(require('path'));\n\n  path = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _fbWatchman() {\n  const data = _interopRequireDefault(require('fb-watchman'));\n\n  _fbWatchman = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _constants = _interopRequireDefault(require('../constants'));\n\nvar fastPath = _interopRequireWildcard(require('../lib/fast_path'));\n\nvar _normalizePathSep = _interopRequireDefault(require('../lib/normalizePathSep'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== 'function') return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== 'object' && typeof obj !== 'function') {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache(nodeInterop);\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (key !== 'default' && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nconst watchmanURL = 'https://facebook.github.io/watchman/docs/troubleshooting';\n\nfunction WatchmanError(error) {\n  error.message = `Watchman error: ${error.message.trim()}. Make sure watchman ` + `is running for this project. See ${watchmanURL}.`;\n  return error;\n}\n/**\n * Wrap watchman capabilityCheck method as a promise.\n *\n * @param client watchman client\n * @param caps capabilities to verify\n * @returns a promise resolving to a list of verified capabilities\n */\n\n\nasync function capabilityCheck(client, caps) {\n  return new Promise((resolve, reject) => {\n    client.capabilityCheck( // @ts-expect-error: incorrectly typed\n    caps, (error, response) => {\n      if (error) {\n        reject(error);\n      } else {\n        resolve(response);\n      }\n    });\n  });\n}\n\nmodule.exports = async function watchmanCrawl(options) {\n  const fields = ['name', 'exists', 'mtime_ms', 'size'];\n  const {\n    data,\n    extensions,\n    ignore,\n    rootDir,\n    roots\n  } = options;\n  const defaultWatchExpression = ['allof', ['type', 'f']];\n  const clocks = data.clocks;\n  const client = new (_fbWatchman().default.Client)(); // https://facebook.github.io/watchman/docs/capabilities.html\n  // Check adds about ~28ms\n\n  const capabilities = await capabilityCheck(client, {\n    // If a required capability is missing then an error will be thrown,\n    // we don't need this assertion, so using optional instead.\n    optional: ['suffix-set']\n  });\n\n  if (capabilities !== null && capabilities !== void 0 && capabilities.capabilities['suffix-set']) {\n    // If available, use the optimized `suffix-set` operation:\n    // https://facebook.github.io/watchman/docs/expr/suffix.html#suffix-set\n    defaultWatchExpression.push(['suffix', extensions]);\n  } else {\n    // Otherwise use the older and less optimal suffix tuple array\n    defaultWatchExpression.push(['anyof', ...extensions.map(extension => ['suffix', extension])]);\n  }\n\n  let clientError;\n  client.on('error', error => clientError = WatchmanError(error));\n\n  const cmd = function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return new Promise((resolve, reject) => client.command(args, (error, result) => error ? reject(WatchmanError(error)) : resolve(result)));\n  };\n\n  if (options.computeSha1) {\n    const {\n      capabilities\n    } = await cmd('list-capabilities');\n\n    if (capabilities.indexOf('field-content.sha1hex') !== -1) {\n      fields.push('content.sha1hex');\n    }\n  }\n\n  async function getWatchmanRoots(roots) {\n    const watchmanRoots = new Map();\n    await Promise.all(roots.map(async root => {\n      const response = await cmd('watch-project', root);\n      const existing = watchmanRoots.get(response.watch); // A root can only be filtered if it was never seen with a\n      // relative_path before.\n\n      const canBeFiltered = !existing || existing.length > 0;\n\n      if (canBeFiltered) {\n        if (response.relative_path) {\n          watchmanRoots.set(response.watch, (existing || []).concat(response.relative_path));\n        } else {\n          // Make the filter directories an empty array to signal that this\n          // root was already seen and needs to be watched for all files or\n          // directories.\n          watchmanRoots.set(response.watch, []);\n        }\n      }\n    }));\n    return watchmanRoots;\n  }\n\n  async function queryWatchmanForDirs(rootProjectDirMappings) {\n    const results = new Map();\n    let isFresh = false;\n    await Promise.all(Array.from(rootProjectDirMappings).map(async _ref => {\n      let [root, directoryFilters] = _ref;\n\n      var _since$scm;\n\n      const expression = Array.from(defaultWatchExpression);\n      const glob = [];\n\n      if (directoryFilters.length > 0) {\n        expression.push(['anyof', ...directoryFilters.map(dir => ['dirname', dir])]);\n\n        for (const directory of directoryFilters) {\n          for (const extension of extensions) {\n            glob.push(`${directory}/**/*.${extension}`);\n          }\n        }\n      } else {\n        for (const extension of extensions) {\n          glob.push(`**/*.${extension}`);\n        }\n      } // Jest is only going to store one type of clock; a string that\n      // represents a local clock. However, the Watchman crawler supports\n      // a second type of clock that can be written by automation outside of\n      // Jest, called an \"scm query\", which fetches changed files based on\n      // source control mergebases. The reason this is necessary is because\n      // local clocks are not portable across systems, but scm queries are.\n      // By using scm queries, we can create the haste map on a different\n      // system and import it, transforming the clock into a local clock.\n\n\n      const since = clocks.get(fastPath.relative(rootDir, root));\n      const query = since !== undefined // Use the `since` generator if we have a clock available\n      ? {\n        expression,\n        fields,\n        since\n      } // Otherwise use the `glob` filter\n      : {\n        expression,\n        fields,\n        glob,\n        glob_includedotfiles: true\n      };\n      const response = await cmd('query', root, query);\n\n      if ('warning' in response) {\n        console.warn('watchman warning: ', response.warning);\n      } // When a source-control query is used, we ignore the \"is fresh\"\n      // response from Watchman because it will be true despite the query\n      // being incremental.\n\n\n      const isSourceControlQuery = typeof since !== 'string' && (since === null || since === void 0 ? void 0 : (_since$scm = since.scm) === null || _since$scm === void 0 ? void 0 : _since$scm['mergebase-with']) !== undefined;\n\n      if (!isSourceControlQuery) {\n        isFresh = isFresh || response.is_fresh_instance;\n      }\n\n      results.set(root, response);\n    }));\n    return {\n      isFresh,\n      results\n    };\n  }\n\n  let files = data.files;\n  let removedFiles = new Map();\n  const changedFiles = new Map();\n  let results;\n  let isFresh = false;\n\n  try {\n    const watchmanRoots = await getWatchmanRoots(roots);\n    const watchmanFileResults = await queryWatchmanForDirs(watchmanRoots); // Reset the file map if watchman was restarted and sends us a list of\n    // files.\n\n    if (watchmanFileResults.isFresh) {\n      files = new Map();\n      removedFiles = new Map(data.files);\n      isFresh = true;\n    }\n\n    results = watchmanFileResults.results;\n  } finally {\n    client.end();\n  }\n\n  if (clientError) {\n    throw clientError;\n  }\n\n  for (const [watchRoot, response] of results) {\n    const fsRoot = (0, _normalizePathSep.default)(watchRoot);\n    const relativeFsRoot = fastPath.relative(rootDir, fsRoot);\n    clocks.set(relativeFsRoot, // Ensure we persist only the local clock.\n    typeof response.clock === 'string' ? response.clock : response.clock.clock);\n\n    for (const fileData of response.files) {\n      const filePath = fsRoot + path().sep + (0, _normalizePathSep.default)(fileData.name);\n      const relativeFilePath = fastPath.relative(rootDir, filePath);\n      const existingFileData = data.files.get(relativeFilePath); // If watchman is fresh, the removed files map starts with all files\n      // and we remove them as we verify they still exist.\n\n      if (isFresh && existingFileData && fileData.exists) {\n        removedFiles.delete(relativeFilePath);\n      }\n\n      if (!fileData.exists) {\n        // No need to act on files that do not exist and were not tracked.\n        if (existingFileData) {\n          files.delete(relativeFilePath); // If watchman is not fresh, we will know what specific files were\n          // deleted since we last ran and can track only those files.\n\n          if (!isFresh) {\n            removedFiles.set(relativeFilePath, existingFileData);\n          }\n        }\n      } else if (!ignore(filePath)) {\n        const mtime = typeof fileData.mtime_ms === 'number' ? fileData.mtime_ms : fileData.mtime_ms.toNumber();\n        const size = fileData.size;\n        let sha1hex = fileData['content.sha1hex'];\n\n        if (typeof sha1hex !== 'string' || sha1hex.length !== 40) {\n          sha1hex = undefined;\n        }\n\n        let nextData;\n\n        if (existingFileData && existingFileData[_constants.default.MTIME] === mtime) {\n          nextData = existingFileData;\n        } else if (existingFileData && sha1hex && existingFileData[_constants.default.SHA1] === sha1hex) {\n          nextData = [existingFileData[0], mtime, existingFileData[2], existingFileData[3], existingFileData[4], existingFileData[5]];\n        } else {\n          var _sha1hex; // See ../constants.ts\n\n\n          nextData = ['', mtime, size, 0, '', (_sha1hex = sha1hex) !== null && _sha1hex !== void 0 ? _sha1hex : null];\n        }\n\n        files.set(relativeFilePath, nextData);\n        changedFiles.set(relativeFilePath, nextData);\n      }\n    }\n  }\n\n  data.files = files;\n  return {\n    changedFiles: isFresh ? undefined : changedFiles,\n    hasteMap: data,\n    removedFiles\n  };\n};","map":{"version":3,"names":["path","data","_interopRequireWildcard","require","_fbWatchman","_interopRequireDefault","_constants","fastPath","_normalizePathSep","obj","__esModule","default","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","cache","has","get","newObj","hasPropertyDescriptor","Object","defineProperty","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","watchmanURL","WatchmanError","error","message","trim","capabilityCheck","client","caps","Promise","resolve","reject","response","module","exports","watchmanCrawl","options","fields","extensions","ignore","rootDir","roots","defaultWatchExpression","clocks","Client","capabilities","optional","push","map","extension","clientError","on","cmd","args","command","result","computeSha1","indexOf","getWatchmanRoots","watchmanRoots","Map","all","root","existing","watch","canBeFiltered","length","relative_path","concat","queryWatchmanForDirs","rootProjectDirMappings","results","isFresh","Array","from","directoryFilters","_since$scm","expression","glob","dir","directory","since","relative","query","undefined","glob_includedotfiles","console","warn","warning","isSourceControlQuery","scm","is_fresh_instance","files","removedFiles","changedFiles","watchmanFileResults","end","watchRoot","fsRoot","relativeFsRoot","clock","fileData","filePath","sep","name","relativeFilePath","existingFileData","exists","delete","mtime","mtime_ms","toNumber","size","sha1hex","nextData","MTIME","SHA1","_sha1hex","hasteMap"],"sources":["/Users/lincolnkushwah/Desktop/All/React Projects/house_joy_new/node_modules/jest-haste-map/build/crawlers/watchman.js"],"sourcesContent":["'use strict';\n\nfunction path() {\n  const data = _interopRequireWildcard(require('path'));\n\n  path = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _fbWatchman() {\n  const data = _interopRequireDefault(require('fb-watchman'));\n\n  _fbWatchman = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _constants = _interopRequireDefault(require('../constants'));\n\nvar fastPath = _interopRequireWildcard(require('../lib/fast_path'));\n\nvar _normalizePathSep = _interopRequireDefault(\n  require('../lib/normalizePathSep')\n);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== 'function') return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {\n    return {default: obj};\n  }\n  var cache = _getRequireWildcardCache(nodeInterop);\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor =\n    Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (key !== 'default' && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor\n        ? Object.getOwnPropertyDescriptor(obj, key)\n        : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nconst watchmanURL = 'https://facebook.github.io/watchman/docs/troubleshooting';\n\nfunction WatchmanError(error) {\n  error.message =\n    `Watchman error: ${error.message.trim()}. Make sure watchman ` +\n    `is running for this project. See ${watchmanURL}.`;\n  return error;\n}\n/**\n * Wrap watchman capabilityCheck method as a promise.\n *\n * @param client watchman client\n * @param caps capabilities to verify\n * @returns a promise resolving to a list of verified capabilities\n */\n\nasync function capabilityCheck(client, caps) {\n  return new Promise((resolve, reject) => {\n    client.capabilityCheck(\n      // @ts-expect-error: incorrectly typed\n      caps,\n      (error, response) => {\n        if (error) {\n          reject(error);\n        } else {\n          resolve(response);\n        }\n      }\n    );\n  });\n}\n\nmodule.exports = async function watchmanCrawl(options) {\n  const fields = ['name', 'exists', 'mtime_ms', 'size'];\n  const {data, extensions, ignore, rootDir, roots} = options;\n  const defaultWatchExpression = ['allof', ['type', 'f']];\n  const clocks = data.clocks;\n  const client = new (_fbWatchman().default.Client)(); // https://facebook.github.io/watchman/docs/capabilities.html\n  // Check adds about ~28ms\n\n  const capabilities = await capabilityCheck(client, {\n    // If a required capability is missing then an error will be thrown,\n    // we don't need this assertion, so using optional instead.\n    optional: ['suffix-set']\n  });\n\n  if (\n    capabilities !== null &&\n    capabilities !== void 0 &&\n    capabilities.capabilities['suffix-set']\n  ) {\n    // If available, use the optimized `suffix-set` operation:\n    // https://facebook.github.io/watchman/docs/expr/suffix.html#suffix-set\n    defaultWatchExpression.push(['suffix', extensions]);\n  } else {\n    // Otherwise use the older and less optimal suffix tuple array\n    defaultWatchExpression.push([\n      'anyof',\n      ...extensions.map(extension => ['suffix', extension])\n    ]);\n  }\n\n  let clientError;\n  client.on('error', error => (clientError = WatchmanError(error)));\n\n  const cmd = (...args) =>\n    new Promise((resolve, reject) =>\n      client.command(args, (error, result) =>\n        error ? reject(WatchmanError(error)) : resolve(result)\n      )\n    );\n\n  if (options.computeSha1) {\n    const {capabilities} = await cmd('list-capabilities');\n\n    if (capabilities.indexOf('field-content.sha1hex') !== -1) {\n      fields.push('content.sha1hex');\n    }\n  }\n\n  async function getWatchmanRoots(roots) {\n    const watchmanRoots = new Map();\n    await Promise.all(\n      roots.map(async root => {\n        const response = await cmd('watch-project', root);\n        const existing = watchmanRoots.get(response.watch); // A root can only be filtered if it was never seen with a\n        // relative_path before.\n\n        const canBeFiltered = !existing || existing.length > 0;\n\n        if (canBeFiltered) {\n          if (response.relative_path) {\n            watchmanRoots.set(\n              response.watch,\n              (existing || []).concat(response.relative_path)\n            );\n          } else {\n            // Make the filter directories an empty array to signal that this\n            // root was already seen and needs to be watched for all files or\n            // directories.\n            watchmanRoots.set(response.watch, []);\n          }\n        }\n      })\n    );\n    return watchmanRoots;\n  }\n\n  async function queryWatchmanForDirs(rootProjectDirMappings) {\n    const results = new Map();\n    let isFresh = false;\n    await Promise.all(\n      Array.from(rootProjectDirMappings).map(\n        async ([root, directoryFilters]) => {\n          var _since$scm;\n\n          const expression = Array.from(defaultWatchExpression);\n          const glob = [];\n\n          if (directoryFilters.length > 0) {\n            expression.push([\n              'anyof',\n              ...directoryFilters.map(dir => ['dirname', dir])\n            ]);\n\n            for (const directory of directoryFilters) {\n              for (const extension of extensions) {\n                glob.push(`${directory}/**/*.${extension}`);\n              }\n            }\n          } else {\n            for (const extension of extensions) {\n              glob.push(`**/*.${extension}`);\n            }\n          } // Jest is only going to store one type of clock; a string that\n          // represents a local clock. However, the Watchman crawler supports\n          // a second type of clock that can be written by automation outside of\n          // Jest, called an \"scm query\", which fetches changed files based on\n          // source control mergebases. The reason this is necessary is because\n          // local clocks are not portable across systems, but scm queries are.\n          // By using scm queries, we can create the haste map on a different\n          // system and import it, transforming the clock into a local clock.\n\n          const since = clocks.get(fastPath.relative(rootDir, root));\n          const query =\n            since !== undefined // Use the `since` generator if we have a clock available\n              ? {\n                  expression,\n                  fields,\n                  since\n                } // Otherwise use the `glob` filter\n              : {\n                  expression,\n                  fields,\n                  glob,\n                  glob_includedotfiles: true\n                };\n          const response = await cmd('query', root, query);\n\n          if ('warning' in response) {\n            console.warn('watchman warning: ', response.warning);\n          } // When a source-control query is used, we ignore the \"is fresh\"\n          // response from Watchman because it will be true despite the query\n          // being incremental.\n\n          const isSourceControlQuery =\n            typeof since !== 'string' &&\n            (since === null || since === void 0\n              ? void 0\n              : (_since$scm = since.scm) === null || _since$scm === void 0\n              ? void 0\n              : _since$scm['mergebase-with']) !== undefined;\n\n          if (!isSourceControlQuery) {\n            isFresh = isFresh || response.is_fresh_instance;\n          }\n\n          results.set(root, response);\n        }\n      )\n    );\n    return {\n      isFresh,\n      results\n    };\n  }\n\n  let files = data.files;\n  let removedFiles = new Map();\n  const changedFiles = new Map();\n  let results;\n  let isFresh = false;\n\n  try {\n    const watchmanRoots = await getWatchmanRoots(roots);\n    const watchmanFileResults = await queryWatchmanForDirs(watchmanRoots); // Reset the file map if watchman was restarted and sends us a list of\n    // files.\n\n    if (watchmanFileResults.isFresh) {\n      files = new Map();\n      removedFiles = new Map(data.files);\n      isFresh = true;\n    }\n\n    results = watchmanFileResults.results;\n  } finally {\n    client.end();\n  }\n\n  if (clientError) {\n    throw clientError;\n  }\n\n  for (const [watchRoot, response] of results) {\n    const fsRoot = (0, _normalizePathSep.default)(watchRoot);\n    const relativeFsRoot = fastPath.relative(rootDir, fsRoot);\n    clocks.set(\n      relativeFsRoot, // Ensure we persist only the local clock.\n      typeof response.clock === 'string' ? response.clock : response.clock.clock\n    );\n\n    for (const fileData of response.files) {\n      const filePath =\n        fsRoot + path().sep + (0, _normalizePathSep.default)(fileData.name);\n      const relativeFilePath = fastPath.relative(rootDir, filePath);\n      const existingFileData = data.files.get(relativeFilePath); // If watchman is fresh, the removed files map starts with all files\n      // and we remove them as we verify they still exist.\n\n      if (isFresh && existingFileData && fileData.exists) {\n        removedFiles.delete(relativeFilePath);\n      }\n\n      if (!fileData.exists) {\n        // No need to act on files that do not exist and were not tracked.\n        if (existingFileData) {\n          files.delete(relativeFilePath); // If watchman is not fresh, we will know what specific files were\n          // deleted since we last ran and can track only those files.\n\n          if (!isFresh) {\n            removedFiles.set(relativeFilePath, existingFileData);\n          }\n        }\n      } else if (!ignore(filePath)) {\n        const mtime =\n          typeof fileData.mtime_ms === 'number'\n            ? fileData.mtime_ms\n            : fileData.mtime_ms.toNumber();\n        const size = fileData.size;\n        let sha1hex = fileData['content.sha1hex'];\n\n        if (typeof sha1hex !== 'string' || sha1hex.length !== 40) {\n          sha1hex = undefined;\n        }\n\n        let nextData;\n\n        if (\n          existingFileData &&\n          existingFileData[_constants.default.MTIME] === mtime\n        ) {\n          nextData = existingFileData;\n        } else if (\n          existingFileData &&\n          sha1hex &&\n          existingFileData[_constants.default.SHA1] === sha1hex\n        ) {\n          nextData = [\n            existingFileData[0],\n            mtime,\n            existingFileData[2],\n            existingFileData[3],\n            existingFileData[4],\n            existingFileData[5]\n          ];\n        } else {\n          var _sha1hex;\n\n          // See ../constants.ts\n          nextData = [\n            '',\n            mtime,\n            size,\n            0,\n            '',\n            (_sha1hex = sha1hex) !== null && _sha1hex !== void 0\n              ? _sha1hex\n              : null\n          ];\n        }\n\n        files.set(relativeFilePath, nextData);\n        changedFiles.set(relativeFilePath, nextData);\n      }\n    }\n  }\n\n  data.files = files;\n  return {\n    changedFiles: isFresh ? undefined : changedFiles,\n    hasteMap: data,\n    removedFiles\n  };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}