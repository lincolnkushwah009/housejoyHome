{"ast":null,"code":"/*\n Copyright 2012-2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\nconst {\n  transformSync\n} = require('@babel/core');\n\nconst {\n  defaults\n} = require('@istanbuljs/schema');\n\nconst programVisitor = require('./visitor');\n\nconst readInitialCoverage = require('./read-coverage');\n/**\n * Instrumenter is the public API for the instrument library.\n * It is typically used for ES5 code. For ES6 code that you\n * are already running under `babel` use the coverage plugin\n * instead.\n * @param {Object} opts optional.\n * @param {string} [opts.coverageVariable=__coverage__] name of global coverage variable.\n * @param {boolean} [opts.reportLogic=false] report boolean value of logical expressions.\n * @param {boolean} [opts.preserveComments=false] preserve comments in output.\n * @param {boolean} [opts.compact=true] generate compact code.\n * @param {boolean} [opts.esModules=false] set to true to instrument ES6 modules.\n * @param {boolean} [opts.autoWrap=false] set to true to allow `return` statements outside of functions.\n * @param {boolean} [opts.produceSourceMap=false] set to true to produce a source map for the instrumented code.\n * @param {Array} [opts.ignoreClassMethods=[]] set to array of class method names to ignore for coverage.\n * @param {Function} [opts.sourceMapUrlCallback=null] a callback function that is called when a source map URL\n *     is found in the original code. This function is called with the source file name and the source map URL.\n * @param {boolean} [opts.debug=false] - turn debugging on.\n * @param {array} [opts.parserPlugins] - set babel parser plugins, see @istanbuljs/schema for defaults.\n */\n\n\nclass Instrumenter {\n  constructor() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.opts = { ...defaults.instrumenter,\n      ...opts\n    };\n    this.fileCoverage = null;\n    this.sourceMap = null;\n  }\n  /**\n   * instrument the supplied code and track coverage against the supplied\n   * filename. It throws if invalid code is passed to it. ES5 and ES6 syntax\n   * is supported. To instrument ES6 modules, make sure that you set the\n   * `esModules` property to `true` when creating the instrumenter.\n   *\n   * @param {string} code - the code to instrument\n   * @param {string} filename - the filename against which to track coverage.\n   * @param {object} [inputSourceMap] - the source map that maps the not instrumented code back to it's original form.\n   * Is assigned to the coverage object and therefore, is available in the json output and can be used to remap the\n   * coverage to the untranspiled source.\n   * @returns {string} the instrumented code.\n   */\n\n\n  instrumentSync(code, filename, inputSourceMap) {\n    if (typeof code !== 'string') {\n      throw new Error('Code must be a string');\n    }\n\n    filename = filename || String(new Date().getTime()) + '.js';\n    const {\n      opts\n    } = this;\n    let output = {};\n    const babelOpts = {\n      configFile: false,\n      babelrc: false,\n      ast: true,\n      filename: filename || String(new Date().getTime()) + '.js',\n      inputSourceMap,\n      sourceMaps: opts.produceSourceMap,\n      compact: opts.compact,\n      comments: opts.preserveComments,\n      parserOpts: {\n        allowReturnOutsideFunction: opts.autoWrap,\n        sourceType: opts.esModules ? 'module' : 'script',\n        plugins: opts.parserPlugins\n      },\n      plugins: [[_ref => {\n        let {\n          types\n        } = _ref;\n        const ee = programVisitor(types, filename, {\n          coverageVariable: opts.coverageVariable,\n          reportLogic: opts.reportLogic,\n          coverageGlobalScope: opts.coverageGlobalScope,\n          coverageGlobalScopeFunc: opts.coverageGlobalScopeFunc,\n          ignoreClassMethods: opts.ignoreClassMethods,\n          inputSourceMap\n        });\n        return {\n          visitor: {\n            Program: {\n              enter: ee.enter,\n\n              exit(path) {\n                output = ee.exit(path);\n              }\n\n            }\n          }\n        };\n      }]]\n    };\n    const codeMap = transformSync(code, babelOpts);\n\n    if (!output || !output.fileCoverage) {\n      const initialCoverage = readInitialCoverage(codeMap.ast) ||\n      /* istanbul ignore next: paranoid check */\n      {};\n      this.fileCoverage = initialCoverage.coverageData;\n      this.sourceMap = inputSourceMap;\n      return code;\n    }\n\n    this.fileCoverage = output.fileCoverage;\n    this.sourceMap = codeMap.map;\n    const cb = this.opts.sourceMapUrlCallback;\n\n    if (cb && output.sourceMappingURL) {\n      cb(filename, output.sourceMappingURL);\n    }\n\n    return codeMap.code;\n  }\n  /**\n   * callback-style instrument method that calls back with an error\n   * as opposed to throwing one. Note that in the current implementation,\n   * the callback will be called in the same process tick and is not asynchronous.\n   *\n   * @param {string} code - the code to instrument\n   * @param {string} filename - the filename against which to track coverage.\n   * @param {Function} callback - the callback\n   * @param {Object} inputSourceMap - the source map that maps the not instrumented code back to it's original form.\n   * Is assigned to the coverage object and therefore, is available in the json output and can be used to remap the\n   * coverage to the untranspiled source.\n   */\n\n\n  instrument(code, filename, callback, inputSourceMap) {\n    if (!callback && typeof filename === 'function') {\n      callback = filename;\n      filename = null;\n    }\n\n    try {\n      const out = this.instrumentSync(code, filename, inputSourceMap);\n      callback(null, out);\n    } catch (ex) {\n      callback(ex);\n    }\n  }\n  /**\n   * returns the file coverage object for the last file instrumented.\n   * @returns {Object} the file coverage object.\n   */\n\n\n  lastFileCoverage() {\n    return this.fileCoverage;\n  }\n  /**\n   * returns the source map produced for the last file instrumented.\n   * @returns {null|Object} the source map object.\n   */\n\n\n  lastSourceMap() {\n    return this.sourceMap;\n  }\n\n}\n\nmodule.exports = Instrumenter;","map":{"version":3,"names":["transformSync","require","defaults","programVisitor","readInitialCoverage","Instrumenter","constructor","opts","instrumenter","fileCoverage","sourceMap","instrumentSync","code","filename","inputSourceMap","Error","String","Date","getTime","output","babelOpts","configFile","babelrc","ast","sourceMaps","produceSourceMap","compact","comments","preserveComments","parserOpts","allowReturnOutsideFunction","autoWrap","sourceType","esModules","plugins","parserPlugins","types","ee","coverageVariable","reportLogic","coverageGlobalScope","coverageGlobalScopeFunc","ignoreClassMethods","visitor","Program","enter","exit","path","codeMap","initialCoverage","coverageData","map","cb","sourceMapUrlCallback","sourceMappingURL","instrument","callback","out","ex","lastFileCoverage","lastSourceMap","module","exports"],"sources":["/Users/lincolnkushwah/Desktop/All/React Projects/house_joy_new/node_modules/istanbul-lib-instrument/src/instrumenter.js"],"sourcesContent":["/*\n Copyright 2012-2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\nconst { transformSync } = require('@babel/core');\nconst { defaults } = require('@istanbuljs/schema');\nconst programVisitor = require('./visitor');\nconst readInitialCoverage = require('./read-coverage');\n\n/**\n * Instrumenter is the public API for the instrument library.\n * It is typically used for ES5 code. For ES6 code that you\n * are already running under `babel` use the coverage plugin\n * instead.\n * @param {Object} opts optional.\n * @param {string} [opts.coverageVariable=__coverage__] name of global coverage variable.\n * @param {boolean} [opts.reportLogic=false] report boolean value of logical expressions.\n * @param {boolean} [opts.preserveComments=false] preserve comments in output.\n * @param {boolean} [opts.compact=true] generate compact code.\n * @param {boolean} [opts.esModules=false] set to true to instrument ES6 modules.\n * @param {boolean} [opts.autoWrap=false] set to true to allow `return` statements outside of functions.\n * @param {boolean} [opts.produceSourceMap=false] set to true to produce a source map for the instrumented code.\n * @param {Array} [opts.ignoreClassMethods=[]] set to array of class method names to ignore for coverage.\n * @param {Function} [opts.sourceMapUrlCallback=null] a callback function that is called when a source map URL\n *     is found in the original code. This function is called with the source file name and the source map URL.\n * @param {boolean} [opts.debug=false] - turn debugging on.\n * @param {array} [opts.parserPlugins] - set babel parser plugins, see @istanbuljs/schema for defaults.\n */\nclass Instrumenter {\n    constructor(opts = {}) {\n        this.opts = {\n            ...defaults.instrumenter,\n            ...opts\n        };\n        this.fileCoverage = null;\n        this.sourceMap = null;\n    }\n    /**\n     * instrument the supplied code and track coverage against the supplied\n     * filename. It throws if invalid code is passed to it. ES5 and ES6 syntax\n     * is supported. To instrument ES6 modules, make sure that you set the\n     * `esModules` property to `true` when creating the instrumenter.\n     *\n     * @param {string} code - the code to instrument\n     * @param {string} filename - the filename against which to track coverage.\n     * @param {object} [inputSourceMap] - the source map that maps the not instrumented code back to it's original form.\n     * Is assigned to the coverage object and therefore, is available in the json output and can be used to remap the\n     * coverage to the untranspiled source.\n     * @returns {string} the instrumented code.\n     */\n    instrumentSync(code, filename, inputSourceMap) {\n        if (typeof code !== 'string') {\n            throw new Error('Code must be a string');\n        }\n        filename = filename || String(new Date().getTime()) + '.js';\n        const { opts } = this;\n        let output = {};\n        const babelOpts = {\n            configFile: false,\n            babelrc: false,\n            ast: true,\n            filename: filename || String(new Date().getTime()) + '.js',\n            inputSourceMap,\n            sourceMaps: opts.produceSourceMap,\n            compact: opts.compact,\n            comments: opts.preserveComments,\n            parserOpts: {\n                allowReturnOutsideFunction: opts.autoWrap,\n                sourceType: opts.esModules ? 'module' : 'script',\n                plugins: opts.parserPlugins\n            },\n            plugins: [\n                [\n                    ({ types }) => {\n                        const ee = programVisitor(types, filename, {\n                            coverageVariable: opts.coverageVariable,\n                            reportLogic: opts.reportLogic,\n                            coverageGlobalScope: opts.coverageGlobalScope,\n                            coverageGlobalScopeFunc:\n                                opts.coverageGlobalScopeFunc,\n                            ignoreClassMethods: opts.ignoreClassMethods,\n                            inputSourceMap\n                        });\n\n                        return {\n                            visitor: {\n                                Program: {\n                                    enter: ee.enter,\n                                    exit(path) {\n                                        output = ee.exit(path);\n                                    }\n                                }\n                            }\n                        };\n                    }\n                ]\n            ]\n        };\n\n        const codeMap = transformSync(code, babelOpts);\n\n        if (!output || !output.fileCoverage) {\n            const initialCoverage =\n                readInitialCoverage(codeMap.ast) ||\n                /* istanbul ignore next: paranoid check */ {};\n            this.fileCoverage = initialCoverage.coverageData;\n            this.sourceMap = inputSourceMap;\n            return code;\n        }\n\n        this.fileCoverage = output.fileCoverage;\n        this.sourceMap = codeMap.map;\n        const cb = this.opts.sourceMapUrlCallback;\n        if (cb && output.sourceMappingURL) {\n            cb(filename, output.sourceMappingURL);\n        }\n\n        return codeMap.code;\n    }\n    /**\n     * callback-style instrument method that calls back with an error\n     * as opposed to throwing one. Note that in the current implementation,\n     * the callback will be called in the same process tick and is not asynchronous.\n     *\n     * @param {string} code - the code to instrument\n     * @param {string} filename - the filename against which to track coverage.\n     * @param {Function} callback - the callback\n     * @param {Object} inputSourceMap - the source map that maps the not instrumented code back to it's original form.\n     * Is assigned to the coverage object and therefore, is available in the json output and can be used to remap the\n     * coverage to the untranspiled source.\n     */\n    instrument(code, filename, callback, inputSourceMap) {\n        if (!callback && typeof filename === 'function') {\n            callback = filename;\n            filename = null;\n        }\n        try {\n            const out = this.instrumentSync(code, filename, inputSourceMap);\n            callback(null, out);\n        } catch (ex) {\n            callback(ex);\n        }\n    }\n    /**\n     * returns the file coverage object for the last file instrumented.\n     * @returns {Object} the file coverage object.\n     */\n    lastFileCoverage() {\n        return this.fileCoverage;\n    }\n    /**\n     * returns the source map produced for the last file instrumented.\n     * @returns {null|Object} the source map object.\n     */\n    lastSourceMap() {\n        return this.sourceMap;\n    }\n}\n\nmodule.exports = Instrumenter;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}