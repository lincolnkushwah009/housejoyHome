{"ast":null,"code":"module.exports = Walker;\n\nvar path = require('path'),\n    fs = require('fs'),\n    util = require('util'),\n    EventEmitter = require('events').EventEmitter,\n    makeError = require('makeerror');\n/**\n * To walk a directory. It's complicated (but it's async, so it must be fast).\n *\n * @param root {String} the directory to start with\n */\n\n\nfunction Walker(root) {\n  if (!(this instanceof Walker)) return new Walker(root);\n  EventEmitter.call(this);\n  this._pending = 0;\n\n  this._filterDir = function () {\n    return true;\n  };\n\n  this.go(root);\n}\n\nutil.inherits(Walker, EventEmitter);\n/**\n * Errors of this type are thrown when the type of a file could not be\n * determined.\n */\n\nvar UnknownFileTypeError = Walker.UnknownFileTypeError = makeError('UnknownFileTypeError', 'The type of this file could not be determined.');\n/**\n * Setup a function to filter out directory entries.\n *\n * @param fn {Function} a function that will be given a directory name, which\n * if returns true will include the directory and it's children\n */\n\nWalker.prototype.filterDir = function (fn) {\n  this._filterDir = fn;\n  return this;\n};\n/**\n * Process a file or directory.\n */\n\n\nWalker.prototype.go = function (entry) {\n  var that = this;\n  this._pending++;\n  fs.lstat(entry, function (er, stat) {\n    if (er) {\n      that.emit('error', er, entry, stat);\n      that.doneOne();\n      return;\n    }\n\n    if (stat.isDirectory()) {\n      if (!that._filterDir(entry, stat)) {\n        that.doneOne();\n      } else {\n        fs.readdir(entry, function (er, files) {\n          if (er) {\n            that.emit('error', er, entry, stat);\n            that.doneOne();\n            return;\n          }\n\n          that.emit('entry', entry, stat);\n          that.emit('dir', entry, stat);\n          files.forEach(function (part) {\n            that.go(path.join(entry, part));\n          });\n          that.doneOne();\n        });\n      }\n    } else if (stat.isSymbolicLink()) {\n      that.emit('entry', entry, stat);\n      that.emit('symlink', entry, stat);\n      that.doneOne();\n    } else if (stat.isBlockDevice()) {\n      that.emit('entry', entry, stat);\n      that.emit('blockDevice', entry, stat);\n      that.doneOne();\n    } else if (stat.isCharacterDevice()) {\n      that.emit('entry', entry, stat);\n      that.emit('characterDevice', entry, stat);\n      that.doneOne();\n    } else if (stat.isFIFO()) {\n      that.emit('entry', entry, stat);\n      that.emit('fifo', entry, stat);\n      that.doneOne();\n    } else if (stat.isSocket()) {\n      that.emit('entry', entry, stat);\n      that.emit('socket', entry, stat);\n      that.doneOne();\n    } else if (stat.isFile()) {\n      that.emit('entry', entry, stat);\n      that.emit('file', entry, stat);\n      that.doneOne();\n    } else {\n      that.emit('error', UnknownFileTypeError(), entry, stat);\n      that.doneOne();\n    }\n  });\n  return this;\n};\n\nWalker.prototype.doneOne = function () {\n  if (--this._pending === 0) this.emit('end');\n  return this;\n};","map":{"version":3,"names":["module","exports","Walker","path","require","fs","util","EventEmitter","makeError","root","call","_pending","_filterDir","go","inherits","UnknownFileTypeError","prototype","filterDir","fn","entry","that","lstat","er","stat","emit","doneOne","isDirectory","readdir","files","forEach","part","join","isSymbolicLink","isBlockDevice","isCharacterDevice","isFIFO","isSocket","isFile"],"sources":["/Users/lincolnkushwah/Desktop/All/React Projects/house_joy_new/node_modules/walker/lib/walker.js"],"sourcesContent":["module.exports = Walker\n\nvar path = require('path')\n  , fs = require('fs')\n  , util = require('util')\n  , EventEmitter = require('events').EventEmitter\n  , makeError = require('makeerror')\n\n/**\n * To walk a directory. It's complicated (but it's async, so it must be fast).\n *\n * @param root {String} the directory to start with\n */\nfunction Walker(root) {\n  if (!(this instanceof Walker)) return new Walker(root)\n  EventEmitter.call(this)\n  this._pending = 0\n  this._filterDir = function() { return true }\n  this.go(root)\n}\nutil.inherits(Walker, EventEmitter)\n\n/**\n * Errors of this type are thrown when the type of a file could not be\n * determined.\n */\nvar UnknownFileTypeError = Walker.UnknownFileTypeError = makeError(\n  'UnknownFileTypeError',\n  'The type of this file could not be determined.'\n)\n\n/**\n * Setup a function to filter out directory entries.\n *\n * @param fn {Function} a function that will be given a directory name, which\n * if returns true will include the directory and it's children\n */\nWalker.prototype.filterDir = function(fn) {\n  this._filterDir = fn\n  return this\n}\n\n/**\n * Process a file or directory.\n */\nWalker.prototype.go = function(entry) {\n  var that = this\n  this._pending++\n\n  fs.lstat(entry, function(er, stat) {\n    if (er) {\n      that.emit('error', er, entry, stat)\n      that.doneOne()\n      return\n    }\n\n    if (stat.isDirectory()) {\n      if (!that._filterDir(entry, stat)) {\n        that.doneOne()\n      } else {\n        fs.readdir(entry, function(er, files) {\n          if (er) {\n            that.emit('error', er, entry, stat)\n            that.doneOne()\n            return\n          }\n\n          that.emit('entry', entry, stat)\n          that.emit('dir', entry, stat)\n          files.forEach(function(part) {\n            that.go(path.join(entry, part))\n          })\n          that.doneOne()\n        })\n      }\n    } else if (stat.isSymbolicLink()) {\n      that.emit('entry', entry, stat)\n      that.emit('symlink', entry, stat)\n      that.doneOne()\n    } else if (stat.isBlockDevice()) {\n      that.emit('entry', entry, stat)\n      that.emit('blockDevice', entry, stat)\n      that.doneOne()\n    } else if (stat.isCharacterDevice()) {\n      that.emit('entry', entry, stat)\n      that.emit('characterDevice', entry, stat)\n      that.doneOne()\n    } else if (stat.isFIFO()) {\n      that.emit('entry', entry, stat)\n      that.emit('fifo', entry, stat)\n      that.doneOne()\n    } else if (stat.isSocket()) {\n      that.emit('entry', entry, stat)\n      that.emit('socket', entry, stat)\n      that.doneOne()\n    } else if (stat.isFile()) {\n      that.emit('entry', entry, stat)\n      that.emit('file', entry, stat)\n      that.doneOne()\n    } else {\n      that.emit('error', UnknownFileTypeError(), entry, stat)\n      that.doneOne()\n    }\n  })\n  return this\n}\n\nWalker.prototype.doneOne = function() {\n  if (--this._pending === 0) this.emit('end')\n  return this\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}