{"ast":null,"code":"const {\n  createHash\n} = require('crypto');\n\nconst {\n  template\n} = require('@babel/core');\n\nconst {\n  defaults\n} = require('@istanbuljs/schema');\n\nconst {\n  SourceCoverage\n} = require('./source-coverage');\n\nconst {\n  SHA,\n  MAGIC_KEY,\n  MAGIC_VALUE\n} = require('./constants'); // pattern for istanbul to ignore a section\n\n\nconst COMMENT_RE = /^\\s*istanbul\\s+ignore\\s+(if|else|next)(?=\\W|$)/; // pattern for istanbul to ignore the whole file\n\nconst COMMENT_FILE_RE = /^\\s*istanbul\\s+ignore\\s+(file)(?=\\W|$)/; // source map URL pattern\n\nconst SOURCE_MAP_RE = /[#@]\\s*sourceMappingURL=(.*)\\s*$/m; // generate a variable name from hashing the supplied file path\n\nfunction genVar(filename) {\n  const hash = createHash(SHA);\n  hash.update(filename);\n  return 'cov_' + parseInt(hash.digest('hex').substr(0, 12), 16).toString(36);\n} // VisitState holds the state of the visitor, provides helper functions\n// and is the `this` for the individual coverage visitors.\n\n\nclass VisitState {\n  constructor(types, sourceFilePath, inputSourceMap) {\n    let ignoreClassMethods = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n    let reportLogic = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    this.varName = genVar(sourceFilePath);\n    this.attrs = {};\n    this.nextIgnore = null;\n    this.cov = new SourceCoverage(sourceFilePath);\n\n    if (typeof inputSourceMap !== 'undefined') {\n      this.cov.inputSourceMap(inputSourceMap);\n    }\n\n    this.ignoreClassMethods = ignoreClassMethods;\n    this.types = types;\n    this.sourceMappingURL = null;\n    this.reportLogic = reportLogic;\n  } // should we ignore the node? Yes, if specifically ignoring\n  // or if the node is generated.\n\n\n  shouldIgnore(path) {\n    return this.nextIgnore || !path.node.loc;\n  } // extract the ignore comment hint (next|if|else) or null\n\n\n  hintFor(node) {\n    let hint = null;\n\n    if (node.leadingComments) {\n      node.leadingComments.forEach(c => {\n        const v = (c.value ||\n        /* istanbul ignore next: paranoid check */\n        '').trim();\n        const groups = v.match(COMMENT_RE);\n\n        if (groups) {\n          hint = groups[1];\n        }\n      });\n    }\n\n    return hint;\n  } // extract a source map URL from comments and keep track of it\n\n\n  maybeAssignSourceMapURL(node) {\n    const extractURL = comments => {\n      if (!comments) {\n        return;\n      }\n\n      comments.forEach(c => {\n        const v = (c.value ||\n        /* istanbul ignore next: paranoid check */\n        '').trim();\n        const groups = v.match(SOURCE_MAP_RE);\n\n        if (groups) {\n          this.sourceMappingURL = groups[1];\n        }\n      });\n    };\n\n    extractURL(node.leadingComments);\n    extractURL(node.trailingComments);\n  } // for these expressions the statement counter needs to be hoisted, so\n  // function name inference can be preserved\n\n\n  counterNeedsHoisting(path) {\n    return path.isFunctionExpression() || path.isArrowFunctionExpression() || path.isClassExpression();\n  } // all the generic stuff that needs to be done on enter for every node\n\n\n  onEnter(path) {\n    const n = path.node;\n    this.maybeAssignSourceMapURL(n); // if already ignoring, nothing more to do\n\n    if (this.nextIgnore !== null) {\n      return;\n    } // check hint to see if ignore should be turned on\n\n\n    const hint = this.hintFor(n);\n\n    if (hint === 'next') {\n      this.nextIgnore = n;\n      return;\n    } // else check custom node attribute set by a prior visitor\n\n\n    if (this.getAttr(path.node, 'skip-all') !== null) {\n      this.nextIgnore = n;\n    } // else check for ignored class methods\n\n\n    if (path.isFunctionExpression() && this.ignoreClassMethods.some(name => path.node.id && name === path.node.id.name)) {\n      this.nextIgnore = n;\n      return;\n    }\n\n    if (path.isClassMethod() && this.ignoreClassMethods.some(name => name === path.node.key.name)) {\n      this.nextIgnore = n;\n      return;\n    }\n  } // all the generic stuff on exit of a node,\n  // including reseting ignores and custom node attrs\n\n\n  onExit(path) {\n    // restore ignore status, if needed\n    if (path.node === this.nextIgnore) {\n      this.nextIgnore = null;\n    } // nuke all attributes for the node\n\n\n    delete path.node.__cov__;\n  } // set a node attribute for the supplied node\n\n\n  setAttr(node, name, value) {\n    node.__cov__ = node.__cov__ || {};\n    node.__cov__[name] = value;\n  } // retrieve a node attribute for the supplied node or null\n\n\n  getAttr(node, name) {\n    const c = node.__cov__;\n\n    if (!c) {\n      return null;\n    }\n\n    return c[name];\n  } //\n\n\n  increase(type, id, index) {\n    const T = this.types;\n    const wrap = index !== null ? // If `index` present, turn `x` into `x[index]`.\n    x => T.memberExpression(x, T.numericLiteral(index), true) : x => x;\n    return T.updateExpression('++', wrap(T.memberExpression(T.memberExpression(T.callExpression(T.identifier(this.varName), []), T.identifier(type)), T.numericLiteral(id), true)));\n  } // Reads the logic expression conditions and conditionally increments truthy counter.\n\n\n  increaseTrue(type, id, index, node) {\n    const T = this.types;\n    const tempName = `${this.varName}_temp`;\n    return T.sequenceExpression([T.assignmentExpression('=', T.memberExpression(T.callExpression(T.identifier(this.varName), []), T.identifier(tempName)), node // Only evaluates once.\n    ), T.parenthesizedExpression(T.conditionalExpression(this.validateTrueNonTrivial(T, tempName), this.increase(type, id, index), T.nullLiteral())), T.memberExpression(T.callExpression(T.identifier(this.varName), []), T.identifier(tempName))]);\n  }\n\n  validateTrueNonTrivial(T, tempName) {\n    return T.logicalExpression('&&', T.memberExpression(T.callExpression(T.identifier(this.varName), []), T.identifier(tempName)), T.logicalExpression('&&', T.parenthesizedExpression(T.logicalExpression('||', T.unaryExpression('!', T.callExpression(T.memberExpression(T.identifier('Array'), T.identifier('isArray')), [T.memberExpression(T.callExpression(T.identifier(this.varName), []), T.identifier(tempName))])), T.memberExpression(T.memberExpression(T.callExpression(T.identifier(this.varName), []), T.identifier(tempName)), T.identifier('length')))), T.parenthesizedExpression(T.logicalExpression('||', T.binaryExpression('!==', T.callExpression(T.memberExpression(T.identifier('Object'), T.identifier('getPrototypeOf')), [T.memberExpression(T.callExpression(T.identifier(this.varName), []), T.identifier(tempName))]), T.memberExpression(T.identifier('Object'), T.identifier('prototype'))), T.memberExpression(T.callExpression(T.memberExpression(T.identifier('Object'), T.identifier('values')), [T.memberExpression(T.callExpression(T.identifier(this.varName), []), T.identifier(tempName))]), T.identifier('length'))))));\n  }\n\n  insertCounter(path, increment) {\n    const T = this.types;\n\n    if (path.isBlockStatement()) {\n      path.node.body.unshift(T.expressionStatement(increment));\n    } else if (path.isStatement()) {\n      path.insertBefore(T.expressionStatement(increment));\n    } else if (this.counterNeedsHoisting(path) && T.isVariableDeclarator(path.parentPath)) {\n      // make an attempt to hoist the statement counter, so that\n      // function names are maintained.\n      const parent = path.parentPath.parentPath;\n\n      if (parent && T.isExportNamedDeclaration(parent.parentPath)) {\n        parent.parentPath.insertBefore(T.expressionStatement(increment));\n      } else if (parent && (T.isProgram(parent.parentPath) || T.isBlockStatement(parent.parentPath))) {\n        parent.insertBefore(T.expressionStatement(increment));\n      } else {\n        path.replaceWith(T.sequenceExpression([increment, path.node]));\n      }\n    }\n    /* istanbul ignore else: not expected */\n    else if (path.isExpression()) {\n      path.replaceWith(T.sequenceExpression([increment, path.node]));\n    } else {\n      console.error('Unable to insert counter for node type:', path.node.type);\n    }\n  }\n\n  insertStatementCounter(path) {\n    /* istanbul ignore if: paranoid check */\n    if (!(path.node && path.node.loc)) {\n      return;\n    }\n\n    const index = this.cov.newStatement(path.node.loc);\n    const increment = this.increase('s', index, null);\n    this.insertCounter(path, increment);\n  }\n\n  insertFunctionCounter(path) {\n    const T = this.types;\n    /* istanbul ignore if: paranoid check */\n\n    if (!(path.node && path.node.loc)) {\n      return;\n    }\n\n    const n = path.node;\n    let dloc = null; // get location for declaration\n\n    switch (n.type) {\n      case 'FunctionDeclaration':\n      case 'FunctionExpression':\n        /* istanbul ignore else: paranoid check */\n        if (n.id) {\n          dloc = n.id.loc;\n        }\n\n        break;\n    }\n\n    if (!dloc) {\n      dloc = {\n        start: n.loc.start,\n        end: {\n          line: n.loc.start.line,\n          column: n.loc.start.column + 1\n        }\n      };\n    }\n\n    const name = path.node.id ? path.node.id.name : path.node.name;\n    const index = this.cov.newFunction(name, dloc, path.node.body.loc);\n    const increment = this.increase('f', index, null);\n    const body = path.get('body');\n    /* istanbul ignore else: not expected */\n\n    if (body.isBlockStatement()) {\n      body.node.body.unshift(T.expressionStatement(increment));\n    } else {\n      console.error('Unable to process function body node type:', path.node.type);\n    }\n  }\n\n  getBranchIncrement(branchName, loc) {\n    const index = this.cov.addBranchPath(branchName, loc);\n    return this.increase('b', branchName, index);\n  }\n\n  getBranchLogicIncrement(path, branchName, loc) {\n    const index = this.cov.addBranchPath(branchName, loc);\n    return [this.increase('b', branchName, index), this.increaseTrue('bT', branchName, index, path.node)];\n  }\n\n  insertBranchCounter(path, branchName, loc) {\n    const increment = this.getBranchIncrement(branchName, loc || path.node.loc);\n    this.insertCounter(path, increment);\n  }\n\n  findLeaves(node, accumulator, parent, property) {\n    if (!node) {\n      return;\n    }\n\n    if (node.type === 'LogicalExpression') {\n      const hint = this.hintFor(node);\n\n      if (hint !== 'next') {\n        this.findLeaves(node.left, accumulator, node, 'left');\n        this.findLeaves(node.right, accumulator, node, 'right');\n      }\n    } else {\n      accumulator.push({\n        node,\n        parent,\n        property\n      });\n    }\n  }\n\n} // generic function that takes a set of visitor methods and\n// returns a visitor object with `enter` and `exit` properties,\n// such that:\n//\n// * standard entry processing is done\n// * the supplied visitors are called only when ignore is not in effect\n//   This relieves them from worrying about ignore states and generated nodes.\n// * standard exit processing is done\n//\n\n\nfunction entries() {\n  for (var _len = arguments.length, enter = new Array(_len), _key = 0; _key < _len; _key++) {\n    enter[_key] = arguments[_key];\n  }\n\n  // the enter function\n  const wrappedEntry = function (path, node) {\n    this.onEnter(path);\n\n    if (this.shouldIgnore(path)) {\n      return;\n    }\n\n    enter.forEach(e => {\n      e.call(this, path, node);\n    });\n  };\n\n  const exit = function (path, node) {\n    this.onExit(path, node);\n  };\n\n  return {\n    enter: wrappedEntry,\n    exit\n  };\n}\n\nfunction coverStatement(path) {\n  this.insertStatementCounter(path);\n}\n/* istanbul ignore next: no node.js support */\n\n\nfunction coverAssignmentPattern(path) {\n  const n = path.node;\n  const b = this.cov.newBranch('default-arg', n.loc);\n  this.insertBranchCounter(path.get('right'), b);\n}\n\nfunction coverFunction(path) {\n  this.insertFunctionCounter(path);\n}\n\nfunction coverVariableDeclarator(path) {\n  this.insertStatementCounter(path.get('init'));\n}\n\nfunction coverClassPropDeclarator(path) {\n  this.insertStatementCounter(path.get('value'));\n}\n\nfunction makeBlock(path) {\n  const T = this.types;\n\n  if (!path.node) {\n    path.replaceWith(T.blockStatement([]));\n  }\n\n  if (!path.isBlockStatement()) {\n    path.replaceWith(T.blockStatement([path.node]));\n    path.node.loc = path.node.body[0].loc;\n    path.node.body[0].leadingComments = path.node.leadingComments;\n    path.node.leadingComments = undefined;\n  }\n}\n\nfunction blockProp(prop) {\n  return function (path) {\n    makeBlock.call(this, path.get(prop));\n  };\n}\n\nfunction makeParenthesizedExpressionForNonIdentifier(path) {\n  const T = this.types;\n\n  if (path.node && !path.isIdentifier()) {\n    path.replaceWith(T.parenthesizedExpression(path.node));\n  }\n}\n\nfunction parenthesizedExpressionProp(prop) {\n  return function (path) {\n    makeParenthesizedExpressionForNonIdentifier.call(this, path.get(prop));\n  };\n}\n\nfunction convertArrowExpression(path) {\n  const n = path.node;\n  const T = this.types;\n\n  if (!T.isBlockStatement(n.body)) {\n    const bloc = n.body.loc;\n\n    if (n.expression === true) {\n      n.expression = false;\n    }\n\n    n.body = T.blockStatement([T.returnStatement(n.body)]); // restore body location\n\n    n.body.loc = bloc; // set up the location for the return statement so it gets\n    // instrumented\n\n    n.body.body[0].loc = bloc;\n  }\n}\n\nfunction coverIfBranches(path) {\n  const n = path.node;\n  const hint = this.hintFor(n);\n  const ignoreIf = hint === 'if';\n  const ignoreElse = hint === 'else';\n  const branch = this.cov.newBranch('if', n.loc);\n\n  if (ignoreIf) {\n    this.setAttr(n.consequent, 'skip-all', true);\n  } else {\n    this.insertBranchCounter(path.get('consequent'), branch, n.loc);\n  }\n\n  if (ignoreElse) {\n    this.setAttr(n.alternate, 'skip-all', true);\n  } else {\n    this.insertBranchCounter(path.get('alternate'), branch);\n  }\n}\n\nfunction createSwitchBranch(path) {\n  const b = this.cov.newBranch('switch', path.node.loc);\n  this.setAttr(path.node, 'branchName', b);\n}\n\nfunction coverSwitchCase(path) {\n  const T = this.types;\n  const b = this.getAttr(path.parentPath.node, 'branchName');\n  /* istanbul ignore if: paranoid check */\n\n  if (b === null) {\n    throw new Error('Unable to get switch branch name');\n  }\n\n  const increment = this.getBranchIncrement(b, path.node.loc);\n  path.node.consequent.unshift(T.expressionStatement(increment));\n}\n\nfunction coverTernary(path) {\n  const n = path.node;\n  const branch = this.cov.newBranch('cond-expr', path.node.loc);\n  const cHint = this.hintFor(n.consequent);\n  const aHint = this.hintFor(n.alternate);\n\n  if (cHint !== 'next') {\n    this.insertBranchCounter(path.get('consequent'), branch);\n  }\n\n  if (aHint !== 'next') {\n    this.insertBranchCounter(path.get('alternate'), branch);\n  }\n}\n\nfunction coverLogicalExpression(path) {\n  const T = this.types;\n\n  if (path.parentPath.node.type === 'LogicalExpression') {\n    return; // already processed\n  }\n\n  const leaves = [];\n  this.findLeaves(path.node, leaves);\n  const b = this.cov.newBranch('binary-expr', path.node.loc, this.reportLogic);\n\n  for (let i = 0; i < leaves.length; i += 1) {\n    const leaf = leaves[i];\n    const hint = this.hintFor(leaf.node);\n\n    if (hint === 'next') {\n      continue;\n    }\n\n    if (this.reportLogic) {\n      const increment = this.getBranchLogicIncrement(leaf, b, leaf.node.loc);\n\n      if (!increment[0]) {\n        continue;\n      }\n\n      leaf.parent[leaf.property] = T.sequenceExpression([increment[0], increment[1]]);\n      continue;\n    }\n\n    const increment = this.getBranchIncrement(b, leaf.node.loc);\n\n    if (!increment) {\n      continue;\n    }\n\n    leaf.parent[leaf.property] = T.sequenceExpression([increment, leaf.node]);\n  }\n}\n\nconst codeVisitor = {\n  ArrowFunctionExpression: entries(convertArrowExpression, coverFunction),\n  AssignmentPattern: entries(coverAssignmentPattern),\n  BlockStatement: entries(),\n  // ignore processing only\n  ExportDefaultDeclaration: entries(),\n  // ignore processing only\n  ExportNamedDeclaration: entries(),\n  // ignore processing only\n  ClassMethod: entries(coverFunction),\n  ClassDeclaration: entries(parenthesizedExpressionProp('superClass')),\n  ClassProperty: entries(coverClassPropDeclarator),\n  ClassPrivateProperty: entries(coverClassPropDeclarator),\n  ObjectMethod: entries(coverFunction),\n  ExpressionStatement: entries(coverStatement),\n  BreakStatement: entries(coverStatement),\n  ContinueStatement: entries(coverStatement),\n  DebuggerStatement: entries(coverStatement),\n  ReturnStatement: entries(coverStatement),\n  ThrowStatement: entries(coverStatement),\n  TryStatement: entries(coverStatement),\n  VariableDeclaration: entries(),\n  // ignore processing only\n  VariableDeclarator: entries(coverVariableDeclarator),\n  IfStatement: entries(blockProp('consequent'), blockProp('alternate'), coverStatement, coverIfBranches),\n  ForStatement: entries(blockProp('body'), coverStatement),\n  ForInStatement: entries(blockProp('body'), coverStatement),\n  ForOfStatement: entries(blockProp('body'), coverStatement),\n  WhileStatement: entries(blockProp('body'), coverStatement),\n  DoWhileStatement: entries(blockProp('body'), coverStatement),\n  SwitchStatement: entries(createSwitchBranch, coverStatement),\n  SwitchCase: entries(coverSwitchCase),\n  WithStatement: entries(blockProp('body'), coverStatement),\n  FunctionDeclaration: entries(coverFunction),\n  FunctionExpression: entries(coverFunction),\n  LabeledStatement: entries(coverStatement),\n  ConditionalExpression: entries(coverTernary),\n  LogicalExpression: entries(coverLogicalExpression)\n};\nconst globalTemplateAlteredFunction = template(`\n        var Function = (function(){}).constructor;\n        var global = (new Function(GLOBAL_COVERAGE_SCOPE))();\n`);\nconst globalTemplateFunction = template(`\n        var global = (new Function(GLOBAL_COVERAGE_SCOPE))();\n`);\nconst globalTemplateVariable = template(`\n        var global = GLOBAL_COVERAGE_SCOPE;\n`); // the template to insert at the top of the program.\n\nconst coverageTemplate = template(`\n    function COVERAGE_FUNCTION () {\n        var path = PATH;\n        var hash = HASH;\n        GLOBAL_COVERAGE_TEMPLATE\n        var gcv = GLOBAL_COVERAGE_VAR;\n        var coverageData = INITIAL;\n        var coverage = global[gcv] || (global[gcv] = {});\n        if (!coverage[path] || coverage[path].hash !== hash) {\n            coverage[path] = coverageData;\n        }\n\n        var actualCoverage = coverage[path];\n        {\n            // @ts-ignore\n            COVERAGE_FUNCTION = function () {\n                return actualCoverage;\n            }\n        }\n\n        return actualCoverage;\n    }\n`, {\n  preserveComments: true\n}); // the rewire plugin (and potentially other babel middleware)\n// may cause files to be instrumented twice, see:\n// https://github.com/istanbuljs/babel-plugin-istanbul/issues/94\n// we should only instrument code for coverage the first time\n// it's run through istanbul-lib-instrument.\n\nfunction alreadyInstrumented(path, visitState) {\n  return path.scope.hasBinding(visitState.varName);\n}\n\nfunction shouldIgnoreFile(programNode) {\n  return programNode.parent && programNode.parent.comments.some(c => COMMENT_FILE_RE.test(c.value));\n}\n/**\n * programVisitor is a `babel` adaptor for instrumentation.\n * It returns an object with two methods `enter` and `exit`.\n * These should be assigned to or called from `Program` entry and exit functions\n * in a babel visitor.\n * These functions do not make assumptions about the state set by Babel and thus\n * can be used in a context other than a Babel plugin.\n *\n * The exit function returns an object that currently has the following keys:\n *\n * `fileCoverage` - the file coverage object created for the source file.\n * `sourceMappingURL` - any source mapping URL found when processing the file.\n *\n * @param {Object} types - an instance of babel-types.\n * @param {string} sourceFilePath - the path to source file.\n * @param {Object} opts - additional options.\n * @param {string} [opts.coverageVariable=__coverage__] the global coverage variable name.\n * @param {boolean} [opts.reportLogic=false] report boolean value of logical expressions.\n * @param {string} [opts.coverageGlobalScope=this] the global coverage variable scope.\n * @param {boolean} [opts.coverageGlobalScopeFunc=true] use an evaluated function to find coverageGlobalScope.\n * @param {Array} [opts.ignoreClassMethods=[]] names of methods to ignore by default on classes.\n * @param {object} [opts.inputSourceMap=undefined] the input source map, that maps the uninstrumented code back to the\n * original code.\n */\n\n\nfunction programVisitor(types) {\n  let sourceFilePath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'unknown.js';\n  let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const T = types;\n  opts = { ...defaults.instrumentVisitor,\n    ...opts\n  };\n  const visitState = new VisitState(types, sourceFilePath, opts.inputSourceMap, opts.ignoreClassMethods, opts.reportLogic);\n  return {\n    enter(path) {\n      if (shouldIgnoreFile(path.find(p => p.isProgram()))) {\n        return;\n      }\n\n      if (alreadyInstrumented(path, visitState)) {\n        return;\n      }\n\n      path.traverse(codeVisitor, visitState);\n    },\n\n    exit(path) {\n      if (alreadyInstrumented(path, visitState)) {\n        return;\n      }\n\n      visitState.cov.freeze();\n      const coverageData = visitState.cov.toJSON();\n\n      if (shouldIgnoreFile(path.find(p => p.isProgram()))) {\n        return {\n          fileCoverage: coverageData,\n          sourceMappingURL: visitState.sourceMappingURL\n        };\n      }\n\n      coverageData[MAGIC_KEY] = MAGIC_VALUE;\n      const hash = createHash(SHA).update(JSON.stringify(coverageData)).digest('hex');\n      coverageData.hash = hash;\n      const coverageNode = T.valueToNode(coverageData);\n      delete coverageData[MAGIC_KEY];\n      delete coverageData.hash;\n      let gvTemplate;\n\n      if (opts.coverageGlobalScopeFunc) {\n        if (path.scope.getBinding('Function')) {\n          gvTemplate = globalTemplateAlteredFunction({\n            GLOBAL_COVERAGE_SCOPE: T.stringLiteral('return ' + opts.coverageGlobalScope)\n          });\n        } else {\n          gvTemplate = globalTemplateFunction({\n            GLOBAL_COVERAGE_SCOPE: T.stringLiteral('return ' + opts.coverageGlobalScope)\n          });\n        }\n      } else {\n        gvTemplate = globalTemplateVariable({\n          GLOBAL_COVERAGE_SCOPE: opts.coverageGlobalScope\n        });\n      }\n\n      const cv = coverageTemplate({\n        GLOBAL_COVERAGE_VAR: T.stringLiteral(opts.coverageVariable),\n        GLOBAL_COVERAGE_TEMPLATE: gvTemplate,\n        COVERAGE_FUNCTION: T.identifier(visitState.varName),\n        PATH: T.stringLiteral(sourceFilePath),\n        INITIAL: coverageNode,\n        HASH: T.stringLiteral(hash)\n      }); // explicitly call this.varName to ensure coverage is always initialized\n\n      path.node.body.unshift(T.expressionStatement(T.callExpression(T.identifier(visitState.varName), [])));\n      path.node.body.unshift(cv);\n      return {\n        fileCoverage: coverageData,\n        sourceMappingURL: visitState.sourceMappingURL\n      };\n    }\n\n  };\n}\n\nmodule.exports = programVisitor;","map":{"version":3,"names":["createHash","require","template","defaults","SourceCoverage","SHA","MAGIC_KEY","MAGIC_VALUE","COMMENT_RE","COMMENT_FILE_RE","SOURCE_MAP_RE","genVar","filename","hash","update","parseInt","digest","substr","toString","VisitState","constructor","types","sourceFilePath","inputSourceMap","ignoreClassMethods","reportLogic","varName","attrs","nextIgnore","cov","sourceMappingURL","shouldIgnore","path","node","loc","hintFor","hint","leadingComments","forEach","c","v","value","trim","groups","match","maybeAssignSourceMapURL","extractURL","comments","trailingComments","counterNeedsHoisting","isFunctionExpression","isArrowFunctionExpression","isClassExpression","onEnter","n","getAttr","some","name","id","isClassMethod","key","onExit","__cov__","setAttr","increase","type","index","T","wrap","x","memberExpression","numericLiteral","updateExpression","callExpression","identifier","increaseTrue","tempName","sequenceExpression","assignmentExpression","parenthesizedExpression","conditionalExpression","validateTrueNonTrivial","nullLiteral","logicalExpression","unaryExpression","binaryExpression","insertCounter","increment","isBlockStatement","body","unshift","expressionStatement","isStatement","insertBefore","isVariableDeclarator","parentPath","parent","isExportNamedDeclaration","isProgram","replaceWith","isExpression","console","error","insertStatementCounter","newStatement","insertFunctionCounter","dloc","start","end","line","column","newFunction","get","getBranchIncrement","branchName","addBranchPath","getBranchLogicIncrement","insertBranchCounter","findLeaves","accumulator","property","left","right","push","entries","enter","wrappedEntry","e","call","exit","coverStatement","coverAssignmentPattern","b","newBranch","coverFunction","coverVariableDeclarator","coverClassPropDeclarator","makeBlock","blockStatement","undefined","blockProp","prop","makeParenthesizedExpressionForNonIdentifier","isIdentifier","parenthesizedExpressionProp","convertArrowExpression","bloc","expression","returnStatement","coverIfBranches","ignoreIf","ignoreElse","branch","consequent","alternate","createSwitchBranch","coverSwitchCase","Error","coverTernary","cHint","aHint","coverLogicalExpression","leaves","i","length","leaf","codeVisitor","ArrowFunctionExpression","AssignmentPattern","BlockStatement","ExportDefaultDeclaration","ExportNamedDeclaration","ClassMethod","ClassDeclaration","ClassProperty","ClassPrivateProperty","ObjectMethod","ExpressionStatement","BreakStatement","ContinueStatement","DebuggerStatement","ReturnStatement","ThrowStatement","TryStatement","VariableDeclaration","VariableDeclarator","IfStatement","ForStatement","ForInStatement","ForOfStatement","WhileStatement","DoWhileStatement","SwitchStatement","SwitchCase","WithStatement","FunctionDeclaration","FunctionExpression","LabeledStatement","ConditionalExpression","LogicalExpression","globalTemplateAlteredFunction","globalTemplateFunction","globalTemplateVariable","coverageTemplate","preserveComments","alreadyInstrumented","visitState","scope","hasBinding","shouldIgnoreFile","programNode","test","programVisitor","opts","instrumentVisitor","find","p","traverse","freeze","coverageData","toJSON","fileCoverage","JSON","stringify","coverageNode","valueToNode","gvTemplate","coverageGlobalScopeFunc","getBinding","GLOBAL_COVERAGE_SCOPE","stringLiteral","coverageGlobalScope","cv","GLOBAL_COVERAGE_VAR","coverageVariable","GLOBAL_COVERAGE_TEMPLATE","COVERAGE_FUNCTION","PATH","INITIAL","HASH","module","exports"],"sources":["/Users/lincolnkushwah/Desktop/All/React Projects/house_joy_new/node_modules/istanbul-lib-instrument/src/visitor.js"],"sourcesContent":["const { createHash } = require('crypto');\nconst { template } = require('@babel/core');\nconst { defaults } = require('@istanbuljs/schema');\nconst { SourceCoverage } = require('./source-coverage');\nconst { SHA, MAGIC_KEY, MAGIC_VALUE } = require('./constants');\n\n// pattern for istanbul to ignore a section\nconst COMMENT_RE = /^\\s*istanbul\\s+ignore\\s+(if|else|next)(?=\\W|$)/;\n// pattern for istanbul to ignore the whole file\nconst COMMENT_FILE_RE = /^\\s*istanbul\\s+ignore\\s+(file)(?=\\W|$)/;\n// source map URL pattern\nconst SOURCE_MAP_RE = /[#@]\\s*sourceMappingURL=(.*)\\s*$/m;\n\n// generate a variable name from hashing the supplied file path\nfunction genVar(filename) {\n    const hash = createHash(SHA);\n    hash.update(filename);\n    return 'cov_' + parseInt(hash.digest('hex').substr(0, 12), 16).toString(36);\n}\n\n// VisitState holds the state of the visitor, provides helper functions\n// and is the `this` for the individual coverage visitors.\nclass VisitState {\n    constructor(\n        types,\n        sourceFilePath,\n        inputSourceMap,\n        ignoreClassMethods = [],\n        reportLogic = false\n    ) {\n        this.varName = genVar(sourceFilePath);\n        this.attrs = {};\n        this.nextIgnore = null;\n        this.cov = new SourceCoverage(sourceFilePath);\n\n        if (typeof inputSourceMap !== 'undefined') {\n            this.cov.inputSourceMap(inputSourceMap);\n        }\n        this.ignoreClassMethods = ignoreClassMethods;\n        this.types = types;\n        this.sourceMappingURL = null;\n        this.reportLogic = reportLogic;\n    }\n\n    // should we ignore the node? Yes, if specifically ignoring\n    // or if the node is generated.\n    shouldIgnore(path) {\n        return this.nextIgnore || !path.node.loc;\n    }\n\n    // extract the ignore comment hint (next|if|else) or null\n    hintFor(node) {\n        let hint = null;\n        if (node.leadingComments) {\n            node.leadingComments.forEach(c => {\n                const v = (\n                    c.value || /* istanbul ignore next: paranoid check */ ''\n                ).trim();\n                const groups = v.match(COMMENT_RE);\n                if (groups) {\n                    hint = groups[1];\n                }\n            });\n        }\n        return hint;\n    }\n\n    // extract a source map URL from comments and keep track of it\n    maybeAssignSourceMapURL(node) {\n        const extractURL = comments => {\n            if (!comments) {\n                return;\n            }\n            comments.forEach(c => {\n                const v = (\n                    c.value || /* istanbul ignore next: paranoid check */ ''\n                ).trim();\n                const groups = v.match(SOURCE_MAP_RE);\n                if (groups) {\n                    this.sourceMappingURL = groups[1];\n                }\n            });\n        };\n        extractURL(node.leadingComments);\n        extractURL(node.trailingComments);\n    }\n\n    // for these expressions the statement counter needs to be hoisted, so\n    // function name inference can be preserved\n    counterNeedsHoisting(path) {\n        return (\n            path.isFunctionExpression() ||\n            path.isArrowFunctionExpression() ||\n            path.isClassExpression()\n        );\n    }\n\n    // all the generic stuff that needs to be done on enter for every node\n    onEnter(path) {\n        const n = path.node;\n\n        this.maybeAssignSourceMapURL(n);\n\n        // if already ignoring, nothing more to do\n        if (this.nextIgnore !== null) {\n            return;\n        }\n        // check hint to see if ignore should be turned on\n        const hint = this.hintFor(n);\n        if (hint === 'next') {\n            this.nextIgnore = n;\n            return;\n        }\n        // else check custom node attribute set by a prior visitor\n        if (this.getAttr(path.node, 'skip-all') !== null) {\n            this.nextIgnore = n;\n        }\n\n        // else check for ignored class methods\n        if (\n            path.isFunctionExpression() &&\n            this.ignoreClassMethods.some(\n                name => path.node.id && name === path.node.id.name\n            )\n        ) {\n            this.nextIgnore = n;\n            return;\n        }\n        if (\n            path.isClassMethod() &&\n            this.ignoreClassMethods.some(name => name === path.node.key.name)\n        ) {\n            this.nextIgnore = n;\n            return;\n        }\n    }\n\n    // all the generic stuff on exit of a node,\n    // including reseting ignores and custom node attrs\n    onExit(path) {\n        // restore ignore status, if needed\n        if (path.node === this.nextIgnore) {\n            this.nextIgnore = null;\n        }\n        // nuke all attributes for the node\n        delete path.node.__cov__;\n    }\n\n    // set a node attribute for the supplied node\n    setAttr(node, name, value) {\n        node.__cov__ = node.__cov__ || {};\n        node.__cov__[name] = value;\n    }\n\n    // retrieve a node attribute for the supplied node or null\n    getAttr(node, name) {\n        const c = node.__cov__;\n        if (!c) {\n            return null;\n        }\n        return c[name];\n    }\n\n    //\n    increase(type, id, index) {\n        const T = this.types;\n        const wrap =\n            index !== null\n                ? // If `index` present, turn `x` into `x[index]`.\n                  x => T.memberExpression(x, T.numericLiteral(index), true)\n                : x => x;\n        return T.updateExpression(\n            '++',\n            wrap(\n                T.memberExpression(\n                    T.memberExpression(\n                        T.callExpression(T.identifier(this.varName), []),\n                        T.identifier(type)\n                    ),\n                    T.numericLiteral(id),\n                    true\n                )\n            )\n        );\n    }\n\n    // Reads the logic expression conditions and conditionally increments truthy counter.\n    increaseTrue(type, id, index, node) {\n        const T = this.types;\n        const tempName = `${this.varName}_temp`;\n\n        return T.sequenceExpression([\n            T.assignmentExpression(\n                '=',\n                T.memberExpression(\n                    T.callExpression(T.identifier(this.varName), []),\n                    T.identifier(tempName)\n                ),\n                node // Only evaluates once.\n            ),\n            T.parenthesizedExpression(\n                T.conditionalExpression(\n                    this.validateTrueNonTrivial(T, tempName),\n                    this.increase(type, id, index),\n                    T.nullLiteral()\n                )\n            ),\n            T.memberExpression(\n                T.callExpression(T.identifier(this.varName), []),\n                T.identifier(tempName)\n            )\n        ]);\n    }\n\n    validateTrueNonTrivial(T, tempName) {\n        return T.logicalExpression(\n            '&&',\n            T.memberExpression(\n                T.callExpression(T.identifier(this.varName), []),\n                T.identifier(tempName)\n            ),\n            T.logicalExpression(\n                '&&',\n                T.parenthesizedExpression(\n                    T.logicalExpression(\n                        '||',\n                        T.unaryExpression(\n                            '!',\n                            T.callExpression(\n                                T.memberExpression(\n                                    T.identifier('Array'),\n                                    T.identifier('isArray')\n                                ),\n                                [\n                                    T.memberExpression(\n                                        T.callExpression(\n                                            T.identifier(this.varName),\n                                            []\n                                        ),\n                                        T.identifier(tempName)\n                                    )\n                                ]\n                            )\n                        ),\n                        T.memberExpression(\n                            T.memberExpression(\n                                T.callExpression(\n                                    T.identifier(this.varName),\n                                    []\n                                ),\n                                T.identifier(tempName)\n                            ),\n                            T.identifier('length')\n                        )\n                    )\n                ),\n                T.parenthesizedExpression(\n                    T.logicalExpression(\n                        '||',\n                        T.binaryExpression(\n                            '!==',\n                            T.callExpression(\n                                T.memberExpression(\n                                    T.identifier('Object'),\n                                    T.identifier('getPrototypeOf')\n                                ),\n                                [\n                                    T.memberExpression(\n                                        T.callExpression(\n                                            T.identifier(this.varName),\n                                            []\n                                        ),\n                                        T.identifier(tempName)\n                                    )\n                                ]\n                            ),\n                            T.memberExpression(\n                                T.identifier('Object'),\n                                T.identifier('prototype')\n                            )\n                        ),\n                        T.memberExpression(\n                            T.callExpression(\n                                T.memberExpression(\n                                    T.identifier('Object'),\n                                    T.identifier('values')\n                                ),\n                                [\n                                    T.memberExpression(\n                                        T.callExpression(\n                                            T.identifier(this.varName),\n                                            []\n                                        ),\n                                        T.identifier(tempName)\n                                    )\n                                ]\n                            ),\n                            T.identifier('length')\n                        )\n                    )\n                )\n            )\n        );\n    }\n\n    insertCounter(path, increment) {\n        const T = this.types;\n        if (path.isBlockStatement()) {\n            path.node.body.unshift(T.expressionStatement(increment));\n        } else if (path.isStatement()) {\n            path.insertBefore(T.expressionStatement(increment));\n        } else if (\n            this.counterNeedsHoisting(path) &&\n            T.isVariableDeclarator(path.parentPath)\n        ) {\n            // make an attempt to hoist the statement counter, so that\n            // function names are maintained.\n            const parent = path.parentPath.parentPath;\n            if (parent && T.isExportNamedDeclaration(parent.parentPath)) {\n                parent.parentPath.insertBefore(\n                    T.expressionStatement(increment)\n                );\n            } else if (\n                parent &&\n                (T.isProgram(parent.parentPath) ||\n                    T.isBlockStatement(parent.parentPath))\n            ) {\n                parent.insertBefore(T.expressionStatement(increment));\n            } else {\n                path.replaceWith(T.sequenceExpression([increment, path.node]));\n            }\n        } /* istanbul ignore else: not expected */ else if (\n            path.isExpression()\n        ) {\n            path.replaceWith(T.sequenceExpression([increment, path.node]));\n        } else {\n            console.error(\n                'Unable to insert counter for node type:',\n                path.node.type\n            );\n        }\n    }\n\n    insertStatementCounter(path) {\n        /* istanbul ignore if: paranoid check */\n        if (!(path.node && path.node.loc)) {\n            return;\n        }\n        const index = this.cov.newStatement(path.node.loc);\n        const increment = this.increase('s', index, null);\n        this.insertCounter(path, increment);\n    }\n\n    insertFunctionCounter(path) {\n        const T = this.types;\n        /* istanbul ignore if: paranoid check */\n        if (!(path.node && path.node.loc)) {\n            return;\n        }\n        const n = path.node;\n\n        let dloc = null;\n        // get location for declaration\n        switch (n.type) {\n            case 'FunctionDeclaration':\n            case 'FunctionExpression':\n                /* istanbul ignore else: paranoid check */\n                if (n.id) {\n                    dloc = n.id.loc;\n                }\n                break;\n        }\n        if (!dloc) {\n            dloc = {\n                start: n.loc.start,\n                end: { line: n.loc.start.line, column: n.loc.start.column + 1 }\n            };\n        }\n\n        const name = path.node.id ? path.node.id.name : path.node.name;\n        const index = this.cov.newFunction(name, dloc, path.node.body.loc);\n        const increment = this.increase('f', index, null);\n        const body = path.get('body');\n        /* istanbul ignore else: not expected */\n        if (body.isBlockStatement()) {\n            body.node.body.unshift(T.expressionStatement(increment));\n        } else {\n            console.error(\n                'Unable to process function body node type:',\n                path.node.type\n            );\n        }\n    }\n\n    getBranchIncrement(branchName, loc) {\n        const index = this.cov.addBranchPath(branchName, loc);\n        return this.increase('b', branchName, index);\n    }\n\n    getBranchLogicIncrement(path, branchName, loc) {\n        const index = this.cov.addBranchPath(branchName, loc);\n        return [\n            this.increase('b', branchName, index),\n            this.increaseTrue('bT', branchName, index, path.node)\n        ];\n    }\n\n    insertBranchCounter(path, branchName, loc) {\n        const increment = this.getBranchIncrement(\n            branchName,\n            loc || path.node.loc\n        );\n        this.insertCounter(path, increment);\n    }\n\n    findLeaves(node, accumulator, parent, property) {\n        if (!node) {\n            return;\n        }\n        if (node.type === 'LogicalExpression') {\n            const hint = this.hintFor(node);\n            if (hint !== 'next') {\n                this.findLeaves(node.left, accumulator, node, 'left');\n                this.findLeaves(node.right, accumulator, node, 'right');\n            }\n        } else {\n            accumulator.push({\n                node,\n                parent,\n                property\n            });\n        }\n    }\n}\n\n// generic function that takes a set of visitor methods and\n// returns a visitor object with `enter` and `exit` properties,\n// such that:\n//\n// * standard entry processing is done\n// * the supplied visitors are called only when ignore is not in effect\n//   This relieves them from worrying about ignore states and generated nodes.\n// * standard exit processing is done\n//\nfunction entries(...enter) {\n    // the enter function\n    const wrappedEntry = function(path, node) {\n        this.onEnter(path);\n        if (this.shouldIgnore(path)) {\n            return;\n        }\n        enter.forEach(e => {\n            e.call(this, path, node);\n        });\n    };\n    const exit = function(path, node) {\n        this.onExit(path, node);\n    };\n    return {\n        enter: wrappedEntry,\n        exit\n    };\n}\n\nfunction coverStatement(path) {\n    this.insertStatementCounter(path);\n}\n\n/* istanbul ignore next: no node.js support */\nfunction coverAssignmentPattern(path) {\n    const n = path.node;\n    const b = this.cov.newBranch('default-arg', n.loc);\n    this.insertBranchCounter(path.get('right'), b);\n}\n\nfunction coverFunction(path) {\n    this.insertFunctionCounter(path);\n}\n\nfunction coverVariableDeclarator(path) {\n    this.insertStatementCounter(path.get('init'));\n}\n\nfunction coverClassPropDeclarator(path) {\n    this.insertStatementCounter(path.get('value'));\n}\n\nfunction makeBlock(path) {\n    const T = this.types;\n    if (!path.node) {\n        path.replaceWith(T.blockStatement([]));\n    }\n    if (!path.isBlockStatement()) {\n        path.replaceWith(T.blockStatement([path.node]));\n        path.node.loc = path.node.body[0].loc;\n        path.node.body[0].leadingComments = path.node.leadingComments;\n        path.node.leadingComments = undefined;\n    }\n}\n\nfunction blockProp(prop) {\n    return function(path) {\n        makeBlock.call(this, path.get(prop));\n    };\n}\n\nfunction makeParenthesizedExpressionForNonIdentifier(path) {\n    const T = this.types;\n    if (path.node && !path.isIdentifier()) {\n        path.replaceWith(T.parenthesizedExpression(path.node));\n    }\n}\n\nfunction parenthesizedExpressionProp(prop) {\n    return function(path) {\n        makeParenthesizedExpressionForNonIdentifier.call(this, path.get(prop));\n    };\n}\n\nfunction convertArrowExpression(path) {\n    const n = path.node;\n    const T = this.types;\n    if (!T.isBlockStatement(n.body)) {\n        const bloc = n.body.loc;\n        if (n.expression === true) {\n            n.expression = false;\n        }\n        n.body = T.blockStatement([T.returnStatement(n.body)]);\n        // restore body location\n        n.body.loc = bloc;\n        // set up the location for the return statement so it gets\n        // instrumented\n        n.body.body[0].loc = bloc;\n    }\n}\n\nfunction coverIfBranches(path) {\n    const n = path.node;\n    const hint = this.hintFor(n);\n    const ignoreIf = hint === 'if';\n    const ignoreElse = hint === 'else';\n    const branch = this.cov.newBranch('if', n.loc);\n\n    if (ignoreIf) {\n        this.setAttr(n.consequent, 'skip-all', true);\n    } else {\n        this.insertBranchCounter(path.get('consequent'), branch, n.loc);\n    }\n    if (ignoreElse) {\n        this.setAttr(n.alternate, 'skip-all', true);\n    } else {\n        this.insertBranchCounter(path.get('alternate'), branch);\n    }\n}\n\nfunction createSwitchBranch(path) {\n    const b = this.cov.newBranch('switch', path.node.loc);\n    this.setAttr(path.node, 'branchName', b);\n}\n\nfunction coverSwitchCase(path) {\n    const T = this.types;\n    const b = this.getAttr(path.parentPath.node, 'branchName');\n    /* istanbul ignore if: paranoid check */\n    if (b === null) {\n        throw new Error('Unable to get switch branch name');\n    }\n    const increment = this.getBranchIncrement(b, path.node.loc);\n    path.node.consequent.unshift(T.expressionStatement(increment));\n}\n\nfunction coverTernary(path) {\n    const n = path.node;\n    const branch = this.cov.newBranch('cond-expr', path.node.loc);\n    const cHint = this.hintFor(n.consequent);\n    const aHint = this.hintFor(n.alternate);\n\n    if (cHint !== 'next') {\n        this.insertBranchCounter(path.get('consequent'), branch);\n    }\n    if (aHint !== 'next') {\n        this.insertBranchCounter(path.get('alternate'), branch);\n    }\n}\n\nfunction coverLogicalExpression(path) {\n    const T = this.types;\n    if (path.parentPath.node.type === 'LogicalExpression') {\n        return; // already processed\n    }\n    const leaves = [];\n    this.findLeaves(path.node, leaves);\n    const b = this.cov.newBranch(\n        'binary-expr',\n        path.node.loc,\n        this.reportLogic\n    );\n    for (let i = 0; i < leaves.length; i += 1) {\n        const leaf = leaves[i];\n        const hint = this.hintFor(leaf.node);\n        if (hint === 'next') {\n            continue;\n        }\n\n        if (this.reportLogic) {\n            const increment = this.getBranchLogicIncrement(\n                leaf,\n                b,\n                leaf.node.loc\n            );\n            if (!increment[0]) {\n                continue;\n            }\n            leaf.parent[leaf.property] = T.sequenceExpression([\n                increment[0],\n                increment[1]\n            ]);\n            continue;\n        }\n\n        const increment = this.getBranchIncrement(b, leaf.node.loc);\n        if (!increment) {\n            continue;\n        }\n        leaf.parent[leaf.property] = T.sequenceExpression([\n            increment,\n            leaf.node\n        ]);\n    }\n}\n\nconst codeVisitor = {\n    ArrowFunctionExpression: entries(convertArrowExpression, coverFunction),\n    AssignmentPattern: entries(coverAssignmentPattern),\n    BlockStatement: entries(), // ignore processing only\n    ExportDefaultDeclaration: entries(), // ignore processing only\n    ExportNamedDeclaration: entries(), // ignore processing only\n    ClassMethod: entries(coverFunction),\n    ClassDeclaration: entries(parenthesizedExpressionProp('superClass')),\n    ClassProperty: entries(coverClassPropDeclarator),\n    ClassPrivateProperty: entries(coverClassPropDeclarator),\n    ObjectMethod: entries(coverFunction),\n    ExpressionStatement: entries(coverStatement),\n    BreakStatement: entries(coverStatement),\n    ContinueStatement: entries(coverStatement),\n    DebuggerStatement: entries(coverStatement),\n    ReturnStatement: entries(coverStatement),\n    ThrowStatement: entries(coverStatement),\n    TryStatement: entries(coverStatement),\n    VariableDeclaration: entries(), // ignore processing only\n    VariableDeclarator: entries(coverVariableDeclarator),\n    IfStatement: entries(\n        blockProp('consequent'),\n        blockProp('alternate'),\n        coverStatement,\n        coverIfBranches\n    ),\n    ForStatement: entries(blockProp('body'), coverStatement),\n    ForInStatement: entries(blockProp('body'), coverStatement),\n    ForOfStatement: entries(blockProp('body'), coverStatement),\n    WhileStatement: entries(blockProp('body'), coverStatement),\n    DoWhileStatement: entries(blockProp('body'), coverStatement),\n    SwitchStatement: entries(createSwitchBranch, coverStatement),\n    SwitchCase: entries(coverSwitchCase),\n    WithStatement: entries(blockProp('body'), coverStatement),\n    FunctionDeclaration: entries(coverFunction),\n    FunctionExpression: entries(coverFunction),\n    LabeledStatement: entries(coverStatement),\n    ConditionalExpression: entries(coverTernary),\n    LogicalExpression: entries(coverLogicalExpression)\n};\nconst globalTemplateAlteredFunction = template(`\n        var Function = (function(){}).constructor;\n        var global = (new Function(GLOBAL_COVERAGE_SCOPE))();\n`);\nconst globalTemplateFunction = template(`\n        var global = (new Function(GLOBAL_COVERAGE_SCOPE))();\n`);\nconst globalTemplateVariable = template(`\n        var global = GLOBAL_COVERAGE_SCOPE;\n`);\n// the template to insert at the top of the program.\nconst coverageTemplate = template(\n    `\n    function COVERAGE_FUNCTION () {\n        var path = PATH;\n        var hash = HASH;\n        GLOBAL_COVERAGE_TEMPLATE\n        var gcv = GLOBAL_COVERAGE_VAR;\n        var coverageData = INITIAL;\n        var coverage = global[gcv] || (global[gcv] = {});\n        if (!coverage[path] || coverage[path].hash !== hash) {\n            coverage[path] = coverageData;\n        }\n\n        var actualCoverage = coverage[path];\n        {\n            // @ts-ignore\n            COVERAGE_FUNCTION = function () {\n                return actualCoverage;\n            }\n        }\n\n        return actualCoverage;\n    }\n`,\n    { preserveComments: true }\n);\n// the rewire plugin (and potentially other babel middleware)\n// may cause files to be instrumented twice, see:\n// https://github.com/istanbuljs/babel-plugin-istanbul/issues/94\n// we should only instrument code for coverage the first time\n// it's run through istanbul-lib-instrument.\nfunction alreadyInstrumented(path, visitState) {\n    return path.scope.hasBinding(visitState.varName);\n}\nfunction shouldIgnoreFile(programNode) {\n    return (\n        programNode.parent &&\n        programNode.parent.comments.some(c => COMMENT_FILE_RE.test(c.value))\n    );\n}\n\n/**\n * programVisitor is a `babel` adaptor for instrumentation.\n * It returns an object with two methods `enter` and `exit`.\n * These should be assigned to or called from `Program` entry and exit functions\n * in a babel visitor.\n * These functions do not make assumptions about the state set by Babel and thus\n * can be used in a context other than a Babel plugin.\n *\n * The exit function returns an object that currently has the following keys:\n *\n * `fileCoverage` - the file coverage object created for the source file.\n * `sourceMappingURL` - any source mapping URL found when processing the file.\n *\n * @param {Object} types - an instance of babel-types.\n * @param {string} sourceFilePath - the path to source file.\n * @param {Object} opts - additional options.\n * @param {string} [opts.coverageVariable=__coverage__] the global coverage variable name.\n * @param {boolean} [opts.reportLogic=false] report boolean value of logical expressions.\n * @param {string} [opts.coverageGlobalScope=this] the global coverage variable scope.\n * @param {boolean} [opts.coverageGlobalScopeFunc=true] use an evaluated function to find coverageGlobalScope.\n * @param {Array} [opts.ignoreClassMethods=[]] names of methods to ignore by default on classes.\n * @param {object} [opts.inputSourceMap=undefined] the input source map, that maps the uninstrumented code back to the\n * original code.\n */\nfunction programVisitor(types, sourceFilePath = 'unknown.js', opts = {}) {\n    const T = types;\n    opts = {\n        ...defaults.instrumentVisitor,\n        ...opts\n    };\n    const visitState = new VisitState(\n        types,\n        sourceFilePath,\n        opts.inputSourceMap,\n        opts.ignoreClassMethods,\n        opts.reportLogic\n    );\n    return {\n        enter(path) {\n            if (shouldIgnoreFile(path.find(p => p.isProgram()))) {\n                return;\n            }\n            if (alreadyInstrumented(path, visitState)) {\n                return;\n            }\n            path.traverse(codeVisitor, visitState);\n        },\n        exit(path) {\n            if (alreadyInstrumented(path, visitState)) {\n                return;\n            }\n            visitState.cov.freeze();\n            const coverageData = visitState.cov.toJSON();\n            if (shouldIgnoreFile(path.find(p => p.isProgram()))) {\n                return {\n                    fileCoverage: coverageData,\n                    sourceMappingURL: visitState.sourceMappingURL\n                };\n            }\n            coverageData[MAGIC_KEY] = MAGIC_VALUE;\n            const hash = createHash(SHA)\n                .update(JSON.stringify(coverageData))\n                .digest('hex');\n            coverageData.hash = hash;\n            const coverageNode = T.valueToNode(coverageData);\n            delete coverageData[MAGIC_KEY];\n            delete coverageData.hash;\n            let gvTemplate;\n            if (opts.coverageGlobalScopeFunc) {\n                if (path.scope.getBinding('Function')) {\n                    gvTemplate = globalTemplateAlteredFunction({\n                        GLOBAL_COVERAGE_SCOPE: T.stringLiteral(\n                            'return ' + opts.coverageGlobalScope\n                        )\n                    });\n                } else {\n                    gvTemplate = globalTemplateFunction({\n                        GLOBAL_COVERAGE_SCOPE: T.stringLiteral(\n                            'return ' + opts.coverageGlobalScope\n                        )\n                    });\n                }\n            } else {\n                gvTemplate = globalTemplateVariable({\n                    GLOBAL_COVERAGE_SCOPE: opts.coverageGlobalScope\n                });\n            }\n            const cv = coverageTemplate({\n                GLOBAL_COVERAGE_VAR: T.stringLiteral(opts.coverageVariable),\n                GLOBAL_COVERAGE_TEMPLATE: gvTemplate,\n                COVERAGE_FUNCTION: T.identifier(visitState.varName),\n                PATH: T.stringLiteral(sourceFilePath),\n                INITIAL: coverageNode,\n                HASH: T.stringLiteral(hash)\n            });\n            // explicitly call this.varName to ensure coverage is always initialized\n            path.node.body.unshift(\n                T.expressionStatement(\n                    T.callExpression(T.identifier(visitState.varName), [])\n                )\n            );\n            path.node.body.unshift(cv);\n            return {\n                fileCoverage: coverageData,\n                sourceMappingURL: visitState.sourceMappingURL\n            };\n        }\n    };\n}\n\nmodule.exports = programVisitor;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}