{"ast":null,"code":"const {\n  classes\n} = require('istanbul-lib-coverage');\n\nfunction cloneLocation(loc) {\n  return {\n    start: {\n      line: loc && loc.start.line,\n      column: loc && loc.start.column\n    },\n    end: {\n      line: loc && loc.end.line,\n      column: loc && loc.end.column\n    }\n  };\n}\n/**\n * SourceCoverage provides mutation methods to manipulate the structure of\n * a file coverage object. Used by the instrumenter to create a full coverage\n * object for a file incrementally.\n *\n * @private\n * @param pathOrObj {String|Object} - see the argument for {@link FileCoverage}\n * @extends FileCoverage\n * @constructor\n */\n\n\nclass SourceCoverage extends classes.FileCoverage {\n  constructor(pathOrObj) {\n    super(pathOrObj);\n    this.meta = {\n      last: {\n        s: 0,\n        f: 0,\n        b: 0\n      }\n    };\n  }\n\n  newStatement(loc) {\n    const s = this.meta.last.s;\n    this.data.statementMap[s] = cloneLocation(loc);\n    this.data.s[s] = 0;\n    this.meta.last.s += 1;\n    return s;\n  }\n\n  newFunction(name, decl, loc) {\n    const f = this.meta.last.f;\n    name = name || '(anonymous_' + f + ')';\n    this.data.fnMap[f] = {\n      name,\n      decl: cloneLocation(decl),\n      loc: cloneLocation(loc),\n      // DEPRECATED: some legacy reports require this info.\n      line: loc && loc.start.line\n    };\n    this.data.f[f] = 0;\n    this.meta.last.f += 1;\n    return f;\n  }\n\n  newBranch(type, loc) {\n    let isReportLogic = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    const b = this.meta.last.b;\n    this.data.b[b] = [];\n    this.data.branchMap[b] = {\n      loc: cloneLocation(loc),\n      type,\n      locations: [],\n      // DEPRECATED: some legacy reports require this info.\n      line: loc && loc.start.line\n    };\n    this.meta.last.b += 1;\n    this.maybeNewBranchTrue(type, b, isReportLogic);\n    return b;\n  }\n\n  maybeNewBranchTrue(type, name, isReportLogic) {\n    if (!isReportLogic) {\n      return;\n    }\n\n    if (type !== 'binary-expr') {\n      return;\n    }\n\n    this.data.bT = this.data.bT || {};\n    this.data.bT[name] = [];\n  }\n\n  addBranchPath(name, location) {\n    const bMeta = this.data.branchMap[name];\n    const counts = this.data.b[name];\n    /* istanbul ignore if: paranoid check */\n\n    if (!bMeta) {\n      throw new Error('Invalid branch ' + name);\n    }\n\n    bMeta.locations.push(cloneLocation(location));\n    counts.push(0);\n    this.maybeAddBranchTrue(name);\n    return counts.length - 1;\n  }\n\n  maybeAddBranchTrue(name) {\n    if (!this.data.bT) {\n      return;\n    }\n\n    const countsTrue = this.data.bT[name];\n\n    if (!countsTrue) {\n      return;\n    }\n\n    countsTrue.push(0);\n  }\n  /**\n   * Assigns an input source map to the coverage that can be used\n   * to remap the coverage output to the original source\n   * @param sourceMap {object} the source map\n   */\n\n\n  inputSourceMap(sourceMap) {\n    this.data.inputSourceMap = sourceMap;\n  }\n\n  freeze() {\n    // prune empty branches\n    const map = this.data.branchMap;\n    const branches = this.data.b;\n    const branchesT = this.data.bT || {};\n    Object.keys(map).forEach(b => {\n      if (map[b].locations.length === 0) {\n        delete map[b];\n        delete branches[b];\n        delete branchesT[b];\n      }\n    });\n  }\n\n}\n\nmodule.exports = {\n  SourceCoverage\n};","map":{"version":3,"names":["classes","require","cloneLocation","loc","start","line","column","end","SourceCoverage","FileCoverage","constructor","pathOrObj","meta","last","s","f","b","newStatement","data","statementMap","newFunction","name","decl","fnMap","newBranch","type","isReportLogic","branchMap","locations","maybeNewBranchTrue","bT","addBranchPath","location","bMeta","counts","Error","push","maybeAddBranchTrue","length","countsTrue","inputSourceMap","sourceMap","freeze","map","branches","branchesT","Object","keys","forEach","module","exports"],"sources":["/Users/lincolnkushwah/Desktop/All/React Projects/house_joy_new/node_modules/istanbul-lib-instrument/src/source-coverage.js"],"sourcesContent":["const { classes } = require('istanbul-lib-coverage');\n\nfunction cloneLocation(loc) {\n    return {\n        start: {\n            line: loc && loc.start.line,\n            column: loc && loc.start.column\n        },\n        end: {\n            line: loc && loc.end.line,\n            column: loc && loc.end.column\n        }\n    };\n}\n/**\n * SourceCoverage provides mutation methods to manipulate the structure of\n * a file coverage object. Used by the instrumenter to create a full coverage\n * object for a file incrementally.\n *\n * @private\n * @param pathOrObj {String|Object} - see the argument for {@link FileCoverage}\n * @extends FileCoverage\n * @constructor\n */\nclass SourceCoverage extends classes.FileCoverage {\n    constructor(pathOrObj) {\n        super(pathOrObj);\n        this.meta = {\n            last: {\n                s: 0,\n                f: 0,\n                b: 0\n            }\n        };\n    }\n\n    newStatement(loc) {\n        const s = this.meta.last.s;\n        this.data.statementMap[s] = cloneLocation(loc);\n        this.data.s[s] = 0;\n        this.meta.last.s += 1;\n        return s;\n    }\n\n    newFunction(name, decl, loc) {\n        const f = this.meta.last.f;\n        name = name || '(anonymous_' + f + ')';\n        this.data.fnMap[f] = {\n            name,\n            decl: cloneLocation(decl),\n            loc: cloneLocation(loc),\n            // DEPRECATED: some legacy reports require this info.\n            line: loc && loc.start.line\n        };\n        this.data.f[f] = 0;\n        this.meta.last.f += 1;\n        return f;\n    }\n\n    newBranch(type, loc, isReportLogic = false) {\n        const b = this.meta.last.b;\n        this.data.b[b] = [];\n        this.data.branchMap[b] = {\n            loc: cloneLocation(loc),\n            type,\n            locations: [],\n            // DEPRECATED: some legacy reports require this info.\n            line: loc && loc.start.line\n        };\n        this.meta.last.b += 1;\n        this.maybeNewBranchTrue(type, b, isReportLogic);\n        return b;\n    }\n\n    maybeNewBranchTrue(type, name, isReportLogic) {\n        if (!isReportLogic) {\n            return;\n        }\n        if (type !== 'binary-expr') {\n            return;\n        }\n        this.data.bT = this.data.bT || {};\n        this.data.bT[name] = [];\n    }\n\n    addBranchPath(name, location) {\n        const bMeta = this.data.branchMap[name];\n        const counts = this.data.b[name];\n\n        /* istanbul ignore if: paranoid check */\n        if (!bMeta) {\n            throw new Error('Invalid branch ' + name);\n        }\n        bMeta.locations.push(cloneLocation(location));\n        counts.push(0);\n        this.maybeAddBranchTrue(name);\n        return counts.length - 1;\n    }\n\n    maybeAddBranchTrue(name) {\n        if (!this.data.bT) {\n            return;\n        }\n        const countsTrue = this.data.bT[name];\n        if (!countsTrue) {\n            return;\n        }\n        countsTrue.push(0);\n    }\n\n    /**\n     * Assigns an input source map to the coverage that can be used\n     * to remap the coverage output to the original source\n     * @param sourceMap {object} the source map\n     */\n    inputSourceMap(sourceMap) {\n        this.data.inputSourceMap = sourceMap;\n    }\n\n    freeze() {\n        // prune empty branches\n        const map = this.data.branchMap;\n        const branches = this.data.b;\n        const branchesT = this.data.bT || {};\n        Object.keys(map).forEach(b => {\n            if (map[b].locations.length === 0) {\n                delete map[b];\n                delete branches[b];\n                delete branchesT[b];\n            }\n        });\n    }\n}\n\nmodule.exports = { SourceCoverage };\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}