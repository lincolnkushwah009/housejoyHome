{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.joinAlignedDiffsNoExpand = exports.joinAlignedDiffsExpand = void 0;\n\nvar _cleanupSemantic = require('./cleanupSemantic');\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nconst formatTrailingSpaces = (line, trailingSpaceFormatter) => line.replace(/\\s+$/, match => trailingSpaceFormatter(match));\n\nconst printDiffLine = (line, isFirstOrLast, color, indicator, trailingSpaceFormatter, emptyFirstOrLastLinePlaceholder) => line.length !== 0 ? color(indicator + ' ' + formatTrailingSpaces(line, trailingSpaceFormatter)) : indicator !== ' ' ? color(indicator) : isFirstOrLast && emptyFirstOrLastLinePlaceholder.length !== 0 ? color(indicator + ' ' + emptyFirstOrLastLinePlaceholder) : '';\n\nconst printDeleteLine = (line, isFirstOrLast, _ref) => {\n  let {\n    aColor,\n    aIndicator,\n    changeLineTrailingSpaceColor,\n    emptyFirstOrLastLinePlaceholder\n  } = _ref;\n  return printDiffLine(line, isFirstOrLast, aColor, aIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder);\n};\n\nconst printInsertLine = (line, isFirstOrLast, _ref2) => {\n  let {\n    bColor,\n    bIndicator,\n    changeLineTrailingSpaceColor,\n    emptyFirstOrLastLinePlaceholder\n  } = _ref2;\n  return printDiffLine(line, isFirstOrLast, bColor, bIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder);\n};\n\nconst printCommonLine = (line, isFirstOrLast, _ref3) => {\n  let {\n    commonColor,\n    commonIndicator,\n    commonLineTrailingSpaceColor,\n    emptyFirstOrLastLinePlaceholder\n  } = _ref3;\n  return printDiffLine(line, isFirstOrLast, commonColor, commonIndicator, commonLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder);\n}; // In GNU diff format, indexes are one-based instead of zero-based.\n\n\nconst createPatchMark = (aStart, aEnd, bStart, bEnd, _ref4) => {\n  let {\n    patchColor\n  } = _ref4;\n  return patchColor(`@@ -${aStart + 1},${aEnd - aStart} +${bStart + 1},${bEnd - bStart} @@`);\n}; // jest --no-expand\n//\n// Given array of aligned strings with inverse highlight formatting,\n// return joined lines with diff formatting (and patch marks, if needed).\n\n\nconst joinAlignedDiffsNoExpand = (diffs, options) => {\n  const iLength = diffs.length;\n  const nContextLines = options.contextLines;\n  const nContextLines2 = nContextLines + nContextLines; // First pass: count output lines and see if it has patches.\n\n  let jLength = iLength;\n  let hasExcessAtStartOrEnd = false;\n  let nExcessesBetweenChanges = 0;\n  let i = 0;\n\n  while (i !== iLength) {\n    const iStart = i;\n\n    while (i !== iLength && diffs[i][0] === _cleanupSemantic.DIFF_EQUAL) {\n      i += 1;\n    }\n\n    if (iStart !== i) {\n      if (iStart === 0) {\n        // at start\n        if (i > nContextLines) {\n          jLength -= i - nContextLines; // subtract excess common lines\n\n          hasExcessAtStartOrEnd = true;\n        }\n      } else if (i === iLength) {\n        // at end\n        const n = i - iStart;\n\n        if (n > nContextLines) {\n          jLength -= n - nContextLines; // subtract excess common lines\n\n          hasExcessAtStartOrEnd = true;\n        }\n      } else {\n        // between changes\n        const n = i - iStart;\n\n        if (n > nContextLines2) {\n          jLength -= n - nContextLines2; // subtract excess common lines\n\n          nExcessesBetweenChanges += 1;\n        }\n      }\n    }\n\n    while (i !== iLength && diffs[i][0] !== _cleanupSemantic.DIFF_EQUAL) {\n      i += 1;\n    }\n  }\n\n  const hasPatch = nExcessesBetweenChanges !== 0 || hasExcessAtStartOrEnd;\n\n  if (nExcessesBetweenChanges !== 0) {\n    jLength += nExcessesBetweenChanges + 1; // add patch lines\n  } else if (hasExcessAtStartOrEnd) {\n    jLength += 1; // add patch line\n  }\n\n  const jLast = jLength - 1;\n  const lines = [];\n  let jPatchMark = 0; // index of placeholder line for current patch mark\n\n  if (hasPatch) {\n    lines.push(''); // placeholder line for first patch mark\n  } // Indexes of expected or received lines in current patch:\n\n\n  let aStart = 0;\n  let bStart = 0;\n  let aEnd = 0;\n  let bEnd = 0;\n\n  const pushCommonLine = line => {\n    const j = lines.length;\n    lines.push(printCommonLine(line, j === 0 || j === jLast, options));\n    aEnd += 1;\n    bEnd += 1;\n  };\n\n  const pushDeleteLine = line => {\n    const j = lines.length;\n    lines.push(printDeleteLine(line, j === 0 || j === jLast, options));\n    aEnd += 1;\n  };\n\n  const pushInsertLine = line => {\n    const j = lines.length;\n    lines.push(printInsertLine(line, j === 0 || j === jLast, options));\n    bEnd += 1;\n  }; // Second pass: push lines with diff formatting (and patch marks, if needed).\n\n\n  i = 0;\n\n  while (i !== iLength) {\n    let iStart = i;\n\n    while (i !== iLength && diffs[i][0] === _cleanupSemantic.DIFF_EQUAL) {\n      i += 1;\n    }\n\n    if (iStart !== i) {\n      if (iStart === 0) {\n        // at beginning\n        if (i > nContextLines) {\n          iStart = i - nContextLines;\n          aStart = iStart;\n          bStart = iStart;\n          aEnd = aStart;\n          bEnd = bStart;\n        }\n\n        for (let iCommon = iStart; iCommon !== i; iCommon += 1) {\n          pushCommonLine(diffs[iCommon][1]);\n        }\n      } else if (i === iLength) {\n        // at end\n        const iEnd = i - iStart > nContextLines ? iStart + nContextLines : i;\n\n        for (let iCommon = iStart; iCommon !== iEnd; iCommon += 1) {\n          pushCommonLine(diffs[iCommon][1]);\n        }\n      } else {\n        // between changes\n        const nCommon = i - iStart;\n\n        if (nCommon > nContextLines2) {\n          const iEnd = iStart + nContextLines;\n\n          for (let iCommon = iStart; iCommon !== iEnd; iCommon += 1) {\n            pushCommonLine(diffs[iCommon][1]);\n          }\n\n          lines[jPatchMark] = createPatchMark(aStart, aEnd, bStart, bEnd, options);\n          jPatchMark = lines.length;\n          lines.push(''); // placeholder line for next patch mark\n\n          const nOmit = nCommon - nContextLines2;\n          aStart = aEnd + nOmit;\n          bStart = bEnd + nOmit;\n          aEnd = aStart;\n          bEnd = bStart;\n\n          for (let iCommon = i - nContextLines; iCommon !== i; iCommon += 1) {\n            pushCommonLine(diffs[iCommon][1]);\n          }\n        } else {\n          for (let iCommon = iStart; iCommon !== i; iCommon += 1) {\n            pushCommonLine(diffs[iCommon][1]);\n          }\n        }\n      }\n    }\n\n    while (i !== iLength && diffs[i][0] === _cleanupSemantic.DIFF_DELETE) {\n      pushDeleteLine(diffs[i][1]);\n      i += 1;\n    }\n\n    while (i !== iLength && diffs[i][0] === _cleanupSemantic.DIFF_INSERT) {\n      pushInsertLine(diffs[i][1]);\n      i += 1;\n    }\n  }\n\n  if (hasPatch) {\n    lines[jPatchMark] = createPatchMark(aStart, aEnd, bStart, bEnd, options);\n  }\n\n  return lines.join('\\n');\n}; // jest --expand\n//\n// Given array of aligned strings with inverse highlight formatting,\n// return joined lines with diff formatting.\n\n\nexports.joinAlignedDiffsNoExpand = joinAlignedDiffsNoExpand;\n\nconst joinAlignedDiffsExpand = (diffs, options) => diffs.map((diff, i, diffs) => {\n  const line = diff[1];\n  const isFirstOrLast = i === 0 || i === diffs.length - 1;\n\n  switch (diff[0]) {\n    case _cleanupSemantic.DIFF_DELETE:\n      return printDeleteLine(line, isFirstOrLast, options);\n\n    case _cleanupSemantic.DIFF_INSERT:\n      return printInsertLine(line, isFirstOrLast, options);\n\n    default:\n      return printCommonLine(line, isFirstOrLast, options);\n  }\n}).join('\\n');\n\nexports.joinAlignedDiffsExpand = joinAlignedDiffsExpand;","map":{"version":3,"names":["Object","defineProperty","exports","value","joinAlignedDiffsNoExpand","joinAlignedDiffsExpand","_cleanupSemantic","require","formatTrailingSpaces","line","trailingSpaceFormatter","replace","match","printDiffLine","isFirstOrLast","color","indicator","emptyFirstOrLastLinePlaceholder","length","printDeleteLine","aColor","aIndicator","changeLineTrailingSpaceColor","printInsertLine","bColor","bIndicator","printCommonLine","commonColor","commonIndicator","commonLineTrailingSpaceColor","createPatchMark","aStart","aEnd","bStart","bEnd","patchColor","diffs","options","iLength","nContextLines","contextLines","nContextLines2","jLength","hasExcessAtStartOrEnd","nExcessesBetweenChanges","i","iStart","DIFF_EQUAL","n","hasPatch","jLast","lines","jPatchMark","push","pushCommonLine","j","pushDeleteLine","pushInsertLine","iCommon","iEnd","nCommon","nOmit","DIFF_DELETE","DIFF_INSERT","join","map","diff"],"sources":["/Users/lincolnkushwah/Desktop/All/React Projects/house_joy_new/node_modules/jest-diff/build/joinAlignedDiffs.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.joinAlignedDiffsNoExpand = exports.joinAlignedDiffsExpand = void 0;\n\nvar _cleanupSemantic = require('./cleanupSemantic');\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nconst formatTrailingSpaces = (line, trailingSpaceFormatter) =>\n  line.replace(/\\s+$/, match => trailingSpaceFormatter(match));\n\nconst printDiffLine = (\n  line,\n  isFirstOrLast,\n  color,\n  indicator,\n  trailingSpaceFormatter,\n  emptyFirstOrLastLinePlaceholder\n) =>\n  line.length !== 0\n    ? color(\n        indicator + ' ' + formatTrailingSpaces(line, trailingSpaceFormatter)\n      )\n    : indicator !== ' '\n    ? color(indicator)\n    : isFirstOrLast && emptyFirstOrLastLinePlaceholder.length !== 0\n    ? color(indicator + ' ' + emptyFirstOrLastLinePlaceholder)\n    : '';\n\nconst printDeleteLine = (\n  line,\n  isFirstOrLast,\n  {\n    aColor,\n    aIndicator,\n    changeLineTrailingSpaceColor,\n    emptyFirstOrLastLinePlaceholder\n  }\n) =>\n  printDiffLine(\n    line,\n    isFirstOrLast,\n    aColor,\n    aIndicator,\n    changeLineTrailingSpaceColor,\n    emptyFirstOrLastLinePlaceholder\n  );\n\nconst printInsertLine = (\n  line,\n  isFirstOrLast,\n  {\n    bColor,\n    bIndicator,\n    changeLineTrailingSpaceColor,\n    emptyFirstOrLastLinePlaceholder\n  }\n) =>\n  printDiffLine(\n    line,\n    isFirstOrLast,\n    bColor,\n    bIndicator,\n    changeLineTrailingSpaceColor,\n    emptyFirstOrLastLinePlaceholder\n  );\n\nconst printCommonLine = (\n  line,\n  isFirstOrLast,\n  {\n    commonColor,\n    commonIndicator,\n    commonLineTrailingSpaceColor,\n    emptyFirstOrLastLinePlaceholder\n  }\n) =>\n  printDiffLine(\n    line,\n    isFirstOrLast,\n    commonColor,\n    commonIndicator,\n    commonLineTrailingSpaceColor,\n    emptyFirstOrLastLinePlaceholder\n  ); // In GNU diff format, indexes are one-based instead of zero-based.\n\nconst createPatchMark = (aStart, aEnd, bStart, bEnd, {patchColor}) =>\n  patchColor(\n    `@@ -${aStart + 1},${aEnd - aStart} +${bStart + 1},${bEnd - bStart} @@`\n  ); // jest --no-expand\n//\n// Given array of aligned strings with inverse highlight formatting,\n// return joined lines with diff formatting (and patch marks, if needed).\n\nconst joinAlignedDiffsNoExpand = (diffs, options) => {\n  const iLength = diffs.length;\n  const nContextLines = options.contextLines;\n  const nContextLines2 = nContextLines + nContextLines; // First pass: count output lines and see if it has patches.\n\n  let jLength = iLength;\n  let hasExcessAtStartOrEnd = false;\n  let nExcessesBetweenChanges = 0;\n  let i = 0;\n\n  while (i !== iLength) {\n    const iStart = i;\n\n    while (i !== iLength && diffs[i][0] === _cleanupSemantic.DIFF_EQUAL) {\n      i += 1;\n    }\n\n    if (iStart !== i) {\n      if (iStart === 0) {\n        // at start\n        if (i > nContextLines) {\n          jLength -= i - nContextLines; // subtract excess common lines\n\n          hasExcessAtStartOrEnd = true;\n        }\n      } else if (i === iLength) {\n        // at end\n        const n = i - iStart;\n\n        if (n > nContextLines) {\n          jLength -= n - nContextLines; // subtract excess common lines\n\n          hasExcessAtStartOrEnd = true;\n        }\n      } else {\n        // between changes\n        const n = i - iStart;\n\n        if (n > nContextLines2) {\n          jLength -= n - nContextLines2; // subtract excess common lines\n\n          nExcessesBetweenChanges += 1;\n        }\n      }\n    }\n\n    while (i !== iLength && diffs[i][0] !== _cleanupSemantic.DIFF_EQUAL) {\n      i += 1;\n    }\n  }\n\n  const hasPatch = nExcessesBetweenChanges !== 0 || hasExcessAtStartOrEnd;\n\n  if (nExcessesBetweenChanges !== 0) {\n    jLength += nExcessesBetweenChanges + 1; // add patch lines\n  } else if (hasExcessAtStartOrEnd) {\n    jLength += 1; // add patch line\n  }\n\n  const jLast = jLength - 1;\n  const lines = [];\n  let jPatchMark = 0; // index of placeholder line for current patch mark\n\n  if (hasPatch) {\n    lines.push(''); // placeholder line for first patch mark\n  } // Indexes of expected or received lines in current patch:\n\n  let aStart = 0;\n  let bStart = 0;\n  let aEnd = 0;\n  let bEnd = 0;\n\n  const pushCommonLine = line => {\n    const j = lines.length;\n    lines.push(printCommonLine(line, j === 0 || j === jLast, options));\n    aEnd += 1;\n    bEnd += 1;\n  };\n\n  const pushDeleteLine = line => {\n    const j = lines.length;\n    lines.push(printDeleteLine(line, j === 0 || j === jLast, options));\n    aEnd += 1;\n  };\n\n  const pushInsertLine = line => {\n    const j = lines.length;\n    lines.push(printInsertLine(line, j === 0 || j === jLast, options));\n    bEnd += 1;\n  }; // Second pass: push lines with diff formatting (and patch marks, if needed).\n\n  i = 0;\n\n  while (i !== iLength) {\n    let iStart = i;\n\n    while (i !== iLength && diffs[i][0] === _cleanupSemantic.DIFF_EQUAL) {\n      i += 1;\n    }\n\n    if (iStart !== i) {\n      if (iStart === 0) {\n        // at beginning\n        if (i > nContextLines) {\n          iStart = i - nContextLines;\n          aStart = iStart;\n          bStart = iStart;\n          aEnd = aStart;\n          bEnd = bStart;\n        }\n\n        for (let iCommon = iStart; iCommon !== i; iCommon += 1) {\n          pushCommonLine(diffs[iCommon][1]);\n        }\n      } else if (i === iLength) {\n        // at end\n        const iEnd = i - iStart > nContextLines ? iStart + nContextLines : i;\n\n        for (let iCommon = iStart; iCommon !== iEnd; iCommon += 1) {\n          pushCommonLine(diffs[iCommon][1]);\n        }\n      } else {\n        // between changes\n        const nCommon = i - iStart;\n\n        if (nCommon > nContextLines2) {\n          const iEnd = iStart + nContextLines;\n\n          for (let iCommon = iStart; iCommon !== iEnd; iCommon += 1) {\n            pushCommonLine(diffs[iCommon][1]);\n          }\n\n          lines[jPatchMark] = createPatchMark(\n            aStart,\n            aEnd,\n            bStart,\n            bEnd,\n            options\n          );\n          jPatchMark = lines.length;\n          lines.push(''); // placeholder line for next patch mark\n\n          const nOmit = nCommon - nContextLines2;\n          aStart = aEnd + nOmit;\n          bStart = bEnd + nOmit;\n          aEnd = aStart;\n          bEnd = bStart;\n\n          for (let iCommon = i - nContextLines; iCommon !== i; iCommon += 1) {\n            pushCommonLine(diffs[iCommon][1]);\n          }\n        } else {\n          for (let iCommon = iStart; iCommon !== i; iCommon += 1) {\n            pushCommonLine(diffs[iCommon][1]);\n          }\n        }\n      }\n    }\n\n    while (i !== iLength && diffs[i][0] === _cleanupSemantic.DIFF_DELETE) {\n      pushDeleteLine(diffs[i][1]);\n      i += 1;\n    }\n\n    while (i !== iLength && diffs[i][0] === _cleanupSemantic.DIFF_INSERT) {\n      pushInsertLine(diffs[i][1]);\n      i += 1;\n    }\n  }\n\n  if (hasPatch) {\n    lines[jPatchMark] = createPatchMark(aStart, aEnd, bStart, bEnd, options);\n  }\n\n  return lines.join('\\n');\n}; // jest --expand\n//\n// Given array of aligned strings with inverse highlight formatting,\n// return joined lines with diff formatting.\n\nexports.joinAlignedDiffsNoExpand = joinAlignedDiffsNoExpand;\n\nconst joinAlignedDiffsExpand = (diffs, options) =>\n  diffs\n    .map((diff, i, diffs) => {\n      const line = diff[1];\n      const isFirstOrLast = i === 0 || i === diffs.length - 1;\n\n      switch (diff[0]) {\n        case _cleanupSemantic.DIFF_DELETE:\n          return printDeleteLine(line, isFirstOrLast, options);\n\n        case _cleanupSemantic.DIFF_INSERT:\n          return printInsertLine(line, isFirstOrLast, options);\n\n        default:\n          return printCommonLine(line, isFirstOrLast, options);\n      }\n    })\n    .join('\\n');\n\nexports.joinAlignedDiffsExpand = joinAlignedDiffsExpand;\n"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;EAC3CC,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,wBAAR,GAAmCF,OAAO,CAACG,sBAAR,GAAiC,KAAK,CAAzE;;AAEA,IAAIC,gBAAgB,GAAGC,OAAO,CAAC,mBAAD,CAA9B;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMC,oBAAoB,GAAG,CAACC,IAAD,EAAOC,sBAAP,KAC3BD,IAAI,CAACE,OAAL,CAAa,MAAb,EAAqBC,KAAK,IAAIF,sBAAsB,CAACE,KAAD,CAApD,CADF;;AAGA,MAAMC,aAAa,GAAG,CACpBJ,IADoB,EAEpBK,aAFoB,EAGpBC,KAHoB,EAIpBC,SAJoB,EAKpBN,sBALoB,EAMpBO,+BANoB,KAQpBR,IAAI,CAACS,MAAL,KAAgB,CAAhB,GACIH,KAAK,CACHC,SAAS,GAAG,GAAZ,GAAkBR,oBAAoB,CAACC,IAAD,EAAOC,sBAAP,CADnC,CADT,GAIIM,SAAS,KAAK,GAAd,GACAD,KAAK,CAACC,SAAD,CADL,GAEAF,aAAa,IAAIG,+BAA+B,CAACC,MAAhC,KAA2C,CAA5D,GACAH,KAAK,CAACC,SAAS,GAAG,GAAZ,GAAkBC,+BAAnB,CADL,GAEA,EAhBN;;AAkBA,MAAME,eAAe,GAAG,CACtBV,IADsB,EAEtBK,aAFsB;EAAA,IAGtB;IACEM,MADF;IAEEC,UAFF;IAGEC,4BAHF;IAIEL;EAJF,CAHsB;EAAA,OAUtBJ,aAAa,CACXJ,IADW,EAEXK,aAFW,EAGXM,MAHW,EAIXC,UAJW,EAKXC,4BALW,EAMXL,+BANW,CAVS;AAAA,CAAxB;;AAmBA,MAAMM,eAAe,GAAG,CACtBd,IADsB,EAEtBK,aAFsB;EAAA,IAGtB;IACEU,MADF;IAEEC,UAFF;IAGEH,4BAHF;IAIEL;EAJF,CAHsB;EAAA,OAUtBJ,aAAa,CACXJ,IADW,EAEXK,aAFW,EAGXU,MAHW,EAIXC,UAJW,EAKXH,4BALW,EAMXL,+BANW,CAVS;AAAA,CAAxB;;AAmBA,MAAMS,eAAe,GAAG,CACtBjB,IADsB,EAEtBK,aAFsB;EAAA,IAGtB;IACEa,WADF;IAEEC,eAFF;IAGEC,4BAHF;IAIEZ;EAJF,CAHsB;EAAA,OAUtBJ,aAAa,CACXJ,IADW,EAEXK,aAFW,EAGXa,WAHW,EAIXC,eAJW,EAKXC,4BALW,EAMXZ,+BANW,CAVS;AAAA,CAAxB,C,CAiBK;;;AAEL,MAAMa,eAAe,GAAG,CAACC,MAAD,EAASC,IAAT,EAAeC,MAAf,EAAuBC,IAAvB;EAAA,IAA6B;IAACC;EAAD,CAA7B;EAAA,OACtBA,UAAU,CACP,OAAMJ,MAAM,GAAG,CAAE,IAAGC,IAAI,GAAGD,MAAO,KAAIE,MAAM,GAAG,CAAE,IAAGC,IAAI,GAAGD,MAAO,KAD3D,CADY;AAAA,CAAxB,C,CAGK;AACL;AACA;AACA;;;AAEA,MAAM7B,wBAAwB,GAAG,CAACgC,KAAD,EAAQC,OAAR,KAAoB;EACnD,MAAMC,OAAO,GAAGF,KAAK,CAAClB,MAAtB;EACA,MAAMqB,aAAa,GAAGF,OAAO,CAACG,YAA9B;EACA,MAAMC,cAAc,GAAGF,aAAa,GAAGA,aAAvC,CAHmD,CAGG;;EAEtD,IAAIG,OAAO,GAAGJ,OAAd;EACA,IAAIK,qBAAqB,GAAG,KAA5B;EACA,IAAIC,uBAAuB,GAAG,CAA9B;EACA,IAAIC,CAAC,GAAG,CAAR;;EAEA,OAAOA,CAAC,KAAKP,OAAb,EAAsB;IACpB,MAAMQ,MAAM,GAAGD,CAAf;;IAEA,OAAOA,CAAC,KAAKP,OAAN,IAAiBF,KAAK,CAACS,CAAD,CAAL,CAAS,CAAT,MAAgBvC,gBAAgB,CAACyC,UAAzD,EAAqE;MACnEF,CAAC,IAAI,CAAL;IACD;;IAED,IAAIC,MAAM,KAAKD,CAAf,EAAkB;MAChB,IAAIC,MAAM,KAAK,CAAf,EAAkB;QAChB;QACA,IAAID,CAAC,GAAGN,aAAR,EAAuB;UACrBG,OAAO,IAAIG,CAAC,GAAGN,aAAf,CADqB,CACS;;UAE9BI,qBAAqB,GAAG,IAAxB;QACD;MACF,CAPD,MAOO,IAAIE,CAAC,KAAKP,OAAV,EAAmB;QACxB;QACA,MAAMU,CAAC,GAAGH,CAAC,GAAGC,MAAd;;QAEA,IAAIE,CAAC,GAAGT,aAAR,EAAuB;UACrBG,OAAO,IAAIM,CAAC,GAAGT,aAAf,CADqB,CACS;;UAE9BI,qBAAqB,GAAG,IAAxB;QACD;MACF,CATM,MASA;QACL;QACA,MAAMK,CAAC,GAAGH,CAAC,GAAGC,MAAd;;QAEA,IAAIE,CAAC,GAAGP,cAAR,EAAwB;UACtBC,OAAO,IAAIM,CAAC,GAAGP,cAAf,CADsB,CACS;;UAE/BG,uBAAuB,IAAI,CAA3B;QACD;MACF;IACF;;IAED,OAAOC,CAAC,KAAKP,OAAN,IAAiBF,KAAK,CAACS,CAAD,CAAL,CAAS,CAAT,MAAgBvC,gBAAgB,CAACyC,UAAzD,EAAqE;MACnEF,CAAC,IAAI,CAAL;IACD;EACF;;EAED,MAAMI,QAAQ,GAAGL,uBAAuB,KAAK,CAA5B,IAAiCD,qBAAlD;;EAEA,IAAIC,uBAAuB,KAAK,CAAhC,EAAmC;IACjCF,OAAO,IAAIE,uBAAuB,GAAG,CAArC,CADiC,CACO;EACzC,CAFD,MAEO,IAAID,qBAAJ,EAA2B;IAChCD,OAAO,IAAI,CAAX,CADgC,CAClB;EACf;;EAED,MAAMQ,KAAK,GAAGR,OAAO,GAAG,CAAxB;EACA,MAAMS,KAAK,GAAG,EAAd;EACA,IAAIC,UAAU,GAAG,CAAjB,CA7DmD,CA6D/B;;EAEpB,IAAIH,QAAJ,EAAc;IACZE,KAAK,CAACE,IAAN,CAAW,EAAX,EADY,CACI;EACjB,CAjEkD,CAiEjD;;;EAEF,IAAItB,MAAM,GAAG,CAAb;EACA,IAAIE,MAAM,GAAG,CAAb;EACA,IAAID,IAAI,GAAG,CAAX;EACA,IAAIE,IAAI,GAAG,CAAX;;EAEA,MAAMoB,cAAc,GAAG7C,IAAI,IAAI;IAC7B,MAAM8C,CAAC,GAAGJ,KAAK,CAACjC,MAAhB;IACAiC,KAAK,CAACE,IAAN,CAAW3B,eAAe,CAACjB,IAAD,EAAO8C,CAAC,KAAK,CAAN,IAAWA,CAAC,KAAKL,KAAxB,EAA+Bb,OAA/B,CAA1B;IACAL,IAAI,IAAI,CAAR;IACAE,IAAI,IAAI,CAAR;EACD,CALD;;EAOA,MAAMsB,cAAc,GAAG/C,IAAI,IAAI;IAC7B,MAAM8C,CAAC,GAAGJ,KAAK,CAACjC,MAAhB;IACAiC,KAAK,CAACE,IAAN,CAAWlC,eAAe,CAACV,IAAD,EAAO8C,CAAC,KAAK,CAAN,IAAWA,CAAC,KAAKL,KAAxB,EAA+Bb,OAA/B,CAA1B;IACAL,IAAI,IAAI,CAAR;EACD,CAJD;;EAMA,MAAMyB,cAAc,GAAGhD,IAAI,IAAI;IAC7B,MAAM8C,CAAC,GAAGJ,KAAK,CAACjC,MAAhB;IACAiC,KAAK,CAACE,IAAN,CAAW9B,eAAe,CAACd,IAAD,EAAO8C,CAAC,KAAK,CAAN,IAAWA,CAAC,KAAKL,KAAxB,EAA+Bb,OAA/B,CAA1B;IACAH,IAAI,IAAI,CAAR;EACD,CAJD,CArFmD,CAyFhD;;;EAEHW,CAAC,GAAG,CAAJ;;EAEA,OAAOA,CAAC,KAAKP,OAAb,EAAsB;IACpB,IAAIQ,MAAM,GAAGD,CAAb;;IAEA,OAAOA,CAAC,KAAKP,OAAN,IAAiBF,KAAK,CAACS,CAAD,CAAL,CAAS,CAAT,MAAgBvC,gBAAgB,CAACyC,UAAzD,EAAqE;MACnEF,CAAC,IAAI,CAAL;IACD;;IAED,IAAIC,MAAM,KAAKD,CAAf,EAAkB;MAChB,IAAIC,MAAM,KAAK,CAAf,EAAkB;QAChB;QACA,IAAID,CAAC,GAAGN,aAAR,EAAuB;UACrBO,MAAM,GAAGD,CAAC,GAAGN,aAAb;UACAR,MAAM,GAAGe,MAAT;UACAb,MAAM,GAAGa,MAAT;UACAd,IAAI,GAAGD,MAAP;UACAG,IAAI,GAAGD,MAAP;QACD;;QAED,KAAK,IAAIyB,OAAO,GAAGZ,MAAnB,EAA2BY,OAAO,KAAKb,CAAvC,EAA0Ca,OAAO,IAAI,CAArD,EAAwD;UACtDJ,cAAc,CAAClB,KAAK,CAACsB,OAAD,CAAL,CAAe,CAAf,CAAD,CAAd;QACD;MACF,CAbD,MAaO,IAAIb,CAAC,KAAKP,OAAV,EAAmB;QACxB;QACA,MAAMqB,IAAI,GAAGd,CAAC,GAAGC,MAAJ,GAAaP,aAAb,GAA6BO,MAAM,GAAGP,aAAtC,GAAsDM,CAAnE;;QAEA,KAAK,IAAIa,OAAO,GAAGZ,MAAnB,EAA2BY,OAAO,KAAKC,IAAvC,EAA6CD,OAAO,IAAI,CAAxD,EAA2D;UACzDJ,cAAc,CAAClB,KAAK,CAACsB,OAAD,CAAL,CAAe,CAAf,CAAD,CAAd;QACD;MACF,CAPM,MAOA;QACL;QACA,MAAME,OAAO,GAAGf,CAAC,GAAGC,MAApB;;QAEA,IAAIc,OAAO,GAAGnB,cAAd,EAA8B;UAC5B,MAAMkB,IAAI,GAAGb,MAAM,GAAGP,aAAtB;;UAEA,KAAK,IAAImB,OAAO,GAAGZ,MAAnB,EAA2BY,OAAO,KAAKC,IAAvC,EAA6CD,OAAO,IAAI,CAAxD,EAA2D;YACzDJ,cAAc,CAAClB,KAAK,CAACsB,OAAD,CAAL,CAAe,CAAf,CAAD,CAAd;UACD;;UAEDP,KAAK,CAACC,UAAD,CAAL,GAAoBtB,eAAe,CACjCC,MADiC,EAEjCC,IAFiC,EAGjCC,MAHiC,EAIjCC,IAJiC,EAKjCG,OALiC,CAAnC;UAOAe,UAAU,GAAGD,KAAK,CAACjC,MAAnB;UACAiC,KAAK,CAACE,IAAN,CAAW,EAAX,EAf4B,CAeZ;;UAEhB,MAAMQ,KAAK,GAAGD,OAAO,GAAGnB,cAAxB;UACAV,MAAM,GAAGC,IAAI,GAAG6B,KAAhB;UACA5B,MAAM,GAAGC,IAAI,GAAG2B,KAAhB;UACA7B,IAAI,GAAGD,MAAP;UACAG,IAAI,GAAGD,MAAP;;UAEA,KAAK,IAAIyB,OAAO,GAAGb,CAAC,GAAGN,aAAvB,EAAsCmB,OAAO,KAAKb,CAAlD,EAAqDa,OAAO,IAAI,CAAhE,EAAmE;YACjEJ,cAAc,CAAClB,KAAK,CAACsB,OAAD,CAAL,CAAe,CAAf,CAAD,CAAd;UACD;QACF,CA1BD,MA0BO;UACL,KAAK,IAAIA,OAAO,GAAGZ,MAAnB,EAA2BY,OAAO,KAAKb,CAAvC,EAA0Ca,OAAO,IAAI,CAArD,EAAwD;YACtDJ,cAAc,CAAClB,KAAK,CAACsB,OAAD,CAAL,CAAe,CAAf,CAAD,CAAd;UACD;QACF;MACF;IACF;;IAED,OAAOb,CAAC,KAAKP,OAAN,IAAiBF,KAAK,CAACS,CAAD,CAAL,CAAS,CAAT,MAAgBvC,gBAAgB,CAACwD,WAAzD,EAAsE;MACpEN,cAAc,CAACpB,KAAK,CAACS,CAAD,CAAL,CAAS,CAAT,CAAD,CAAd;MACAA,CAAC,IAAI,CAAL;IACD;;IAED,OAAOA,CAAC,KAAKP,OAAN,IAAiBF,KAAK,CAACS,CAAD,CAAL,CAAS,CAAT,MAAgBvC,gBAAgB,CAACyD,WAAzD,EAAsE;MACpEN,cAAc,CAACrB,KAAK,CAACS,CAAD,CAAL,CAAS,CAAT,CAAD,CAAd;MACAA,CAAC,IAAI,CAAL;IACD;EACF;;EAED,IAAII,QAAJ,EAAc;IACZE,KAAK,CAACC,UAAD,CAAL,GAAoBtB,eAAe,CAACC,MAAD,EAASC,IAAT,EAAeC,MAAf,EAAuBC,IAAvB,EAA6BG,OAA7B,CAAnC;EACD;;EAED,OAAOc,KAAK,CAACa,IAAN,CAAW,IAAX,CAAP;AACD,CA/KD,C,CA+KG;AACH;AACA;AACA;;;AAEA9D,OAAO,CAACE,wBAAR,GAAmCA,wBAAnC;;AAEA,MAAMC,sBAAsB,GAAG,CAAC+B,KAAD,EAAQC,OAAR,KAC7BD,KAAK,CACF6B,GADH,CACO,CAACC,IAAD,EAAOrB,CAAP,EAAUT,KAAV,KAAoB;EACvB,MAAM3B,IAAI,GAAGyD,IAAI,CAAC,CAAD,CAAjB;EACA,MAAMpD,aAAa,GAAG+B,CAAC,KAAK,CAAN,IAAWA,CAAC,KAAKT,KAAK,CAAClB,MAAN,GAAe,CAAtD;;EAEA,QAAQgD,IAAI,CAAC,CAAD,CAAZ;IACE,KAAK5D,gBAAgB,CAACwD,WAAtB;MACE,OAAO3C,eAAe,CAACV,IAAD,EAAOK,aAAP,EAAsBuB,OAAtB,CAAtB;;IAEF,KAAK/B,gBAAgB,CAACyD,WAAtB;MACE,OAAOxC,eAAe,CAACd,IAAD,EAAOK,aAAP,EAAsBuB,OAAtB,CAAtB;;IAEF;MACE,OAAOX,eAAe,CAACjB,IAAD,EAAOK,aAAP,EAAsBuB,OAAtB,CAAtB;EARJ;AAUD,CAfH,EAgBG2B,IAhBH,CAgBQ,IAhBR,CADF;;AAmBA9D,OAAO,CAACG,sBAAR,GAAiCA,sBAAjC"},"metadata":{},"sourceType":"script"}