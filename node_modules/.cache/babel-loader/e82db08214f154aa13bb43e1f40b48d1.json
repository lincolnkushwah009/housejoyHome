{"ast":null,"code":"/*\n Copyright 2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n'use strict';\n\nconst pathutils = require('./pathutils');\n\nconst {\n  GREATEST_LOWER_BOUND,\n  LEAST_UPPER_BOUND\n} = require('source-map').SourceMapConsumer;\n/**\n * AST ranges are inclusive for start positions and exclusive for end positions.\n * Source maps are also logically ranges over text, though interacting with\n * them is generally achieved by working with explicit positions.\n *\n * When finding the _end_ location of an AST item, the range behavior is\n * important because what we're asking for is the _end_ of whatever range\n * corresponds to the end location we seek.\n *\n * This boils down to the following steps, conceptually, though the source-map\n * library doesn't expose primitives to do this nicely:\n *\n * 1. Find the range on the generated file that ends at, or exclusively\n *    contains the end position of the AST node.\n * 2. Find the range on the original file that corresponds to\n *    that generated range.\n * 3. Find the _end_ location of that original range.\n */\n\n\nfunction originalEndPositionFor(sourceMap, generatedEnd) {\n  // Given the generated location, find the original location of the mapping\n  // that corresponds to a range on the generated file that overlaps the\n  // generated file end location. Note however that this position on its\n  // own is not useful because it is the position of the _start_ of the range\n  // on the original file, and we want the _end_ of the range.\n  const beforeEndMapping = originalPositionTryBoth(sourceMap, generatedEnd.line, generatedEnd.column - 1);\n\n  if (beforeEndMapping.source === null) {\n    return null;\n  } // Convert that original position back to a generated one, with a bump\n  // to the right, and a rightward bias. Since 'generatedPositionFor' searches\n  // for mappings in the original-order sorted list, this will find the\n  // mapping that corresponds to the one immediately after the\n  // beforeEndMapping mapping.\n\n\n  const afterEndMapping = sourceMap.generatedPositionFor({\n    source: beforeEndMapping.source,\n    line: beforeEndMapping.line,\n    column: beforeEndMapping.column + 1,\n    bias: LEAST_UPPER_BOUND\n  });\n\n  if ( // If this is null, it means that we've hit the end of the file,\n  // so we can use Infinity as the end column.\n  afterEndMapping.line === null || // If these don't match, it means that the call to\n  // 'generatedPositionFor' didn't find any other original mappings on\n  // the line we gave, so consider the binding to extend to infinity.\n  sourceMap.originalPositionFor(afterEndMapping).line !== beforeEndMapping.line) {\n    return {\n      source: beforeEndMapping.source,\n      line: beforeEndMapping.line,\n      column: Infinity\n    };\n  } // Convert the end mapping into the real original position.\n\n\n  return sourceMap.originalPositionFor(afterEndMapping);\n}\n/**\n * Attempts to determine the original source position, first\n * returning the closest element to the left (GREATEST_LOWER_BOUND),\n * and next returning the closest element to the right (LEAST_UPPER_BOUND).\n */\n\n\nfunction originalPositionTryBoth(sourceMap, line, column) {\n  const mapping = sourceMap.originalPositionFor({\n    line,\n    column,\n    bias: GREATEST_LOWER_BOUND\n  });\n\n  if (mapping.source === null) {\n    return sourceMap.originalPositionFor({\n      line,\n      column,\n      bias: LEAST_UPPER_BOUND\n    });\n  } else {\n    return mapping;\n  }\n}\n\nfunction isInvalidPosition(pos) {\n  return !pos || typeof pos.line !== 'number' || typeof pos.column !== 'number' || pos.line < 0 || pos.column < 0;\n}\n/**\n * determines the original position for a given location\n * @param  {SourceMapConsumer} sourceMap the source map\n * @param  {Object} generatedLocation the original location Object\n * @returns {Object} the remapped location Object\n */\n\n\nfunction getMapping(sourceMap, generatedLocation, origFile) {\n  if (!generatedLocation) {\n    return null;\n  }\n\n  if (isInvalidPosition(generatedLocation.start) || isInvalidPosition(generatedLocation.end)) {\n    return null;\n  }\n\n  const start = originalPositionTryBoth(sourceMap, generatedLocation.start.line, generatedLocation.start.column);\n  let end = originalEndPositionFor(sourceMap, generatedLocation.end);\n  /* istanbul ignore if: edge case too hard to test for */\n\n  if (!(start && end)) {\n    return null;\n  }\n\n  if (!(start.source && end.source)) {\n    return null;\n  }\n\n  if (start.source !== end.source) {\n    return null;\n  }\n  /* istanbul ignore if: edge case too hard to test for */\n\n\n  if (start.line === null || start.column === null) {\n    return null;\n  }\n  /* istanbul ignore if: edge case too hard to test for */\n\n\n  if (end.line === null || end.column === null) {\n    return null;\n  }\n\n  if (start.line === end.line && start.column === end.column) {\n    end = sourceMap.originalPositionFor({\n      line: generatedLocation.end.line,\n      column: generatedLocation.end.column,\n      bias: LEAST_UPPER_BOUND\n    });\n    end.column -= 1;\n  }\n\n  return {\n    source: pathutils.relativeTo(start.source, origFile),\n    loc: {\n      start: {\n        line: start.line,\n        column: start.column\n      },\n      end: {\n        line: end.line,\n        column: end.column\n      }\n    }\n  };\n}\n\nmodule.exports = getMapping;","map":{"version":3,"names":["pathutils","require","GREATEST_LOWER_BOUND","LEAST_UPPER_BOUND","SourceMapConsumer","originalEndPositionFor","sourceMap","generatedEnd","beforeEndMapping","originalPositionTryBoth","line","column","source","afterEndMapping","generatedPositionFor","bias","originalPositionFor","Infinity","mapping","isInvalidPosition","pos","getMapping","generatedLocation","origFile","start","end","relativeTo","loc","module","exports"],"sources":["/Users/lincolnkushwah/Desktop/All/React Projects/house_joy_new/node_modules/istanbul-lib-source-maps/lib/get-mapping.js"],"sourcesContent":["/*\n Copyright 2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n'use strict';\n\nconst pathutils = require('./pathutils');\nconst {\n    GREATEST_LOWER_BOUND,\n    LEAST_UPPER_BOUND\n} = require('source-map').SourceMapConsumer;\n\n/**\n * AST ranges are inclusive for start positions and exclusive for end positions.\n * Source maps are also logically ranges over text, though interacting with\n * them is generally achieved by working with explicit positions.\n *\n * When finding the _end_ location of an AST item, the range behavior is\n * important because what we're asking for is the _end_ of whatever range\n * corresponds to the end location we seek.\n *\n * This boils down to the following steps, conceptually, though the source-map\n * library doesn't expose primitives to do this nicely:\n *\n * 1. Find the range on the generated file that ends at, or exclusively\n *    contains the end position of the AST node.\n * 2. Find the range on the original file that corresponds to\n *    that generated range.\n * 3. Find the _end_ location of that original range.\n */\nfunction originalEndPositionFor(sourceMap, generatedEnd) {\n    // Given the generated location, find the original location of the mapping\n    // that corresponds to a range on the generated file that overlaps the\n    // generated file end location. Note however that this position on its\n    // own is not useful because it is the position of the _start_ of the range\n    // on the original file, and we want the _end_ of the range.\n    const beforeEndMapping = originalPositionTryBoth(\n        sourceMap,\n        generatedEnd.line,\n        generatedEnd.column - 1\n    );\n    if (beforeEndMapping.source === null) {\n        return null;\n    }\n\n    // Convert that original position back to a generated one, with a bump\n    // to the right, and a rightward bias. Since 'generatedPositionFor' searches\n    // for mappings in the original-order sorted list, this will find the\n    // mapping that corresponds to the one immediately after the\n    // beforeEndMapping mapping.\n    const afterEndMapping = sourceMap.generatedPositionFor({\n        source: beforeEndMapping.source,\n        line: beforeEndMapping.line,\n        column: beforeEndMapping.column + 1,\n        bias: LEAST_UPPER_BOUND\n    });\n    if (\n        // If this is null, it means that we've hit the end of the file,\n        // so we can use Infinity as the end column.\n        afterEndMapping.line === null ||\n        // If these don't match, it means that the call to\n        // 'generatedPositionFor' didn't find any other original mappings on\n        // the line we gave, so consider the binding to extend to infinity.\n        sourceMap.originalPositionFor(afterEndMapping).line !==\n            beforeEndMapping.line\n    ) {\n        return {\n            source: beforeEndMapping.source,\n            line: beforeEndMapping.line,\n            column: Infinity\n        };\n    }\n\n    // Convert the end mapping into the real original position.\n    return sourceMap.originalPositionFor(afterEndMapping);\n}\n\n/**\n * Attempts to determine the original source position, first\n * returning the closest element to the left (GREATEST_LOWER_BOUND),\n * and next returning the closest element to the right (LEAST_UPPER_BOUND).\n */\nfunction originalPositionTryBoth(sourceMap, line, column) {\n    const mapping = sourceMap.originalPositionFor({\n        line,\n        column,\n        bias: GREATEST_LOWER_BOUND\n    });\n    if (mapping.source === null) {\n        return sourceMap.originalPositionFor({\n            line,\n            column,\n            bias: LEAST_UPPER_BOUND\n        });\n    } else {\n        return mapping;\n    }\n}\n\nfunction isInvalidPosition(pos) {\n    return (\n        !pos ||\n        typeof pos.line !== 'number' ||\n        typeof pos.column !== 'number' ||\n        pos.line < 0 ||\n        pos.column < 0\n    );\n}\n\n/**\n * determines the original position for a given location\n * @param  {SourceMapConsumer} sourceMap the source map\n * @param  {Object} generatedLocation the original location Object\n * @returns {Object} the remapped location Object\n */\nfunction getMapping(sourceMap, generatedLocation, origFile) {\n    if (!generatedLocation) {\n        return null;\n    }\n\n    if (\n        isInvalidPosition(generatedLocation.start) ||\n        isInvalidPosition(generatedLocation.end)\n    ) {\n        return null;\n    }\n\n    const start = originalPositionTryBoth(\n        sourceMap,\n        generatedLocation.start.line,\n        generatedLocation.start.column\n    );\n    let end = originalEndPositionFor(sourceMap, generatedLocation.end);\n\n    /* istanbul ignore if: edge case too hard to test for */\n    if (!(start && end)) {\n        return null;\n    }\n\n    if (!(start.source && end.source)) {\n        return null;\n    }\n\n    if (start.source !== end.source) {\n        return null;\n    }\n\n    /* istanbul ignore if: edge case too hard to test for */\n    if (start.line === null || start.column === null) {\n        return null;\n    }\n\n    /* istanbul ignore if: edge case too hard to test for */\n    if (end.line === null || end.column === null) {\n        return null;\n    }\n\n    if (start.line === end.line && start.column === end.column) {\n        end = sourceMap.originalPositionFor({\n            line: generatedLocation.end.line,\n            column: generatedLocation.end.column,\n            bias: LEAST_UPPER_BOUND\n        });\n        end.column -= 1;\n    }\n\n    return {\n        source: pathutils.relativeTo(start.source, origFile),\n        loc: {\n            start: {\n                line: start.line,\n                column: start.column\n            },\n            end: {\n                line: end.line,\n                column: end.column\n            }\n        }\n    };\n}\n\nmodule.exports = getMapping;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}